{"api":{"$":{"name":"libvirt"},"files":[{"file":[{"$":{"name":"libvirt-common"},"summary":["common macros and enums for the libvirt and libvirt-admin library"],"description":["Provides common macros and enums needed by both libvirt and libvirt-admin libraries"],"author":["Erik Skultety <eskultet@redhat.com>  Copyright (C) 2015 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"LIBVIR_CHECK_VERSION","type":"macro"}},{"$":{"symbol":"LIBVIR_VERSION_NUMBER","type":"macro"}},{"$":{"symbol":"VIR_TYPED_PARAM_FIELD_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_CONNECT_CLOSE_REASON_CLIENT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_CLOSE_REASON_EOF","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_CLOSE_REASON_ERROR","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_CLOSE_REASON_KEEPALIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_CLOSE_REASON_LAST","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_BOOLEAN","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_DOUBLE","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_INT","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_LAST","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_LLONG","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_STRING","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_STRING_OKAY","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_UINT","type":"enum"}},{"$":{"symbol":"VIR_TYPED_PARAM_ULLONG","type":"enum"}},{"$":{"symbol":"virConnectCloseReason","type":"typedef"}},{"$":{"symbol":"virTypedParameter","type":"typedef"}},{"$":{"symbol":"virTypedParameterFlags","type":"typedef"}},{"$":{"symbol":"virTypedParameterPtr","type":"typedef"}},{"$":{"symbol":"virTypedParameterType","type":"typedef"}},{"$":{"symbol":"_virTypedParameter","type":"struct"}},{"$":{"symbol":"virFreeCallback","type":"function"}},{"$":{"symbol":"virTypedParamsAddBoolean","type":"function"}},{"$":{"symbol":"virTypedParamsAddDouble","type":"function"}},{"$":{"symbol":"virTypedParamsAddFromString","type":"function"}},{"$":{"symbol":"virTypedParamsAddInt","type":"function"}},{"$":{"symbol":"virTypedParamsAddLLong","type":"function"}},{"$":{"symbol":"virTypedParamsAddString","type":"function"}},{"$":{"symbol":"virTypedParamsAddStringList","type":"function"}},{"$":{"symbol":"virTypedParamsAddUInt","type":"function"}},{"$":{"symbol":"virTypedParamsAddULLong","type":"function"}},{"$":{"symbol":"virTypedParamsClear","type":"function"}},{"$":{"symbol":"virTypedParamsFree","type":"function"}},{"$":{"symbol":"virTypedParamsGet","type":"function"}},{"$":{"symbol":"virTypedParamsGetBoolean","type":"function"}},{"$":{"symbol":"virTypedParamsGetDouble","type":"function"}},{"$":{"symbol":"virTypedParamsGetInt","type":"function"}},{"$":{"symbol":"virTypedParamsGetLLong","type":"function"}},{"$":{"symbol":"virTypedParamsGetString","type":"function"}},{"$":{"symbol":"virTypedParamsGetUInt","type":"function"}},{"$":{"symbol":"virTypedParamsGetULLong","type":"function"}}]},{"$":{"name":"libvirt-domain-snapshot"},"summary":["APIs for management of domain snapshots"],"description":["Provides APIs for the management of domain snapshots"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_HALT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_LIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_LEAVES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_METADATA","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_LIST_ROOTS","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_REVERT_FORCE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING","type":"enum"}},{"$":{"symbol":"virDomainSnapshot","type":"typedef"}},{"$":{"symbol":"virDomainSnapshotCreateFlags","type":"typedef"}},{"$":{"symbol":"virDomainSnapshotDeleteFlags","type":"typedef"}},{"$":{"symbol":"virDomainSnapshotListFlags","type":"typedef"}},{"$":{"symbol":"virDomainSnapshotPtr","type":"typedef"}},{"$":{"symbol":"virDomainSnapshotRevertFlags","type":"typedef"}},{"$":{"symbol":"virDomainHasCurrentSnapshot","type":"function"}},{"$":{"symbol":"virDomainListAllSnapshots","type":"function"}},{"$":{"symbol":"virDomainRevertToSnapshot","type":"function"}},{"$":{"symbol":"virDomainSnapshotCreateXML","type":"function"}},{"$":{"symbol":"virDomainSnapshotCurrent","type":"function"}},{"$":{"symbol":"virDomainSnapshotDelete","type":"function"}},{"$":{"symbol":"virDomainSnapshotFree","type":"function"}},{"$":{"symbol":"virDomainSnapshotGetConnect","type":"function"}},{"$":{"symbol":"virDomainSnapshotGetDomain","type":"function"}},{"$":{"symbol":"virDomainSnapshotGetName","type":"function"}},{"$":{"symbol":"virDomainSnapshotGetParent","type":"function"}},{"$":{"symbol":"virDomainSnapshotGetXMLDesc","type":"function"}},{"$":{"symbol":"virDomainSnapshotHasMetadata","type":"function"}},{"$":{"symbol":"virDomainSnapshotIsCurrent","type":"function"}},{"$":{"symbol":"virDomainSnapshotListAllChildren","type":"function"}},{"$":{"symbol":"virDomainSnapshotListChildrenNames","type":"function"}},{"$":{"symbol":"virDomainSnapshotListNames","type":"function"}},{"$":{"symbol":"virDomainSnapshotLookupByName","type":"function"}},{"$":{"symbol":"virDomainSnapshotNum","type":"function"}},{"$":{"symbol":"virDomainSnapshotNumChildren","type":"function"}},{"$":{"symbol":"virDomainSnapshotRef","type":"function"}}]},{"$":{"name":"libvirt-domain"},"summary":["APIs for management of domains"],"description":["Provides APIs for the management of domains"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2015 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_COPY_CPUMAP","type":"macro"}},{"$":{"symbol":"VIR_CPU_MAPLEN","type":"macro"}},{"$":{"symbol":"VIR_CPU_USABLE","type":"macro"}},{"$":{"symbol":"VIR_CPU_USED","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BANDWIDTH_IN_AVERAGE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BANDWIDTH_IN_BURST","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BANDWIDTH_IN_FLOOR","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BANDWIDTH_IN_PEAK","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BANDWIDTH_OUT_BURST","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BANDWIDTH_OUT_PEAK","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_DEVICE_READ_BPS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_DEVICE_WEIGHT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_FIELD_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_WEIGHT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COPY_BANDWIDTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COPY_BUF_SIZE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COPY_GRANULARITY","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_ERRS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_READ_BYTES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_READ_REQ","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_WRITE_REQ","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_CPU_STATS_CPUTIME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_CPU_STATS_SYSTEMTIME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_CPU_STATS_USERTIME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_CPU_STATS_VCPUTIME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_CALLBACK","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_COMPRESSION_BYTES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_COMPRESSION_CACHE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_COMPRESSION_PAGES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DATA_PROCESSED","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DATA_REMAINING","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DATA_TOTAL","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DISK_BPS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DISK_PROCESSED","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DISK_REMAINING","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DISK_TOTAL","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DOWNTIME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_DOWNTIME_NET","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_BPS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_CONSTANT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_ITERATION","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_NORMAL","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_PROCESSED","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_REMAINING","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_MEMORY_TOTAL","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_SETUP_TIME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_TIME_ELAPSED","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_TIME_ELAPSED_NET","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_JOB_TIME_REMAINING","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_FIELD_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_HARD_LIMIT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_MIN_GUARANTEE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_PARAM_UNLIMITED","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_SOFT_LIMIT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_NUMA_MODE","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_NUMA_NODESET","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_CAP","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_CPU_SHARES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_LIMIT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_RESERVATION","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_SHARES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_VCPU_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_VCPU_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHEDULER_WEIGHT","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SCHED_FIELD_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_SEND_KEY_MAX_KEYS","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_DISK","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_VCPUPIN","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD","type":"macro"}},{"$":{"symbol":"VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA","type":"macro"}},{"$":{"symbol":"VIR_GET_CPUMAP","type":"macro"}},{"$":{"symbol":"VIR_KEYCODE_SET_RFB","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_BANDWIDTH","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_COMPRESSION","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_DEST_NAME","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_DEST_XML","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_DISKS_PORT","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_GRAPHICS_URI","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_LISTEN_ADDRESS","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_MIGRATE_DISKS","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_PERSIST_XML","type":"macro"}},{"$":{"symbol":"VIR_MIGRATE_PARAM_URI","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_ALIGNMENT_FAULTS","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_BRANCH_INSTRUCTIONS","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_BRANCH_MISSES","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_BUS_CYCLES","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_CACHE_MISSES","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_CACHE_REFERENCES","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_CMT","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_CONTEXT_SWITCHES","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_CPU_CLOCK","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_CPU_CYCLES","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_CPU_MIGRATIONS","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_EMULATION_FAULTS","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_INSTRUCTIONS","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_MBML","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_MBMT","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_PAGE_FAULTS","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_PAGE_FAULTS_MAJ","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_PAGE_FAULTS_MIN","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_REF_CPU_CYCLES","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_STALLED_CYCLES_BACKEND","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND","type":"macro"}},{"$":{"symbol":"VIR_PERF_PARAM_TASK_CLOCK","type":"macro"}},{"$":{"symbol":"VIR_UNUSE_CPU","type":"macro"}},{"$":{"symbol":"VIR_USE_CPU","type":"macro"}},{"$":{"symbol":"_virBlkioParameter","type":"macro"}},{"$":{"symbol":"_virMemoryParameter","type":"macro"}},{"$":{"symbol":"_virSchedParameter","type":"macro"}},{"$":{"symbol":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_LAST","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_CONNECTED","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_DISCONNECTED","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_LAST","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_AUTOSTART","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_OTHER","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_PERSISTENT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_RUNNING","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_SHUTOFF","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_DOMAINS_TRANSIENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_AFFECT_CONFIG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_AFFECT_CURRENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_AFFECT_LIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_PARAM_BOOLEAN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_PARAM_DOUBLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_PARAM_INT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_PARAM_LLONG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_PARAM_UINT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLKIO_PARAM_ULLONG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCKED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCKED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCKED_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COMMIT_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COMMIT_DELETE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COMMIT_RELATIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COMMIT_SHALLOW","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COPY_REUSE_EXT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COPY_SHALLOW","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_CANCELED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_COMPLETED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_FAILED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_READY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_TYPE_COPY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_TYPE_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_TYPE_PULL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_REBASE_COPY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_REBASE_COPY_DEV","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_REBASE_COPY_RAW","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_REBASE_RELATIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_REBASE_SHALLOW","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_BLOCK_RESIZE_BYTES","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CHANNEL_FORCE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONSOLE_FORCE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONSOLE_SAFE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_ERROR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_ERROR_REASON_INTERNAL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_ERROR_REASON_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_ERROR_REASON_MONITOR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_ERROR_REASON_NONE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_ERROR_REASON_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_JOB","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_OCCUPIED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CONTROL_OK","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_LZO","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_SNAPPY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_ZLIB","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CORE_DUMP_FORMAT_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CORE_DUMP_FORMAT_RAW","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CRASHED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CRASHED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CRASHED_PANICKED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_CRASHED_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DEFINE_VALIDATE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DESTROY_DEFAULT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DESTROY_GRACEFUL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DEVICE_MODIFY_CONFIG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DEVICE_MODIFY_CURRENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DEVICE_MODIFY_FORCE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DEVICE_MODIFY_LIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DISK_ERROR_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DISK_ERROR_NONE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DISK_ERROR_NO_SPACE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_DISK_ERROR_UNSPEC","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_CRASHED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_CRASHED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_CRASHED_PANICKED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DEFINED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DEFINED_ADDED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DEFINED_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DEFINED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DEFINED_RENAMED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DEFINED_UPDATED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DISK_CHANGE_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_CONNECT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_GRAPHICS_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_BLOCK_JOB","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_CONTROL_ERROR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_DEVICE_ADDED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_DISK_CHANGE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_GRAPHICS","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_IO_ERROR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_JOB_COMPLETED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_LIFECYCLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_METADATA_CHANGE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_PMSUSPEND","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_PMWAKEUP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_REBOOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_RTC_CHANGE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_TRAY_CHANGE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_TUNABLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_ID_WATCHDOG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_IO_ERROR_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_IO_ERROR_NONE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_IO_ERROR_PAUSE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_IO_ERROR_REPORT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_PMSUSPENDED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_PMSUSPENDED_DISK","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_PMSUSPENDED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_RESUMED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_RESUMED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_RESUMED_MIGRATED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_RESUMED_POSTCOPY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_RESUMED_UNPAUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SHUTDOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SHUTDOWN_GUEST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SHUTDOWN_HOST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SHUTDOWN_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STARTED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STARTED_BOOTED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STARTED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STARTED_MIGRATED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STARTED_RESTORED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STARTED_WAKEUP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_CRASHED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_DESTROYED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_FAILED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_MIGRATED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_SAVED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_IOERROR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_RESTORED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_UNDEFINED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_UNDEFINED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_UNDEFINED_REMOVED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_UNDEFINED_RENAMED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_DEBUG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_INJECTNMI","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_NONE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_PAUSE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_RESET","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_BOUNDED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_CANCELLED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_COMPLETED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_FAILED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_NONE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_DUMP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_RESTORE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_SAVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_SNAPSHOT_REVERT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_START","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_OPERATION_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_STATS_COMPLETED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_JOB_UNBOUNDED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_ACTION_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_ACTION_RESTART","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_CRASH","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_POWEROFF","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_LIFECYCLE_REBOOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_PARAM_BOOLEAN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_PARAM_DOUBLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_PARAM_INT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_PARAM_LLONG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_PARAM_UINT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_PARAM_ULLONG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_AVAILABLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_NR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_RSS","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_SWAP_IN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_SWAP_OUT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_UNUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEMORY_STAT_USABLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEM_CONFIG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEM_CURRENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEM_LIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_MEM_MAXIMUM","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_METADATA_DESCRIPTION","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_METADATA_ELEMENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_METADATA_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_METADATA_TITLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NONE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NOSTATE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NOSTATE_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NOSTATE_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NUMATUNE_MEM_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NUMATUNE_MEM_PREFERRED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_NUMATUNE_MEM_STRICT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PASSWORD_ENCRYPTED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_CRASHED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_DUMP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_IOERROR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_MIGRATION","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_POSTCOPY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_POSTCOPY_FAILED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_SAVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_SHUTTING_DOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_STARTING_UP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_USER","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PAUSED_WATCHDOG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PMSUSPENDED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PMSUSPENDED_DISK_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PMSUSPENDED_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PMSUSPENDED_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_ABRT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_ALRM","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_BUS","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_CHLD","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_CONT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_FPE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_HUP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_ILL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_INT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_KILL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_NOP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_PIPE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_POLL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_PROF","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_PWR","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_QUIT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT0","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT1","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT10","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT11","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT12","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT13","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT14","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT15","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT16","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT17","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT18","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT19","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT2","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT20","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT21","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT22","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT23","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT24","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT25","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT26","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT27","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT28","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT29","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT3","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT30","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT31","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT32","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT4","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT5","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT6","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT7","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT8","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_RT9","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_SEGV","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_STKFLT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_STOP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_SYS","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_TERM","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_TRAP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_TSTP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_TTIN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_TTOU","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_URG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_USR1","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_USR2","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_VTALRM","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_WINCH","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_XCPU","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_PROCESS_SIGNAL_XFSZ","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_REBOOT_ACPI_POWER_BTN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_REBOOT_DEFAULT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_REBOOT_GUEST_AGENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_REBOOT_INITCTL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_REBOOT_PARAVIRT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_REBOOT_SIGNAL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_BOOTED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_CRASHED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_MIGRATED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_MIGRATION_CANCELED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_POSTCOPY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_RESTORED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_SAVE_CANCELED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_UNPAUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_RUNNING_WAKEUP","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SAVE_BYPASS_CACHE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SAVE_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SAVE_RUNNING","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SCHED_FIELD_BOOLEAN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SCHED_FIELD_DOUBLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SCHED_FIELD_INT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SCHED_FIELD_LLONG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SCHED_FIELD_UINT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SCHED_FIELD_ULLONG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_DEFAULT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_GUEST_AGENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_INITCTL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_PARAVIRT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_SIGNAL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTDOWN_USER","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_CRASHED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_DESTROYED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_FAILED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_LAST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_MIGRATED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_SAVED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_SHUTDOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_SHUTOFF_UNKNOWN","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_START_AUTODESTROY","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_START_BYPASS_CACHE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_START_FORCE_BOOT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_START_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_START_VALIDATE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_STATS_BALLOON","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_STATS_BLOCK","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_STATS_CPU_TOTAL","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_STATS_INTERFACE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_STATS_PERF","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_STATS_STATE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_STATS_VCPU","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_TIME_SYNC","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_UNDEFINE_KEEP_NVRAM","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_UNDEFINE_MANAGED_SAVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_UNDEFINE_NVRAM","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_VCPU_CONFIG","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_VCPU_CURRENT","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_VCPU_GUEST","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_VCPU_HOTPLUGGABLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_VCPU_LIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_VCPU_MAXIMUM","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_XML_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_XML_MIGRATABLE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_XML_SECURE","type":"enum"}},{"$":{"symbol":"VIR_DOMAIN_XML_UPDATE_CPU","type":"enum"}},{"$":{"symbol":"VIR_DUMP_BYPASS_CACHE","type":"enum"}},{"$":{"symbol":"VIR_DUMP_CRASH","type":"enum"}},{"$":{"symbol":"VIR_DUMP_LIVE","type":"enum"}},{"$":{"symbol":"VIR_DUMP_MEMORY_ONLY","type":"enum"}},{"$":{"symbol":"VIR_DUMP_RESET","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_ATSET1","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_ATSET2","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_ATSET3","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_LAST","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_LINUX","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_OSX","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_QNUM","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_USB","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_WIN32","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_XT","type":"enum"}},{"$":{"symbol":"VIR_KEYCODE_SET_XT_KBD","type":"enum"}},{"$":{"symbol":"VIR_MEMORY_PHYSICAL","type":"enum"}},{"$":{"symbol":"VIR_MEMORY_VIRTUAL","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_ABORT_ON_ERROR","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_AUTO_CONVERGE","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_CHANGE_PROTECTION","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_COMPRESSED","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_LIVE","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_NON_SHARED_DISK","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_NON_SHARED_INC","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_OFFLINE","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_PAUSED","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_PEER2PEER","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_PERSIST_DEST","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_POSTCOPY","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_RDMA_PIN_ALL","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_TLS","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_TUNNELLED","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_UNDEFINE_SOURCE","type":"enum"}},{"$":{"symbol":"VIR_MIGRATE_UNSAFE","type":"enum"}},{"$":{"symbol":"VIR_VCPU_BLOCKED","type":"enum"}},{"$":{"symbol":"VIR_VCPU_LAST","type":"enum"}},{"$":{"symbol":"VIR_VCPU_OFFLINE","type":"enum"}},{"$":{"symbol":"VIR_VCPU_RUNNING","type":"enum"}},{"$":{"symbol":"virBlkioParameter","type":"typedef"}},{"$":{"symbol":"virBlkioParameterPtr","type":"typedef"}},{"$":{"symbol":"virBlkioParameterType","type":"typedef"}},{"$":{"symbol":"virConnectDomainEventAgentLifecycleReason","type":"typedef"}},{"$":{"symbol":"virConnectDomainEventAgentLifecycleState","type":"typedef"}},{"$":{"symbol":"virConnectDomainEventBlockJobStatus","type":"typedef"}},{"$":{"symbol":"virConnectDomainEventDiskChangeReason","type":"typedef"}},{"$":{"symbol":"virConnectGetAllDomainStatsFlags","type":"typedef"}},{"$":{"symbol":"virConnectListAllDomainsFlags","type":"typedef"}},{"$":{"symbol":"virDomain","type":"typedef"}},{"$":{"symbol":"virDomainBlockCommitFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockCopyFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockInfo","type":"typedef"}},{"$":{"symbol":"virDomainBlockInfoPtr","type":"typedef"}},{"$":{"symbol":"virDomainBlockJobAbortFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockJobCursor","type":"typedef"}},{"$":{"symbol":"virDomainBlockJobInfo","type":"typedef"}},{"$":{"symbol":"virDomainBlockJobInfoFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockJobInfoPtr","type":"typedef"}},{"$":{"symbol":"virDomainBlockJobSetSpeedFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockJobType","type":"typedef"}},{"$":{"symbol":"virDomainBlockPullFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockRebaseFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockResizeFlags","type":"typedef"}},{"$":{"symbol":"virDomainBlockStatsPtr","type":"typedef"}},{"$":{"symbol":"virDomainBlockStatsStruct","type":"typedef"}},{"$":{"symbol":"virDomainBlockedReason","type":"typedef"}},{"$":{"symbol":"virDomainChannelFlags","type":"typedef"}},{"$":{"symbol":"virDomainConsoleFlags","type":"typedef"}},{"$":{"symbol":"virDomainControlErrorReason","type":"typedef"}},{"$":{"symbol":"virDomainControlInfo","type":"typedef"}},{"$":{"symbol":"virDomainControlInfoPtr","type":"typedef"}},{"$":{"symbol":"virDomainControlState","type":"typedef"}},{"$":{"symbol":"virDomainCoreDumpFlags","type":"typedef"}},{"$":{"symbol":"virDomainCoreDumpFormat","type":"typedef"}},{"$":{"symbol":"virDomainCrashedReason","type":"typedef"}},{"$":{"symbol":"virDomainCreateFlags","type":"typedef"}},{"$":{"symbol":"virDomainDefineFlags","type":"typedef"}},{"$":{"symbol":"virDomainDestroyFlagsValues","type":"typedef"}},{"$":{"symbol":"virDomainDeviceModifyFlags","type":"typedef"}},{"$":{"symbol":"virDomainDiskError","type":"typedef"}},{"$":{"symbol":"virDomainDiskErrorCode","type":"typedef"}},{"$":{"symbol":"virDomainDiskErrorPtr","type":"typedef"}},{"$":{"symbol":"virDomainEventCrashedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventDefinedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsAddress","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsAddressPtr","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsAddressType","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsPhase","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsSubject","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsSubjectIdentity","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsSubjectIdentityPtr","type":"typedef"}},{"$":{"symbol":"virDomainEventGraphicsSubjectPtr","type":"typedef"}},{"$":{"symbol":"virDomainEventID","type":"typedef"}},{"$":{"symbol":"virDomainEventIOErrorAction","type":"typedef"}},{"$":{"symbol":"virDomainEventPMSuspendedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventResumedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventShutdownDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventStartedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventStoppedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventSuspendedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventTrayChangeReason","type":"typedef"}},{"$":{"symbol":"virDomainEventType","type":"typedef"}},{"$":{"symbol":"virDomainEventUndefinedDetailType","type":"typedef"}},{"$":{"symbol":"virDomainEventWatchdogAction","type":"typedef"}},{"$":{"symbol":"virDomainFSInfo","type":"typedef"}},{"$":{"symbol":"virDomainFSInfoPtr","type":"typedef"}},{"$":{"symbol":"virDomainGetJobStatsFlags","type":"typedef"}},{"$":{"symbol":"virDomainIOThreadInfo","type":"typedef"}},{"$":{"symbol":"virDomainIOThreadInfoPtr","type":"typedef"}},{"$":{"symbol":"virDomainIPAddress","type":"typedef"}},{"$":{"symbol":"virDomainIPAddressPtr","type":"typedef"}},{"$":{"symbol":"virDomainInfo","type":"typedef"}},{"$":{"symbol":"virDomainInfoPtr","type":"typedef"}},{"$":{"symbol":"virDomainInterface","type":"typedef"}},{"$":{"symbol":"virDomainInterfaceAddressesSource","type":"typedef"}},{"$":{"symbol":"virDomainInterfacePtr","type":"typedef"}},{"$":{"symbol":"virDomainInterfaceStatsPtr","type":"typedef"}},{"$":{"symbol":"virDomainInterfaceStatsStruct","type":"typedef"}},{"$":{"symbol":"virDomainJobInfo","type":"typedef"}},{"$":{"symbol":"virDomainJobInfoPtr","type":"typedef"}},{"$":{"symbol":"virDomainJobOperation","type":"typedef"}},{"$":{"symbol":"virDomainJobType","type":"typedef"}},{"$":{"symbol":"virDomainLifecycle","type":"typedef"}},{"$":{"symbol":"virDomainLifecycleAction","type":"typedef"}},{"$":{"symbol":"virDomainMemoryFlags","type":"typedef"}},{"$":{"symbol":"virDomainMemoryModFlags","type":"typedef"}},{"$":{"symbol":"virDomainMemoryStatPtr","type":"typedef"}},{"$":{"symbol":"virDomainMemoryStatStruct","type":"typedef"}},{"$":{"symbol":"virDomainMemoryStatTags","type":"typedef"}},{"$":{"symbol":"virDomainMetadataType","type":"typedef"}},{"$":{"symbol":"virDomainMigrateFlags","type":"typedef"}},{"$":{"symbol":"virDomainModificationImpact","type":"typedef"}},{"$":{"symbol":"virDomainNostateReason","type":"typedef"}},{"$":{"symbol":"virDomainNumatuneMemMode","type":"typedef"}},{"$":{"symbol":"virDomainOpenGraphicsFlags","type":"typedef"}},{"$":{"symbol":"virDomainPMSuspendedDiskReason","type":"typedef"}},{"$":{"symbol":"virDomainPMSuspendedReason","type":"typedef"}},{"$":{"symbol":"virDomainPausedReason","type":"typedef"}},{"$":{"symbol":"virDomainProcessSignal","type":"typedef"}},{"$":{"symbol":"virDomainPtr","type":"typedef"}},{"$":{"symbol":"virDomainRebootFlagValues","type":"typedef"}},{"$":{"symbol":"virDomainRunningReason","type":"typedef"}},{"$":{"symbol":"virDomainSaveRestoreFlags","type":"typedef"}},{"$":{"symbol":"virDomainSetTimeFlags","type":"typedef"}},{"$":{"symbol":"virDomainSetUserPasswordFlags","type":"typedef"}},{"$":{"symbol":"virDomainShutdownFlagValues","type":"typedef"}},{"$":{"symbol":"virDomainShutdownReason","type":"typedef"}},{"$":{"symbol":"virDomainShutoffReason","type":"typedef"}},{"$":{"symbol":"virDomainState","type":"typedef"}},{"$":{"symbol":"virDomainStatsRecord","type":"typedef"}},{"$":{"symbol":"virDomainStatsRecordPtr","type":"typedef"}},{"$":{"symbol":"virDomainStatsTypes","type":"typedef"}},{"$":{"symbol":"virDomainUndefineFlagsValues","type":"typedef"}},{"$":{"symbol":"virDomainVcpuFlags","type":"typedef"}},{"$":{"symbol":"virDomainXMLFlags","type":"typedef"}},{"$":{"symbol":"virKeycodeSet","type":"typedef"}},{"$":{"symbol":"virMemoryParameter","type":"typedef"}},{"$":{"symbol":"virMemoryParameterPtr","type":"typedef"}},{"$":{"symbol":"virMemoryParameterType","type":"typedef"}},{"$":{"symbol":"virSchedParameter","type":"typedef"}},{"$":{"symbol":"virSchedParameterPtr","type":"typedef"}},{"$":{"symbol":"virSchedParameterType","type":"typedef"}},{"$":{"symbol":"virVcpuInfo","type":"typedef"}},{"$":{"symbol":"virVcpuInfoPtr","type":"typedef"}},{"$":{"symbol":"virVcpuState","type":"typedef"}},{"$":{"symbol":"_virDomainBlockInfo","type":"struct"}},{"$":{"symbol":"_virDomainBlockJobInfo","type":"struct"}},{"$":{"symbol":"_virDomainBlockStats","type":"struct"}},{"$":{"symbol":"_virDomainControlInfo","type":"struct"}},{"$":{"symbol":"_virDomainDiskError","type":"struct"}},{"$":{"symbol":"_virDomainEventGraphicsAddress","type":"struct"}},{"$":{"symbol":"_virDomainEventGraphicsSubject","type":"struct"}},{"$":{"symbol":"_virDomainEventGraphicsSubjectIdentity","type":"struct"}},{"$":{"symbol":"_virDomainFSInfo","type":"struct"}},{"$":{"symbol":"_virDomainIOThreadInfo","type":"struct"}},{"$":{"symbol":"_virDomainInfo","type":"struct"}},{"$":{"symbol":"_virDomainInterface","type":"struct"}},{"$":{"symbol":"_virDomainInterfaceIPAddress","type":"struct"}},{"$":{"symbol":"_virDomainInterfaceStats","type":"struct"}},{"$":{"symbol":"_virDomainJobInfo","type":"struct"}},{"$":{"symbol":"_virDomainMemoryStat","type":"struct"}},{"$":{"symbol":"_virDomainStatsRecord","type":"struct"}},{"$":{"symbol":"_virVcpuInfo","type":"struct"}},{"$":{"symbol":"virConnectDomainEventAgentLifecycleCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventBalloonChangeCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventBlockJobCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventBlockThresholdCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventDeregister","type":"function"}},{"$":{"symbol":"virConnectDomainEventDeregisterAny","type":"function"}},{"$":{"symbol":"virConnectDomainEventDeviceAddedCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventDeviceRemovalFailedCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventDeviceRemovedCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventDiskChangeCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventGenericCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventGraphicsCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventIOErrorCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventIOErrorReasonCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventJobCompletedCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventMetadataChangeCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventMigrationIterationCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventPMSuspendCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventPMSuspendDiskCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventPMWakeupCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventRTCChangeCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventRegister","type":"function"}},{"$":{"symbol":"virConnectDomainEventRegisterAny","type":"function"}},{"$":{"symbol":"virConnectDomainEventTrayChangeCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventTunableCallback","type":"function"}},{"$":{"symbol":"virConnectDomainEventWatchdogCallback","type":"function"}},{"$":{"symbol":"virConnectDomainXMLFromNative","type":"function"}},{"$":{"symbol":"virConnectDomainXMLToNative","type":"function"}},{"$":{"symbol":"virConnectGetAllDomainStats","type":"function"}},{"$":{"symbol":"virConnectGetDomainCapabilities","type":"function"}},{"$":{"symbol":"virConnectListAllDomains","type":"function"}},{"$":{"symbol":"virConnectListDefinedDomains","type":"function"}},{"$":{"symbol":"virConnectListDomains","type":"function"}},{"$":{"symbol":"virConnectNumOfDefinedDomains","type":"function"}},{"$":{"symbol":"virConnectNumOfDomains","type":"function"}},{"$":{"symbol":"virDomainAbortJob","type":"function"}},{"$":{"symbol":"virDomainAddIOThread","type":"function"}},{"$":{"symbol":"virDomainAttachDevice","type":"function"}},{"$":{"symbol":"virDomainAttachDeviceFlags","type":"function"}},{"$":{"symbol":"virDomainBlockCommit","type":"function"}},{"$":{"symbol":"virDomainBlockCopy","type":"function"}},{"$":{"symbol":"virDomainBlockJobAbort","type":"function"}},{"$":{"symbol":"virDomainBlockJobSetSpeed","type":"function"}},{"$":{"symbol":"virDomainBlockPeek","type":"function"}},{"$":{"symbol":"virDomainBlockPull","type":"function"}},{"$":{"symbol":"virDomainBlockRebase","type":"function"}},{"$":{"symbol":"virDomainBlockResize","type":"function"}},{"$":{"symbol":"virDomainBlockStats","type":"function"}},{"$":{"symbol":"virDomainBlockStatsFlags","type":"function"}},{"$":{"symbol":"virDomainCoreDump","type":"function"}},{"$":{"symbol":"virDomainCoreDumpWithFormat","type":"function"}},{"$":{"symbol":"virDomainCreate","type":"function"}},{"$":{"symbol":"virDomainCreateLinux","type":"function"}},{"$":{"symbol":"virDomainCreateWithFiles","type":"function"}},{"$":{"symbol":"virDomainCreateWithFlags","type":"function"}},{"$":{"symbol":"virDomainCreateXML","type":"function"}},{"$":{"symbol":"virDomainCreateXMLWithFiles","type":"function"}},{"$":{"symbol":"virDomainDefineXML","type":"function"}},{"$":{"symbol":"virDomainDefineXMLFlags","type":"function"}},{"$":{"symbol":"virDomainDelIOThread","type":"function"}},{"$":{"symbol":"virDomainDestroy","type":"function"}},{"$":{"symbol":"virDomainDestroyFlags","type":"function"}},{"$":{"symbol":"virDomainDetachDevice","type":"function"}},{"$":{"symbol":"virDomainDetachDeviceFlags","type":"function"}},{"$":{"symbol":"virDomainFSFreeze","type":"function"}},{"$":{"symbol":"virDomainFSInfoFree","type":"function"}},{"$":{"symbol":"virDomainFSThaw","type":"function"}},{"$":{"symbol":"virDomainFSTrim","type":"function"}},{"$":{"symbol":"virDomainFree","type":"function"}},{"$":{"symbol":"virDomainGetAutostart","type":"function"}},{"$":{"symbol":"virDomainGetBlkioParameters","type":"function"}},{"$":{"symbol":"virDomainGetBlockInfo","type":"function"}},{"$":{"symbol":"virDomainGetBlockIoTune","type":"function"}},{"$":{"symbol":"virDomainGetBlockJobInfo","type":"function"}},{"$":{"symbol":"virDomainGetCPUStats","type":"function"}},{"$":{"symbol":"virDomainGetConnect","type":"function"}},{"$":{"symbol":"virDomainGetControlInfo","type":"function"}},{"$":{"symbol":"virDomainGetDiskErrors","type":"function"}},{"$":{"symbol":"virDomainGetEmulatorPinInfo","type":"function"}},{"$":{"symbol":"virDomainGetFSInfo","type":"function"}},{"$":{"symbol":"virDomainGetGuestVcpus","type":"function"}},{"$":{"symbol":"virDomainGetHostname","type":"function"}},{"$":{"symbol":"virDomainGetID","type":"function"}},{"$":{"symbol":"virDomainGetIOThreadInfo","type":"function"}},{"$":{"symbol":"virDomainGetInfo","type":"function"}},{"$":{"symbol":"virDomainGetInterfaceParameters","type":"function"}},{"$":{"symbol":"virDomainGetJobInfo","type":"function"}},{"$":{"symbol":"virDomainGetJobStats","type":"function"}},{"$":{"symbol":"virDomainGetMaxMemory","type":"function"}},{"$":{"symbol":"virDomainGetMaxVcpus","type":"function"}},{"$":{"symbol":"virDomainGetMemoryParameters","type":"function"}},{"$":{"symbol":"virDomainGetMetadata","type":"function"}},{"$":{"symbol":"virDomainGetName","type":"function"}},{"$":{"symbol":"virDomainGetNumaParameters","type":"function"}},{"$":{"symbol":"virDomainGetOSType","type":"function"}},{"$":{"symbol":"virDomainGetPerfEvents","type":"function"}},{"$":{"symbol":"virDomainGetSchedulerParameters","type":"function"}},{"$":{"symbol":"virDomainGetSchedulerParametersFlags","type":"function"}},{"$":{"symbol":"virDomainGetSchedulerType","type":"function"}},{"$":{"symbol":"virDomainGetSecurityLabel","type":"function"}},{"$":{"symbol":"virDomainGetSecurityLabelList","type":"function"}},{"$":{"symbol":"virDomainGetState","type":"function"}},{"$":{"symbol":"virDomainGetTime","type":"function"}},{"$":{"symbol":"virDomainGetUUID","type":"function"}},{"$":{"symbol":"virDomainGetUUIDString","type":"function"}},{"$":{"symbol":"virDomainGetVcpuPinInfo","type":"function"}},{"$":{"symbol":"virDomainGetVcpus","type":"function"}},{"$":{"symbol":"virDomainGetVcpusFlags","type":"function"}},{"$":{"symbol":"virDomainGetXMLDesc","type":"function"}},{"$":{"symbol":"virDomainHasManagedSaveImage","type":"function"}},{"$":{"symbol":"virDomainIOThreadInfoFree","type":"function"}},{"$":{"symbol":"virDomainInjectNMI","type":"function"}},{"$":{"symbol":"virDomainInterfaceAddresses","type":"function"}},{"$":{"symbol":"virDomainInterfaceFree","type":"function"}},{"$":{"symbol":"virDomainInterfaceStats","type":"function"}},{"$":{"symbol":"virDomainIsActive","type":"function"}},{"$":{"symbol":"virDomainIsPersistent","type":"function"}},{"$":{"symbol":"virDomainIsUpdated","type":"function"}},{"$":{"symbol":"virDomainListGetStats","type":"function"}},{"$":{"symbol":"virDomainLookupByID","type":"function"}},{"$":{"symbol":"virDomainLookupByName","type":"function"}},{"$":{"symbol":"virDomainLookupByUUID","type":"function"}},{"$":{"symbol":"virDomainLookupByUUIDString","type":"function"}},{"$":{"symbol":"virDomainManagedSave","type":"function"}},{"$":{"symbol":"virDomainManagedSaveDefineXML","type":"function"}},{"$":{"symbol":"virDomainManagedSaveGetXMLDesc","type":"function"}},{"$":{"symbol":"virDomainManagedSaveRemove","type":"function"}},{"$":{"symbol":"virDomainMemoryPeek","type":"function"}},{"$":{"symbol":"virDomainMemoryStats","type":"function"}},{"$":{"symbol":"virDomainMigrate","type":"function"}},{"$":{"symbol":"virDomainMigrate2","type":"function"}},{"$":{"symbol":"virDomainMigrate3","type":"function"}},{"$":{"symbol":"virDomainMigrateGetCompressionCache","type":"function"}},{"$":{"symbol":"virDomainMigrateGetMaxDowntime","type":"function"}},{"$":{"symbol":"virDomainMigrateGetMaxSpeed","type":"function"}},{"$":{"symbol":"virDomainMigrateSetCompressionCache","type":"function"}},{"$":{"symbol":"virDomainMigrateSetMaxDowntime","type":"function"}},{"$":{"symbol":"virDomainMigrateSetMaxSpeed","type":"function"}},{"$":{"symbol":"virDomainMigrateStartPostCopy","type":"function"}},{"$":{"symbol":"virDomainMigrateToURI","type":"function"}},{"$":{"symbol":"virDomainMigrateToURI2","type":"function"}},{"$":{"symbol":"virDomainMigrateToURI3","type":"function"}},{"$":{"symbol":"virDomainOpenChannel","type":"function"}},{"$":{"symbol":"virDomainOpenConsole","type":"function"}},{"$":{"symbol":"virDomainOpenGraphics","type":"function"}},{"$":{"symbol":"virDomainOpenGraphicsFD","type":"function"}},{"$":{"symbol":"virDomainPMSuspendForDuration","type":"function"}},{"$":{"symbol":"virDomainPMWakeup","type":"function"}},{"$":{"symbol":"virDomainPinEmulator","type":"function"}},{"$":{"symbol":"virDomainPinIOThread","type":"function"}},{"$":{"symbol":"virDomainPinVcpu","type":"function"}},{"$":{"symbol":"virDomainPinVcpuFlags","type":"function"}},{"$":{"symbol":"virDomainReboot","type":"function"}},{"$":{"symbol":"virDomainRef","type":"function"}},{"$":{"symbol":"virDomainRename","type":"function"}},{"$":{"symbol":"virDomainReset","type":"function"}},{"$":{"symbol":"virDomainRestore","type":"function"}},{"$":{"symbol":"virDomainRestoreFlags","type":"function"}},{"$":{"symbol":"virDomainResume","type":"function"}},{"$":{"symbol":"virDomainSave","type":"function"}},{"$":{"symbol":"virDomainSaveFlags","type":"function"}},{"$":{"symbol":"virDomainSaveImageDefineXML","type":"function"}},{"$":{"symbol":"virDomainSaveImageGetXMLDesc","type":"function"}},{"$":{"symbol":"virDomainScreenshot","type":"function"}},{"$":{"symbol":"virDomainSendKey","type":"function"}},{"$":{"symbol":"virDomainSendProcessSignal","type":"function"}},{"$":{"symbol":"virDomainSetAutostart","type":"function"}},{"$":{"symbol":"virDomainSetBlkioParameters","type":"function"}},{"$":{"symbol":"virDomainSetBlockIoTune","type":"function"}},{"$":{"symbol":"virDomainSetBlockThreshold","type":"function"}},{"$":{"symbol":"virDomainSetGuestVcpus","type":"function"}},{"$":{"symbol":"virDomainSetInterfaceParameters","type":"function"}},{"$":{"symbol":"virDomainSetLifecycleAction","type":"function"}},{"$":{"symbol":"virDomainSetMaxMemory","type":"function"}},{"$":{"symbol":"virDomainSetMemory","type":"function"}},{"$":{"symbol":"virDomainSetMemoryFlags","type":"function"}},{"$":{"symbol":"virDomainSetMemoryParameters","type":"function"}},{"$":{"symbol":"virDomainSetMemoryStatsPeriod","type":"function"}},{"$":{"symbol":"virDomainSetMetadata","type":"function"}},{"$":{"symbol":"virDomainSetNumaParameters","type":"function"}},{"$":{"symbol":"virDomainSetPerfEvents","type":"function"}},{"$":{"symbol":"virDomainSetSchedulerParameters","type":"function"}},{"$":{"symbol":"virDomainSetSchedulerParametersFlags","type":"function"}},{"$":{"symbol":"virDomainSetTime","type":"function"}},{"$":{"symbol":"virDomainSetUserPassword","type":"function"}},{"$":{"symbol":"virDomainSetVcpu","type":"function"}},{"$":{"symbol":"virDomainSetVcpus","type":"function"}},{"$":{"symbol":"virDomainSetVcpusFlags","type":"function"}},{"$":{"symbol":"virDomainShutdown","type":"function"}},{"$":{"symbol":"virDomainShutdownFlags","type":"function"}},{"$":{"symbol":"virDomainStatsRecordListFree","type":"function"}},{"$":{"symbol":"virDomainSuspend","type":"function"}},{"$":{"symbol":"virDomainUndefine","type":"function"}},{"$":{"symbol":"virDomainUndefineFlags","type":"function"}},{"$":{"symbol":"virDomainUpdateDeviceFlags","type":"function"}}]},{"$":{"name":"libvirt-event"},"summary":["APIs for management of events"],"description":["Provides APIs for the management of events"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_EVENT_HANDLE_ERROR","type":"enum"}},{"$":{"symbol":"VIR_EVENT_HANDLE_HANGUP","type":"enum"}},{"$":{"symbol":"VIR_EVENT_HANDLE_READABLE","type":"enum"}},{"$":{"symbol":"VIR_EVENT_HANDLE_WRITABLE","type":"enum"}},{"$":{"symbol":"virEventHandleType","type":"typedef"}},{"$":{"symbol":"virEventAddHandle","type":"function"}},{"$":{"symbol":"virEventAddHandleFunc","type":"function"}},{"$":{"symbol":"virEventAddTimeout","type":"function"}},{"$":{"symbol":"virEventAddTimeoutFunc","type":"function"}},{"$":{"symbol":"virEventHandleCallback","type":"function"}},{"$":{"symbol":"virEventRegisterDefaultImpl","type":"function"}},{"$":{"symbol":"virEventRegisterImpl","type":"function"}},{"$":{"symbol":"virEventRemoveHandle","type":"function"}},{"$":{"symbol":"virEventRemoveHandleFunc","type":"function"}},{"$":{"symbol":"virEventRemoveTimeout","type":"function"}},{"$":{"symbol":"virEventRemoveTimeoutFunc","type":"function"}},{"$":{"symbol":"virEventRunDefaultImpl","type":"function"}},{"$":{"symbol":"virEventTimeoutCallback","type":"function"}},{"$":{"symbol":"virEventUpdateHandle","type":"function"}},{"$":{"symbol":"virEventUpdateHandleFunc","type":"function"}},{"$":{"symbol":"virEventUpdateTimeout","type":"function"}},{"$":{"symbol":"virEventUpdateTimeoutFunc","type":"function"}}]},{"$":{"name":"libvirt-host"},"summary":["APIs for management of hosts"],"description":["Provides APIs for the management of hosts"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_NODEINFO_MAXCPUS","type":"macro"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_FIELD_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_IDLE","type":"macro"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_INTR","type":"macro"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_IOWAIT","type":"macro"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_KERNEL","type":"macro"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_USER","type":"macro"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_UTILIZATION","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_FULL_SCANS","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_PAGES_SHARED","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_PAGES_SHARING","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_PAGES_UNSHARED","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_PAGES_VOLATILE","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_STATS_BUFFERS","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_STATS_CACHED","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_STATS_FIELD_LENGTH","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_STATS_FREE","type":"macro"}},{"$":{"symbol":"VIR_NODE_MEMORY_STATS_TOTAL","type":"macro"}},{"$":{"symbol":"VIR_SECURITY_DOI_BUFLEN","type":"macro"}},{"$":{"symbol":"VIR_SECURITY_LABEL_BUFLEN","type":"macro"}},{"$":{"symbol":"VIR_SECURITY_MODEL_BUFLEN","type":"macro"}},{"$":{"symbol":"VIR_UUID_BUFLEN","type":"macro"}},{"$":{"symbol":"VIR_UUID_STRING_BUFLEN","type":"macro"}},{"$":{"symbol":"VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_BASELINE_CPU_MIGRATABLE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_COMPARE_CPU_FAIL_INCOMPATIBLE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_NO_ALIASES","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_RO","type":"enum"}},{"$":{"symbol":"VIR_CPU_COMPARE_ERROR","type":"enum"}},{"$":{"symbol":"VIR_CPU_COMPARE_IDENTICAL","type":"enum"}},{"$":{"symbol":"VIR_CPU_COMPARE_INCOMPATIBLE","type":"enum"}},{"$":{"symbol":"VIR_CPU_COMPARE_LAST","type":"enum"}},{"$":{"symbol":"VIR_CPU_COMPARE_SUPERSET","type":"enum"}},{"$":{"symbol":"VIR_CRED_AUTHNAME","type":"enum"}},{"$":{"symbol":"VIR_CRED_CNONCE","type":"enum"}},{"$":{"symbol":"VIR_CRED_ECHOPROMPT","type":"enum"}},{"$":{"symbol":"VIR_CRED_EXTERNAL","type":"enum"}},{"$":{"symbol":"VIR_CRED_LANGUAGE","type":"enum"}},{"$":{"symbol":"VIR_CRED_LAST","type":"enum"}},{"$":{"symbol":"VIR_CRED_NOECHOPROMPT","type":"enum"}},{"$":{"symbol":"VIR_CRED_PASSPHRASE","type":"enum"}},{"$":{"symbol":"VIR_CRED_REALM","type":"enum"}},{"$":{"symbol":"VIR_CRED_USERNAME","type":"enum"}},{"$":{"symbol":"VIR_NODE_ALLOC_PAGES_ADD","type":"enum"}},{"$":{"symbol":"VIR_NODE_ALLOC_PAGES_SET","type":"enum"}},{"$":{"symbol":"VIR_NODE_CPU_STATS_ALL_CPUS","type":"enum"}},{"$":{"symbol":"VIR_NODE_MEMORY_STATS_ALL_CELLS","type":"enum"}},{"$":{"symbol":"VIR_NODE_SUSPEND_TARGET_DISK","type":"enum"}},{"$":{"symbol":"VIR_NODE_SUSPEND_TARGET_HYBRID","type":"enum"}},{"$":{"symbol":"VIR_NODE_SUSPEND_TARGET_LAST","type":"enum"}},{"$":{"symbol":"VIR_NODE_SUSPEND_TARGET_MEM","type":"enum"}},{"$":{"symbol":"virCPUCompareResult","type":"typedef"}},{"$":{"symbol":"virConnect","type":"typedef"}},{"$":{"symbol":"virConnectAuth","type":"typedef"}},{"$":{"symbol":"virConnectAuthPtr","type":"typedef"}},{"$":{"symbol":"virConnectBaselineCPUFlags","type":"typedef"}},{"$":{"symbol":"virConnectCompareCPUFlags","type":"typedef"}},{"$":{"symbol":"virConnectCredential","type":"typedef"}},{"$":{"symbol":"virConnectCredentialPtr","type":"typedef"}},{"$":{"symbol":"virConnectCredentialType","type":"typedef"}},{"$":{"symbol":"virConnectFlags","type":"typedef"}},{"$":{"symbol":"virConnectPtr","type":"typedef"}},{"$":{"symbol":"virNodeAllocPagesFlags","type":"typedef"}},{"$":{"symbol":"virNodeCPUStats","type":"typedef"}},{"$":{"symbol":"virNodeCPUStatsPtr","type":"typedef"}},{"$":{"symbol":"virNodeGetCPUStatsAllCPUs","type":"typedef"}},{"$":{"symbol":"virNodeGetMemoryStatsAllCells","type":"typedef"}},{"$":{"symbol":"virNodeInfo","type":"typedef"}},{"$":{"symbol":"virNodeInfoPtr","type":"typedef"}},{"$":{"symbol":"virNodeMemoryStats","type":"typedef"}},{"$":{"symbol":"virNodeMemoryStatsPtr","type":"typedef"}},{"$":{"symbol":"virNodeSuspendTarget","type":"typedef"}},{"$":{"symbol":"virSecurityLabel","type":"typedef"}},{"$":{"symbol":"virSecurityLabelPtr","type":"typedef"}},{"$":{"symbol":"virSecurityModel","type":"typedef"}},{"$":{"symbol":"virSecurityModelPtr","type":"typedef"}},{"$":{"symbol":"virStream","type":"typedef"}},{"$":{"symbol":"virStreamPtr","type":"typedef"}},{"$":{"symbol":"_virConnectAuth","type":"struct"}},{"$":{"symbol":"_virConnectCredential","type":"struct"}},{"$":{"symbol":"_virNodeCPUStats","type":"struct"}},{"$":{"symbol":"_virNodeInfo","type":"struct"}},{"$":{"symbol":"_virNodeMemoryStats","type":"struct"}},{"$":{"symbol":"_virSecurityLabel","type":"struct"}},{"$":{"symbol":"_virSecurityModel","type":"struct"}},{"$":{"symbol":"virConnectAuthPtrDefault","type":"variable"}},{"$":{"symbol":"virConnectAuthCallbackPtr","type":"function"}},{"$":{"symbol":"virConnectBaselineCPU","type":"function"}},{"$":{"symbol":"virConnectClose","type":"function"}},{"$":{"symbol":"virConnectCloseFunc","type":"function"}},{"$":{"symbol":"virConnectCompareCPU","type":"function"}},{"$":{"symbol":"virConnectGetCPUModelNames","type":"function"}},{"$":{"symbol":"virConnectGetCapabilities","type":"function"}},{"$":{"symbol":"virConnectGetHostname","type":"function"}},{"$":{"symbol":"virConnectGetLibVersion","type":"function"}},{"$":{"symbol":"virConnectGetMaxVcpus","type":"function"}},{"$":{"symbol":"virConnectGetSysinfo","type":"function"}},{"$":{"symbol":"virConnectGetType","type":"function"}},{"$":{"symbol":"virConnectGetURI","type":"function"}},{"$":{"symbol":"virConnectGetVersion","type":"function"}},{"$":{"symbol":"virConnectIsAlive","type":"function"}},{"$":{"symbol":"virConnectIsEncrypted","type":"function"}},{"$":{"symbol":"virConnectIsSecure","type":"function"}},{"$":{"symbol":"virConnectOpen","type":"function"}},{"$":{"symbol":"virConnectOpenAuth","type":"function"}},{"$":{"symbol":"virConnectOpenReadOnly","type":"function"}},{"$":{"symbol":"virConnectRef","type":"function"}},{"$":{"symbol":"virConnectRegisterCloseCallback","type":"function"}},{"$":{"symbol":"virConnectSetKeepAlive","type":"function"}},{"$":{"symbol":"virConnectUnregisterCloseCallback","type":"function"}},{"$":{"symbol":"virGetVersion","type":"function"}},{"$":{"symbol":"virInitialize","type":"function"}},{"$":{"symbol":"virNodeAllocPages","type":"function"}},{"$":{"symbol":"virNodeGetCPUMap","type":"function"}},{"$":{"symbol":"virNodeGetCPUStats","type":"function"}},{"$":{"symbol":"virNodeGetCellsFreeMemory","type":"function"}},{"$":{"symbol":"virNodeGetFreeMemory","type":"function"}},{"$":{"symbol":"virNodeGetFreePages","type":"function"}},{"$":{"symbol":"virNodeGetInfo","type":"function"}},{"$":{"symbol":"virNodeGetMemoryParameters","type":"function"}},{"$":{"symbol":"virNodeGetMemoryStats","type":"function"}},{"$":{"symbol":"virNodeGetSecurityModel","type":"function"}},{"$":{"symbol":"virNodeSetMemoryParameters","type":"function"}},{"$":{"symbol":"virNodeSuspendForDuration","type":"function"}}]},{"$":{"name":"libvirt-interface"},"summary":["APIs for management of interfaces"],"description":["Provides APIs for the management of interfaces"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_CONNECT_LIST_INTERFACES_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_INTERFACES_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_INTERFACE_XML_INACTIVE","type":"enum"}},{"$":{"symbol":"virConnectListAllInterfacesFlags","type":"typedef"}},{"$":{"symbol":"virInterface","type":"typedef"}},{"$":{"symbol":"virInterfacePtr","type":"typedef"}},{"$":{"symbol":"virInterfaceXMLFlags","type":"typedef"}},{"$":{"symbol":"virConnectListAllInterfaces","type":"function"}},{"$":{"symbol":"virConnectListDefinedInterfaces","type":"function"}},{"$":{"symbol":"virConnectListInterfaces","type":"function"}},{"$":{"symbol":"virConnectNumOfDefinedInterfaces","type":"function"}},{"$":{"symbol":"virConnectNumOfInterfaces","type":"function"}},{"$":{"symbol":"virInterfaceChangeBegin","type":"function"}},{"$":{"symbol":"virInterfaceChangeCommit","type":"function"}},{"$":{"symbol":"virInterfaceChangeRollback","type":"function"}},{"$":{"symbol":"virInterfaceCreate","type":"function"}},{"$":{"symbol":"virInterfaceDefineXML","type":"function"}},{"$":{"symbol":"virInterfaceDestroy","type":"function"}},{"$":{"symbol":"virInterfaceFree","type":"function"}},{"$":{"symbol":"virInterfaceGetConnect","type":"function"}},{"$":{"symbol":"virInterfaceGetMACString","type":"function"}},{"$":{"symbol":"virInterfaceGetName","type":"function"}},{"$":{"symbol":"virInterfaceGetXMLDesc","type":"function"}},{"$":{"symbol":"virInterfaceIsActive","type":"function"}},{"$":{"symbol":"virInterfaceLookupByMACString","type":"function"}},{"$":{"symbol":"virInterfaceLookupByName","type":"function"}},{"$":{"symbol":"virInterfaceRef","type":"function"}},{"$":{"symbol":"virInterfaceUndefine","type":"function"}}]},{"$":{"name":"libvirt-network"},"summary":["APIs for management of networks"],"description":["Provides APIs for the management of networks"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_NETWORK_EVENT_CALLBACK","type":"macro"}},{"$":{"symbol":"VIR_CONNECT_LIST_NETWORKS_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NETWORKS_AUTOSTART","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NETWORKS_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NETWORKS_PERSISTENT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NETWORKS_TRANSIENT","type":"enum"}},{"$":{"symbol":"VIR_IP_ADDR_TYPE_IPV4","type":"enum"}},{"$":{"symbol":"VIR_IP_ADDR_TYPE_IPV6","type":"enum"}},{"$":{"symbol":"VIR_IP_ADDR_TYPE_LAST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_EVENT_DEFINED","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_EVENT_ID_LAST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_EVENT_ID_LIFECYCLE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_EVENT_LAST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_EVENT_STARTED","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_EVENT_STOPPED","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_EVENT_UNDEFINED","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_BRIDGE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_DNS_HOST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_DNS_SRV","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_DNS_TXT","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_DOMAIN","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_FORWARD","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_FORWARD_INTERFACE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_FORWARD_PF","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_IP","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_IP_DHCP_HOST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_IP_DHCP_RANGE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_LAST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_NONE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_SECTION_PORTGROUP","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_AFFECT_CONFIG","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_AFFECT_CURRENT","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_AFFECT_LIVE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_COMMAND_ADD_LAST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_COMMAND_DELETE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_COMMAND_LAST","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_COMMAND_MODIFY","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_UPDATE_COMMAND_NONE","type":"enum"}},{"$":{"symbol":"VIR_NETWORK_XML_INACTIVE","type":"enum"}},{"$":{"symbol":"virConnectListAllNetworksFlags","type":"typedef"}},{"$":{"symbol":"virIPAddrType","type":"typedef"}},{"$":{"symbol":"virNetwork","type":"typedef"}},{"$":{"symbol":"virNetworkDHCPLease","type":"typedef"}},{"$":{"symbol":"virNetworkDHCPLeasePtr","type":"typedef"}},{"$":{"symbol":"virNetworkEventID","type":"typedef"}},{"$":{"symbol":"virNetworkEventLifecycleType","type":"typedef"}},{"$":{"symbol":"virNetworkPtr","type":"typedef"}},{"$":{"symbol":"virNetworkUpdateCommand","type":"typedef"}},{"$":{"symbol":"virNetworkUpdateFlags","type":"typedef"}},{"$":{"symbol":"virNetworkUpdateSection","type":"typedef"}},{"$":{"symbol":"virNetworkXMLFlags","type":"typedef"}},{"$":{"symbol":"_virNetworkDHCPLease","type":"struct"}},{"$":{"symbol":"virConnectListAllNetworks","type":"function"}},{"$":{"symbol":"virConnectListDefinedNetworks","type":"function"}},{"$":{"symbol":"virConnectListNetworks","type":"function"}},{"$":{"symbol":"virConnectNetworkEventDeregisterAny","type":"function"}},{"$":{"symbol":"virConnectNetworkEventGenericCallback","type":"function"}},{"$":{"symbol":"virConnectNetworkEventLifecycleCallback","type":"function"}},{"$":{"symbol":"virConnectNetworkEventRegisterAny","type":"function"}},{"$":{"symbol":"virConnectNumOfDefinedNetworks","type":"function"}},{"$":{"symbol":"virConnectNumOfNetworks","type":"function"}},{"$":{"symbol":"virNetworkCreate","type":"function"}},{"$":{"symbol":"virNetworkCreateXML","type":"function"}},{"$":{"symbol":"virNetworkDHCPLeaseFree","type":"function"}},{"$":{"symbol":"virNetworkDefineXML","type":"function"}},{"$":{"symbol":"virNetworkDestroy","type":"function"}},{"$":{"symbol":"virNetworkFree","type":"function"}},{"$":{"symbol":"virNetworkGetAutostart","type":"function"}},{"$":{"symbol":"virNetworkGetBridgeName","type":"function"}},{"$":{"symbol":"virNetworkGetConnect","type":"function"}},{"$":{"symbol":"virNetworkGetDHCPLeases","type":"function"}},{"$":{"symbol":"virNetworkGetName","type":"function"}},{"$":{"symbol":"virNetworkGetUUID","type":"function"}},{"$":{"symbol":"virNetworkGetUUIDString","type":"function"}},{"$":{"symbol":"virNetworkGetXMLDesc","type":"function"}},{"$":{"symbol":"virNetworkIsActive","type":"function"}},{"$":{"symbol":"virNetworkIsPersistent","type":"function"}},{"$":{"symbol":"virNetworkLookupByName","type":"function"}},{"$":{"symbol":"virNetworkLookupByUUID","type":"function"}},{"$":{"symbol":"virNetworkLookupByUUIDString","type":"function"}},{"$":{"symbol":"virNetworkRef","type":"function"}},{"$":{"symbol":"virNetworkSetAutostart","type":"function"}},{"$":{"symbol":"virNetworkUndefine","type":"function"}},{"$":{"symbol":"virNetworkUpdate","type":"function"}}]},{"$":{"name":"libvirt-nodedev"},"summary":["APIs for management of nodedevs"],"description":["Provides APIs for the management of nodedevs"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_NODE_DEVICE_EVENT_CALLBACK","type":"macro"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS","type":"enum"}},{"$":{"symbol":"VIR_NODE_DEVICE_EVENT_CREATED","type":"enum"}},{"$":{"symbol":"VIR_NODE_DEVICE_EVENT_DELETED","type":"enum"}},{"$":{"symbol":"VIR_NODE_DEVICE_EVENT_ID_LAST","type":"enum"}},{"$":{"symbol":"VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE","type":"enum"}},{"$":{"symbol":"VIR_NODE_DEVICE_EVENT_ID_UPDATE","type":"enum"}},{"$":{"symbol":"VIR_NODE_DEVICE_EVENT_LAST","type":"enum"}},{"$":{"symbol":"virConnectListAllNodeDeviceFlags","type":"typedef"}},{"$":{"symbol":"virNodeDevice","type":"typedef"}},{"$":{"symbol":"virNodeDeviceEventID","type":"typedef"}},{"$":{"symbol":"virNodeDeviceEventLifecycleType","type":"typedef"}},{"$":{"symbol":"virNodeDevicePtr","type":"typedef"}},{"$":{"symbol":"virConnectListAllNodeDevices","type":"function"}},{"$":{"symbol":"virConnectNodeDeviceEventDeregisterAny","type":"function"}},{"$":{"symbol":"virConnectNodeDeviceEventGenericCallback","type":"function"}},{"$":{"symbol":"virConnectNodeDeviceEventLifecycleCallback","type":"function"}},{"$":{"symbol":"virConnectNodeDeviceEventRegisterAny","type":"function"}},{"$":{"symbol":"virNodeDeviceCreateXML","type":"function"}},{"$":{"symbol":"virNodeDeviceDestroy","type":"function"}},{"$":{"symbol":"virNodeDeviceDetachFlags","type":"function"}},{"$":{"symbol":"virNodeDeviceDettach","type":"function"}},{"$":{"symbol":"virNodeDeviceFree","type":"function"}},{"$":{"symbol":"virNodeDeviceGetName","type":"function"}},{"$":{"symbol":"virNodeDeviceGetParent","type":"function"}},{"$":{"symbol":"virNodeDeviceGetXMLDesc","type":"function"}},{"$":{"symbol":"virNodeDeviceListCaps","type":"function"}},{"$":{"symbol":"virNodeDeviceLookupByName","type":"function"}},{"$":{"symbol":"virNodeDeviceLookupSCSIHostByWWN","type":"function"}},{"$":{"symbol":"virNodeDeviceNumOfCaps","type":"function"}},{"$":{"symbol":"virNodeDeviceReAttach","type":"function"}},{"$":{"symbol":"virNodeDeviceRef","type":"function"}},{"$":{"symbol":"virNodeDeviceReset","type":"function"}},{"$":{"symbol":"virNodeListDevices","type":"function"}},{"$":{"symbol":"virNodeNumOfDevices","type":"function"}}]},{"$":{"name":"libvirt-nwfilter"},"summary":["APIs for management of nwfilters"],"description":["Provides APIs for the management of nwfilters"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"virNWFilter","type":"typedef"}},{"$":{"symbol":"virNWFilterPtr","type":"typedef"}},{"$":{"symbol":"virConnectListAllNWFilters","type":"function"}},{"$":{"symbol":"virConnectListNWFilters","type":"function"}},{"$":{"symbol":"virConnectNumOfNWFilters","type":"function"}},{"$":{"symbol":"virNWFilterDefineXML","type":"function"}},{"$":{"symbol":"virNWFilterFree","type":"function"}},{"$":{"symbol":"virNWFilterGetName","type":"function"}},{"$":{"symbol":"virNWFilterGetUUID","type":"function"}},{"$":{"symbol":"virNWFilterGetUUIDString","type":"function"}},{"$":{"symbol":"virNWFilterGetXMLDesc","type":"function"}},{"$":{"symbol":"virNWFilterLookupByName","type":"function"}},{"$":{"symbol":"virNWFilterLookupByUUID","type":"function"}},{"$":{"symbol":"virNWFilterLookupByUUIDString","type":"function"}},{"$":{"symbol":"virNWFilterRef","type":"function"}},{"$":{"symbol":"virNWFilterUndefine","type":"function"}}]},{"$":{"name":"libvirt-secret"},"summary":["APIs for management of secrets"],"description":["Provides APIs for the management of secrets"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014, 2016 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_SECRET_EVENT_CALLBACK","type":"macro"}},{"$":{"symbol":"VIR_CONNECT_LIST_SECRETS_EPHEMERAL","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_SECRETS_NO_PRIVATE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_SECRETS_PRIVATE","type":"enum"}},{"$":{"symbol":"VIR_SECRET_EVENT_DEFINED","type":"enum"}},{"$":{"symbol":"VIR_SECRET_EVENT_ID_LAST","type":"enum"}},{"$":{"symbol":"VIR_SECRET_EVENT_ID_LIFECYCLE","type":"enum"}},{"$":{"symbol":"VIR_SECRET_EVENT_ID_VALUE_CHANGED","type":"enum"}},{"$":{"symbol":"VIR_SECRET_EVENT_LAST","type":"enum"}},{"$":{"symbol":"VIR_SECRET_EVENT_UNDEFINED","type":"enum"}},{"$":{"symbol":"VIR_SECRET_USAGE_TYPE_CEPH","type":"enum"}},{"$":{"symbol":"VIR_SECRET_USAGE_TYPE_ISCSI","type":"enum"}},{"$":{"symbol":"VIR_SECRET_USAGE_TYPE_LAST","type":"enum"}},{"$":{"symbol":"VIR_SECRET_USAGE_TYPE_NONE","type":"enum"}},{"$":{"symbol":"VIR_SECRET_USAGE_TYPE_TLS","type":"enum"}},{"$":{"symbol":"VIR_SECRET_USAGE_TYPE_VOLUME","type":"enum"}},{"$":{"symbol":"virConnectListAllSecretsFlags","type":"typedef"}},{"$":{"symbol":"virSecret","type":"typedef"}},{"$":{"symbol":"virSecretEventID","type":"typedef"}},{"$":{"symbol":"virSecretEventLifecycleType","type":"typedef"}},{"$":{"symbol":"virSecretPtr","type":"typedef"}},{"$":{"symbol":"virSecretUsageType","type":"typedef"}},{"$":{"symbol":"virConnectListAllSecrets","type":"function"}},{"$":{"symbol":"virConnectListSecrets","type":"function"}},{"$":{"symbol":"virConnectNumOfSecrets","type":"function"}},{"$":{"symbol":"virConnectSecretEventDeregisterAny","type":"function"}},{"$":{"symbol":"virConnectSecretEventGenericCallback","type":"function"}},{"$":{"symbol":"virConnectSecretEventLifecycleCallback","type":"function"}},{"$":{"symbol":"virConnectSecretEventRegisterAny","type":"function"}},{"$":{"symbol":"virSecretDefineXML","type":"function"}},{"$":{"symbol":"virSecretFree","type":"function"}},{"$":{"symbol":"virSecretGetConnect","type":"function"}},{"$":{"symbol":"virSecretGetUUID","type":"function"}},{"$":{"symbol":"virSecretGetUUIDString","type":"function"}},{"$":{"symbol":"virSecretGetUsageID","type":"function"}},{"$":{"symbol":"virSecretGetUsageType","type":"function"}},{"$":{"symbol":"virSecretGetValue","type":"function"}},{"$":{"symbol":"virSecretGetXMLDesc","type":"function"}},{"$":{"symbol":"virSecretLookupByUUID","type":"function"}},{"$":{"symbol":"virSecretLookupByUUIDString","type":"function"}},{"$":{"symbol":"virSecretLookupByUsage","type":"function"}},{"$":{"symbol":"virSecretRef","type":"function"}},{"$":{"symbol":"virSecretSetValue","type":"function"}},{"$":{"symbol":"virSecretUndefine","type":"function"}}]},{"$":{"name":"libvirt-storage"},"summary":["APIs for management of storage pools and volumes"],"description":["Provides APIs for the management of storage pools and volumes"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2016 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_CALLBACK","type":"macro"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_DIR","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_DISK","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_FS","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_GLUSTER","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_MPATH","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_NETFS","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_RBD","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_SCSI","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_VSTORAGE","type":"enum"}},{"$":{"symbol":"VIR_CONNECT_LIST_STORAGE_POOLS_ZFS","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_BUILDING","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_BUILD_NEW","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_BUILD_NO_OVERWRITE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_BUILD_OVERWRITE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_BUILD_REPAIR","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_BUILD_RESIZE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_CREATE_NORMAL","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_CREATE_WITH_BUILD","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_CREATE_WITH_BUILD_NO_OVERWRITE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_CREATE_WITH_BUILD_OVERWRITE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_DEGRADED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_DELETE_NORMAL","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_DELETE_ZEROED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_CREATED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_DEFINED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_DELETED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_ID_LAST","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_ID_LIFECYCLE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_ID_REFRESH","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_LAST","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_STARTED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_STOPPED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_EVENT_UNDEFINED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_INACCESSIBLE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_INACTIVE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_RUNNING","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_POOL_STATE_LAST","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_BLOCK","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_CREATE_REFLINK","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_DELETE_NORMAL","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_DELETE_WITH_SNAPSHOTS","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_DELETE_ZEROED","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_DIR","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_FILE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_GET_PHYSICAL","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_LAST","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_NETDIR","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_NETWORK","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_PLOOP","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_RESIZE_ALLOCATE","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_RESIZE_DELTA","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_RESIZE_SHRINK","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_USE_ALLOCATION","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_BSI","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_DOD","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_GUTMANN","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_LAST","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_NNSA","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_RANDOM","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_TRIM","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_VOL_WIPE_ALG_ZERO","type":"enum"}},{"$":{"symbol":"VIR_STORAGE_XML_INACTIVE","type":"enum"}},{"$":{"symbol":"virConnectListAllStoragePoolsFlags","type":"typedef"}},{"$":{"symbol":"virStoragePool","type":"typedef"}},{"$":{"symbol":"virStoragePoolBuildFlags","type":"typedef"}},{"$":{"symbol":"virStoragePoolCreateFlags","type":"typedef"}},{"$":{"symbol":"virStoragePoolDeleteFlags","type":"typedef"}},{"$":{"symbol":"virStoragePoolEventID","type":"typedef"}},{"$":{"symbol":"virStoragePoolEventLifecycleType","type":"typedef"}},{"$":{"symbol":"virStoragePoolInfo","type":"typedef"}},{"$":{"symbol":"virStoragePoolInfoPtr","type":"typedef"}},{"$":{"symbol":"virStoragePoolPtr","type":"typedef"}},{"$":{"symbol":"virStoragePoolState","type":"typedef"}},{"$":{"symbol":"virStorageVol","type":"typedef"}},{"$":{"symbol":"virStorageVolCreateFlags","type":"typedef"}},{"$":{"symbol":"virStorageVolDeleteFlags","type":"typedef"}},{"$":{"symbol":"virStorageVolDownloadFlags","type":"typedef"}},{"$":{"symbol":"virStorageVolInfo","type":"typedef"}},{"$":{"symbol":"virStorageVolInfoFlags","type":"typedef"}},{"$":{"symbol":"virStorageVolInfoPtr","type":"typedef"}},{"$":{"symbol":"virStorageVolPtr","type":"typedef"}},{"$":{"symbol":"virStorageVolResizeFlags","type":"typedef"}},{"$":{"symbol":"virStorageVolType","type":"typedef"}},{"$":{"symbol":"virStorageVolUploadFlags","type":"typedef"}},{"$":{"symbol":"virStorageVolWipeAlgorithm","type":"typedef"}},{"$":{"symbol":"virStorageXMLFlags","type":"typedef"}},{"$":{"symbol":"_virStoragePoolInfo","type":"struct"}},{"$":{"symbol":"_virStorageVolInfo","type":"struct"}},{"$":{"symbol":"virConnectFindStoragePoolSources","type":"function"}},{"$":{"symbol":"virConnectListAllStoragePools","type":"function"}},{"$":{"symbol":"virConnectListDefinedStoragePools","type":"function"}},{"$":{"symbol":"virConnectListStoragePools","type":"function"}},{"$":{"symbol":"virConnectNumOfDefinedStoragePools","type":"function"}},{"$":{"symbol":"virConnectNumOfStoragePools","type":"function"}},{"$":{"symbol":"virConnectStoragePoolEventDeregisterAny","type":"function"}},{"$":{"symbol":"virConnectStoragePoolEventGenericCallback","type":"function"}},{"$":{"symbol":"virConnectStoragePoolEventLifecycleCallback","type":"function"}},{"$":{"symbol":"virConnectStoragePoolEventRegisterAny","type":"function"}},{"$":{"symbol":"virStoragePoolBuild","type":"function"}},{"$":{"symbol":"virStoragePoolCreate","type":"function"}},{"$":{"symbol":"virStoragePoolCreateXML","type":"function"}},{"$":{"symbol":"virStoragePoolDefineXML","type":"function"}},{"$":{"symbol":"virStoragePoolDelete","type":"function"}},{"$":{"symbol":"virStoragePoolDestroy","type":"function"}},{"$":{"symbol":"virStoragePoolFree","type":"function"}},{"$":{"symbol":"virStoragePoolGetAutostart","type":"function"}},{"$":{"symbol":"virStoragePoolGetConnect","type":"function"}},{"$":{"symbol":"virStoragePoolGetInfo","type":"function"}},{"$":{"symbol":"virStoragePoolGetName","type":"function"}},{"$":{"symbol":"virStoragePoolGetUUID","type":"function"}},{"$":{"symbol":"virStoragePoolGetUUIDString","type":"function"}},{"$":{"symbol":"virStoragePoolGetXMLDesc","type":"function"}},{"$":{"symbol":"virStoragePoolIsActive","type":"function"}},{"$":{"symbol":"virStoragePoolIsPersistent","type":"function"}},{"$":{"symbol":"virStoragePoolListAllVolumes","type":"function"}},{"$":{"symbol":"virStoragePoolListVolumes","type":"function"}},{"$":{"symbol":"virStoragePoolLookupByName","type":"function"}},{"$":{"symbol":"virStoragePoolLookupByTargetPath","type":"function"}},{"$":{"symbol":"virStoragePoolLookupByUUID","type":"function"}},{"$":{"symbol":"virStoragePoolLookupByUUIDString","type":"function"}},{"$":{"symbol":"virStoragePoolLookupByVolume","type":"function"}},{"$":{"symbol":"virStoragePoolNumOfVolumes","type":"function"}},{"$":{"symbol":"virStoragePoolRef","type":"function"}},{"$":{"symbol":"virStoragePoolRefresh","type":"function"}},{"$":{"symbol":"virStoragePoolSetAutostart","type":"function"}},{"$":{"symbol":"virStoragePoolUndefine","type":"function"}},{"$":{"symbol":"virStorageVolCreateXML","type":"function"}},{"$":{"symbol":"virStorageVolCreateXMLFrom","type":"function"}},{"$":{"symbol":"virStorageVolDelete","type":"function"}},{"$":{"symbol":"virStorageVolDownload","type":"function"}},{"$":{"symbol":"virStorageVolFree","type":"function"}},{"$":{"symbol":"virStorageVolGetConnect","type":"function"}},{"$":{"symbol":"virStorageVolGetInfo","type":"function"}},{"$":{"symbol":"virStorageVolGetInfoFlags","type":"function"}},{"$":{"symbol":"virStorageVolGetKey","type":"function"}},{"$":{"symbol":"virStorageVolGetName","type":"function"}},{"$":{"symbol":"virStorageVolGetPath","type":"function"}},{"$":{"symbol":"virStorageVolGetXMLDesc","type":"function"}},{"$":{"symbol":"virStorageVolLookupByKey","type":"function"}},{"$":{"symbol":"virStorageVolLookupByName","type":"function"}},{"$":{"symbol":"virStorageVolLookupByPath","type":"function"}},{"$":{"symbol":"virStorageVolRef","type":"function"}},{"$":{"symbol":"virStorageVolResize","type":"function"}},{"$":{"symbol":"virStorageVolUpload","type":"function"}},{"$":{"symbol":"virStorageVolWipe","type":"function"}},{"$":{"symbol":"virStorageVolWipePattern","type":"function"}}]},{"$":{"name":"libvirt-stream"},"summary":["APIs for management of streams"],"description":["Provides APIs for the management of streams"],"author":["Daniel Veillard <veillard@redhat.com>  Copyright (C) 2006-2014 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"exports":[{"$":{"symbol":"VIR_STREAM_EVENT_ERROR","type":"enum"}},{"$":{"symbol":"VIR_STREAM_EVENT_HANGUP","type":"enum"}},{"$":{"symbol":"VIR_STREAM_EVENT_READABLE","type":"enum"}},{"$":{"symbol":"VIR_STREAM_EVENT_WRITABLE","type":"enum"}},{"$":{"symbol":"VIR_STREAM_NONBLOCK","type":"enum"}},{"$":{"symbol":"VIR_STREAM_RECV_STOP_AT_HOLE","type":"enum"}},{"$":{"symbol":"virStreamEventType","type":"typedef"}},{"$":{"symbol":"virStreamFlags","type":"typedef"}},{"$":{"symbol":"virStreamRecvFlagsValues","type":"typedef"}},{"$":{"symbol":"virStreamAbort","type":"function"}},{"$":{"symbol":"virStreamEventAddCallback","type":"function"}},{"$":{"symbol":"virStreamEventCallback","type":"function"}},{"$":{"symbol":"virStreamEventRemoveCallback","type":"function"}},{"$":{"symbol":"virStreamEventUpdateCallback","type":"function"}},{"$":{"symbol":"virStreamFinish","type":"function"}},{"$":{"symbol":"virStreamFree","type":"function"}},{"$":{"symbol":"virStreamNew","type":"function"}},{"$":{"symbol":"virStreamRecv","type":"function"}},{"$":{"symbol":"virStreamRecvAll","type":"function"}},{"$":{"symbol":"virStreamRecvFlags","type":"function"}},{"$":{"symbol":"virStreamRecvHole","type":"function"}},{"$":{"symbol":"virStreamRef","type":"function"}},{"$":{"symbol":"virStreamSend","type":"function"}},{"$":{"symbol":"virStreamSendAll","type":"function"}},{"$":{"symbol":"virStreamSendHole","type":"function"}},{"$":{"symbol":"virStreamSinkFunc","type":"function"}},{"$":{"symbol":"virStreamSinkHoleFunc","type":"function"}},{"$":{"symbol":"virStreamSourceFunc","type":"function"}},{"$":{"symbol":"virStreamSourceHoleFunc","type":"function"}},{"$":{"symbol":"virStreamSourceSkipFunc","type":"function"}},{"$":{"symbol":"virStreamSparseRecvAll","type":"function"}},{"$":{"symbol":"virStreamSparseSendAll","type":"function"}}]},{"$":{"name":"virterror"},"summary":["error handling interfaces for the libvirt library"],"description":["Provides the interfaces of the libvirt library to handle errors raised while using the library.  Copyright (C) 2006-2016 Red Hat, Inc.  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.  This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.  You should have received a copy of the GNU Lesser General Public License along with this library.  If not, see <http://www.gnu.org/licenses/>. "],"author":["Daniel Veillard <veillard@redhat.com> "],"exports":[{"$":{"symbol":"VIR_ERR_ACCESS_DENIED","type":"enum"}},{"$":{"symbol":"VIR_ERR_AGENT_UNRESPONSIVE","type":"enum"}},{"$":{"symbol":"VIR_ERR_AGENT_UNSYNCED","type":"enum"}},{"$":{"symbol":"VIR_ERR_ARGUMENT_UNSUPPORTED","type":"enum"}},{"$":{"symbol":"VIR_ERR_AUTH_CANCELLED","type":"enum"}},{"$":{"symbol":"VIR_ERR_AUTH_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_AUTH_UNAVAILABLE","type":"enum"}},{"$":{"symbol":"VIR_ERR_BLOCK_COPY_ACTIVE","type":"enum"}},{"$":{"symbol":"VIR_ERR_BUILD_FIREWALL","type":"enum"}},{"$":{"symbol":"VIR_ERR_CALL_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_CONFIG_UNSUPPORTED","type":"enum"}},{"$":{"symbol":"VIR_ERR_CONF_SYNTAX","type":"enum"}},{"$":{"symbol":"VIR_ERR_CPU_INCOMPATIBLE","type":"enum"}},{"$":{"symbol":"VIR_ERR_DBUS_SERVICE","type":"enum"}},{"$":{"symbol":"VIR_ERR_DEVICE_MISSING","type":"enum"}},{"$":{"symbol":"VIR_ERR_DOMAIN_LAST","type":"enum"}},{"$":{"symbol":"VIR_ERR_DOM_EXIST","type":"enum"}},{"$":{"symbol":"VIR_ERR_DRIVER_FULL","type":"enum"}},{"$":{"symbol":"VIR_ERR_ERROR","type":"enum"}},{"$":{"symbol":"VIR_ERR_GET_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_GNUTLS_ERROR","type":"enum"}},{"$":{"symbol":"VIR_ERR_HOOK_SCRIPT_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_HTTP_ERROR","type":"enum"}},{"$":{"symbol":"VIR_ERR_INTERNAL_ERROR","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_ARG","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_CONN","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_DOMAIN","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_DOMAIN_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_INTERFACE","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_MAC","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_NETWORK","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_NODE_DEVICE","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_NWFILTER","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_SECRET","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_STORAGE_POOL","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_STORAGE_VOL","type":"enum"}},{"$":{"symbol":"VIR_ERR_INVALID_STREAM","type":"enum"}},{"$":{"symbol":"VIR_ERR_LIBSSH","type":"enum"}},{"$":{"symbol":"VIR_ERR_MIGRATE_FINISH_OK","type":"enum"}},{"$":{"symbol":"VIR_ERR_MIGRATE_PERSIST_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_MIGRATE_UNSAFE","type":"enum"}},{"$":{"symbol":"VIR_ERR_MULTIPLE_INTERFACES","type":"enum"}},{"$":{"symbol":"VIR_ERR_NETWORK_EXIST","type":"enum"}},{"$":{"symbol":"VIR_ERR_NONE","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_CLIENT","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_CONNECT","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_DEVICE","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_DOMAIN","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_DOMAIN_METADATA","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_DOMAIN_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_INTERFACE","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_KERNEL","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_MEMORY","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_NAME","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_NETWORK","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_NODE_DEVICE","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_NWFILTER","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_OS","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_ROOT","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_SECRET","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_SECURITY_MODEL","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_SERVER","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_SOURCE","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_STORAGE_POOL","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_STORAGE_VOL","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_SUPPORT","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_TARGET","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_XEN","type":"enum"}},{"$":{"symbol":"VIR_ERR_NO_XENSTORE","type":"enum"}},{"$":{"symbol":"VIR_ERR_OK","type":"enum"}},{"$":{"symbol":"VIR_ERR_OPEN_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_OPERATION_ABORTED","type":"enum"}},{"$":{"symbol":"VIR_ERR_OPERATION_DENIED","type":"enum"}},{"$":{"symbol":"VIR_ERR_OPERATION_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_OPERATION_INVALID","type":"enum"}},{"$":{"symbol":"VIR_ERR_OPERATION_TIMEOUT","type":"enum"}},{"$":{"symbol":"VIR_ERR_OPERATION_UNSUPPORTED","type":"enum"}},{"$":{"symbol":"VIR_ERR_OS_TYPE","type":"enum"}},{"$":{"symbol":"VIR_ERR_OVERFLOW","type":"enum"}},{"$":{"symbol":"VIR_ERR_PARSE_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_POST_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_READ_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_RESOURCE_BUSY","type":"enum"}},{"$":{"symbol":"VIR_ERR_RPC","type":"enum"}},{"$":{"symbol":"VIR_ERR_SEXPR_SERIAL","type":"enum"}},{"$":{"symbol":"VIR_ERR_SNAPSHOT_REVERT_RISKY","type":"enum"}},{"$":{"symbol":"VIR_ERR_SSH","type":"enum"}},{"$":{"symbol":"VIR_ERR_STORAGE_POOL_BUILT","type":"enum"}},{"$":{"symbol":"VIR_ERR_STORAGE_PROBE_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_STORAGE_VOL_EXIST","type":"enum"}},{"$":{"symbol":"VIR_ERR_SYSTEM_ERROR","type":"enum"}},{"$":{"symbol":"VIR_ERR_UNKNOWN_HOST","type":"enum"}},{"$":{"symbol":"VIR_ERR_WARNING","type":"enum"}},{"$":{"symbol":"VIR_ERR_WRITE_FAILED","type":"enum"}},{"$":{"symbol":"VIR_ERR_XEN_CALL","type":"enum"}},{"$":{"symbol":"VIR_ERR_XML_DETAIL","type":"enum"}},{"$":{"symbol":"VIR_ERR_XML_ERROR","type":"enum"}},{"$":{"symbol":"VIR_ERR_XML_INVALID_SCHEMA","type":"enum"}},{"$":{"symbol":"VIR_FROM_ACCESS","type":"enum"}},{"$":{"symbol":"VIR_FROM_ADMIN","type":"enum"}},{"$":{"symbol":"VIR_FROM_AUDIT","type":"enum"}},{"$":{"symbol":"VIR_FROM_AUTH","type":"enum"}},{"$":{"symbol":"VIR_FROM_BHYVE","type":"enum"}},{"$":{"symbol":"VIR_FROM_CAPABILITIES","type":"enum"}},{"$":{"symbol":"VIR_FROM_CGROUP","type":"enum"}},{"$":{"symbol":"VIR_FROM_CONF","type":"enum"}},{"$":{"symbol":"VIR_FROM_CPU","type":"enum"}},{"$":{"symbol":"VIR_FROM_CRYPTO","type":"enum"}},{"$":{"symbol":"VIR_FROM_DBUS","type":"enum"}},{"$":{"symbol":"VIR_FROM_DEVICE","type":"enum"}},{"$":{"symbol":"VIR_FROM_DOM","type":"enum"}},{"$":{"symbol":"VIR_FROM_DOMAIN","type":"enum"}},{"$":{"symbol":"VIR_FROM_DOMAIN_SNAPSHOT","type":"enum"}},{"$":{"symbol":"VIR_FROM_ESX","type":"enum"}},{"$":{"symbol":"VIR_FROM_EVENT","type":"enum"}},{"$":{"symbol":"VIR_FROM_FIREWALL","type":"enum"}},{"$":{"symbol":"VIR_FROM_HOOK","type":"enum"}},{"$":{"symbol":"VIR_FROM_HYPERV","type":"enum"}},{"$":{"symbol":"VIR_FROM_IDENTITY","type":"enum"}},{"$":{"symbol":"VIR_FROM_INITCTL","type":"enum"}},{"$":{"symbol":"VIR_FROM_INTERFACE","type":"enum"}},{"$":{"symbol":"VIR_FROM_LIBSSH","type":"enum"}},{"$":{"symbol":"VIR_FROM_LIBXL","type":"enum"}},{"$":{"symbol":"VIR_FROM_LOCKING","type":"enum"}},{"$":{"symbol":"VIR_FROM_LOCKSPACE","type":"enum"}},{"$":{"symbol":"VIR_FROM_LOGGING","type":"enum"}},{"$":{"symbol":"VIR_FROM_LXC","type":"enum"}},{"$":{"symbol":"VIR_FROM_NET","type":"enum"}},{"$":{"symbol":"VIR_FROM_NETWORK","type":"enum"}},{"$":{"symbol":"VIR_FROM_NODEDEV","type":"enum"}},{"$":{"symbol":"VIR_FROM_NONE","type":"enum"}},{"$":{"symbol":"VIR_FROM_NWFILTER","type":"enum"}},{"$":{"symbol":"VIR_FROM_ONE","type":"enum"}},{"$":{"symbol":"VIR_FROM_OPENVZ","type":"enum"}},{"$":{"symbol":"VIR_FROM_PARALLELS","type":"enum"}},{"$":{"symbol":"VIR_FROM_PERF","type":"enum"}},{"$":{"symbol":"VIR_FROM_PHYP","type":"enum"}},{"$":{"symbol":"VIR_FROM_POLKIT","type":"enum"}},{"$":{"symbol":"VIR_FROM_PROXY","type":"enum"}},{"$":{"symbol":"VIR_FROM_QEMU","type":"enum"}},{"$":{"symbol":"VIR_FROM_REMOTE","type":"enum"}},{"$":{"symbol":"VIR_FROM_RESCTRL","type":"enum"}},{"$":{"symbol":"VIR_FROM_RPC","type":"enum"}},{"$":{"symbol":"VIR_FROM_SECRET","type":"enum"}},{"$":{"symbol":"VIR_FROM_SECURITY","type":"enum"}},{"$":{"symbol":"VIR_FROM_SEXPR","type":"enum"}},{"$":{"symbol":"VIR_FROM_SSH","type":"enum"}},{"$":{"symbol":"VIR_FROM_STATS_LINUX","type":"enum"}},{"$":{"symbol":"VIR_FROM_STORAGE","type":"enum"}},{"$":{"symbol":"VIR_FROM_STREAMS","type":"enum"}},{"$":{"symbol":"VIR_FROM_SYSINFO","type":"enum"}},{"$":{"symbol":"VIR_FROM_SYSTEMD","type":"enum"}},{"$":{"symbol":"VIR_FROM_TEST","type":"enum"}},{"$":{"symbol":"VIR_FROM_THREAD","type":"enum"}},{"$":{"symbol":"VIR_FROM_UML","type":"enum"}},{"$":{"symbol":"VIR_FROM_URI","type":"enum"}},{"$":{"symbol":"VIR_FROM_VBOX","type":"enum"}},{"$":{"symbol":"VIR_FROM_VMWARE","type":"enum"}},{"$":{"symbol":"VIR_FROM_XEN","type":"enum"}},{"$":{"symbol":"VIR_FROM_XENAPI","type":"enum"}},{"$":{"symbol":"VIR_FROM_XEND","type":"enum"}},{"$":{"symbol":"VIR_FROM_XENSTORE","type":"enum"}},{"$":{"symbol":"VIR_FROM_XENXL","type":"enum"}},{"$":{"symbol":"VIR_FROM_XENXM","type":"enum"}},{"$":{"symbol":"VIR_FROM_XEN_INOTIFY","type":"enum"}},{"$":{"symbol":"VIR_FROM_XML","type":"enum"}},{"$":{"symbol":"VIR_WAR_NO_INTERFACE","type":"enum"}},{"$":{"symbol":"VIR_WAR_NO_NETWORK","type":"enum"}},{"$":{"symbol":"VIR_WAR_NO_NODE","type":"enum"}},{"$":{"symbol":"VIR_WAR_NO_NWFILTER","type":"enum"}},{"$":{"symbol":"VIR_WAR_NO_SECRET","type":"enum"}},{"$":{"symbol":"VIR_WAR_NO_STORAGE","type":"enum"}},{"$":{"symbol":"virError","type":"typedef"}},{"$":{"symbol":"virErrorDomain","type":"typedef"}},{"$":{"symbol":"virErrorLevel","type":"typedef"}},{"$":{"symbol":"virErrorNumber","type":"typedef"}},{"$":{"symbol":"virErrorPtr","type":"typedef"}},{"$":{"symbol":"_virError","type":"struct"}},{"$":{"symbol":"virConnCopyLastError","type":"function"}},{"$":{"symbol":"virConnGetLastError","type":"function"}},{"$":{"symbol":"virConnResetLastError","type":"function"}},{"$":{"symbol":"virConnSetErrorFunc","type":"function"}},{"$":{"symbol":"virCopyLastError","type":"function"}},{"$":{"symbol":"virDefaultErrorFunc","type":"function"}},{"$":{"symbol":"virErrorFunc","type":"function"}},{"$":{"symbol":"virFreeError","type":"function"}},{"$":{"symbol":"virGetLastError","type":"function"}},{"$":{"symbol":"virGetLastErrorMessage","type":"function"}},{"$":{"symbol":"virResetError","type":"function"}},{"$":{"symbol":"virResetLastError","type":"function"}},{"$":{"symbol":"virSaveLastError","type":"function"}},{"$":{"symbol":"virSetErrorFunc","type":"function"}}]}]}],"symbols":[{"macro":[{"$":{"name":"LIBVIR_CHECK_VERSION","file":"libvirt-common"},"info":["Macro for developers to easily check what version of the library their code is compiling against. e.g. #if LIBVIR_CHECK_VERSION(1,1,3) // some code that only works in 1.1.3 and newer #endif"],"arg":[{"$":{"name":"major","info":"major component of the version number"}},{"$":{"name":"minor","info":"minor component of the version number"}},{"$":{"name":"micro","info":"micro component of the version number"}}]},{"$":{"name":"LIBVIR_VERSION_NUMBER","file":"libvirt-common"},"info":["Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro"]},{"$":{"name":"VIR_COPY_CPUMAP","file":"libvirt-domain"},"info":["This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_COPY_CPUMAP macro extracts the cpumap of the specified vcpu from cpumaps array and copies it into cpumap to be used later by virDomainPinVcpu() API."],"arg":[{"$":{"name":"cpumaps","info":"pointer to an array of cpumap (in 8-bit bytes) (IN)"}},{"$":{"name":"maplen","info":"the length (in bytes) of one cpumap"}},{"$":{"name":"vcpu","info":"the virtual CPU number"}},{"$":{"name":"cpumap","info":"pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))"}}]},{"$":{"name":"VIR_CPU_MAPLEN","file":"libvirt-domain"},"info":["This macro is to be used in conjunction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual & all physical CPUs of a domain."],"arg":[{"$":{"name":"cpu","info":"number of physical CPUs"}}]},{"$":{"name":"VIR_CPU_USABLE","file":"libvirt-domain"},"info":["This macro is to be used in conjunction with virDomainGetVcpus() API. VIR_CPU_USABLE macro returns a non-zero value (true) if the cpu is usable by the vcpu, and 0 otherwise."],"arg":[{"$":{"name":"cpumaps","info":"pointer to an array of cpumap (in 8-bit bytes) (IN)"}},{"$":{"name":"maplen","info":"the length (in bytes) of one cpumap"}},{"$":{"name":"vcpu","info":"the virtual CPU number"}},{"$":{"name":"cpu","info":"the physical CPU number"}}]},{"$":{"name":"VIR_CPU_USED","file":"libvirt-domain"},"info":["This macro can be used in conjunction with virNodeGetCPUMap() API. It returns non-zero if the bit of the related CPU is set."],"arg":[{"$":{"name":"cpumap","info":"pointer to a bit map of real CPUs (in 8-bit bytes) (IN)"}},{"$":{"name":"cpu","info":"the physical CPU number"}}]},{"$":{"name":"VIR_DOMAIN_BANDWIDTH_IN_AVERAGE","file":"libvirt-domain","string":"inbound.average"},"info":["Macro represents the inbound average of NIC bandwidth, as a uint."]},{"$":{"name":"VIR_DOMAIN_BANDWIDTH_IN_BURST","file":"libvirt-domain","string":"inbound.burst"},"info":["Macro represents the inbound burst of NIC bandwidth, as a uint."]},{"$":{"name":"VIR_DOMAIN_BANDWIDTH_IN_FLOOR","file":"libvirt-domain","string":"inbound.floor"},"info":["Macro represents the inbound floor of NIC bandwidth, as a uint."]},{"$":{"name":"VIR_DOMAIN_BANDWIDTH_IN_PEAK","file":"libvirt-domain","string":"inbound.peak"},"info":["Macro represents the inbound peak of NIC bandwidth, as a uint."]},{"$":{"name":"VIR_DOMAIN_BANDWIDTH_OUT_AVERAGE","file":"libvirt-domain","string":"outbound.average"},"info":["Macro represents the outbound average of NIC bandwidth, as a uint."]},{"$":{"name":"VIR_DOMAIN_BANDWIDTH_OUT_BURST","file":"libvirt-domain","string":"outbound.burst"},"info":["Macro represents the outbound burst of NIC bandwidth, as a uint."]},{"$":{"name":"VIR_DOMAIN_BANDWIDTH_OUT_PEAK","file":"libvirt-domain","string":"outbound.peak"},"info":["Macro represents the outbound peak of NIC bandwidth, as a uint."]},{"$":{"name":"VIR_DOMAIN_BLKIO_DEVICE_READ_BPS","file":"libvirt-domain","string":"device_read_bytes_sec"},"info":["Macro for the blkio tunable throttle.read_iops_device: it represents the bytes of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, read_bps elements, separated by ','."]},{"$":{"name":"VIR_DOMAIN_BLKIO_DEVICE_READ_IOPS","file":"libvirt-domain","string":"device_read_iops_sec"},"info":["Macro for the blkio tunable throttle.read_iops_device: it represents the number of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, read_iops elements, separated by ','."]},{"$":{"name":"VIR_DOMAIN_BLKIO_DEVICE_WEIGHT","file":"libvirt-domain","string":"device_weight"},"info":["Macro for the blkio tunable weight_device: it represents the per-device weight, as a string.  The string is parsed as a series of /path/to/device,weight elements, separated by ','."]},{"$":{"name":"VIR_DOMAIN_BLKIO_DEVICE_WRITE_BPS","file":"libvirt-domain","string":"device_write_bytes_sec"},"info":["Macro for the blkio tunable throttle.read_iops_device: it represents the number of reading the block device per second, as a string. The string is parsed as a series of /path/to/device, write_bps elements, separated by ','."]},{"$":{"name":"VIR_DOMAIN_BLKIO_DEVICE_WRITE_IOPS","file":"libvirt-domain","string":"device_write_iops_sec"},"info":["Macro for the blkio tunable throttle.write_iops_device: it represents the number of writing the block device per second, as a string. The string is parsed as a series of /path/to/device, write_iops elements, separated by ','."]},{"$":{"name":"VIR_DOMAIN_BLKIO_FIELD_LENGTH","file":"libvirt-domain"},"info":["Macro providing the field length of virBlkioParameter.  Provided for backwards compatibility; VIR_TYPED_PARAM_FIELD_LENGTH is the preferred value since 0.9.2."]},{"$":{"name":"VIR_DOMAIN_BLKIO_WEIGHT","file":"libvirt-domain","string":"weight"},"info":["Macro for the Blkio tunable weight: it represents the io weight the guest can use, as a uint."]},{"$":{"name":"VIR_DOMAIN_BLOCK_COPY_BANDWIDTH","file":"libvirt-domain","string":"bandwidth"},"info":["Macro for the virDomainBlockCopy bandwidth tunable: it represents the maximum bandwidth in bytes/s, and is used while getting the copy operation into the mirrored phase, with a type of ullong.  For compatibility with virDomainBlockJobSetSpeed(), values larger than 2^52 bytes/sec (a 32-bit MiB/s value) may be rejected on input due to overflow considerations (but do you really have an interface with that much bandwidth?), and values larger than 2^31 bytes/sec may cause overflow problems if queried in bytes/sec.  Hypervisors may further restrict the set of valid values. Specifying 0 is the same as omitting this parameter, to request no bandwidth limiting. Some hypervisors may lack support for this parameter, while still allowing a subsequent change of bandwidth via virDomainBlockJobSetSpeed().  The actual speed can be determined with virDomainGetBlockJobInfo()."]},{"$":{"name":"VIR_DOMAIN_BLOCK_COPY_BUF_SIZE","file":"libvirt-domain","string":"buf-size"},"info":["Macro for the virDomainBlockCopy buffer size tunable: it represents how much data in bytes can be in flight between source and destination, as an unsigned long long. Specifying 0 is the same as omitting this parameter, to request the hypervisor default."]},{"$":{"name":"VIR_DOMAIN_BLOCK_COPY_GRANULARITY","file":"libvirt-domain","string":"granularity"},"info":["Macro for the virDomainBlockCopy granularity tunable: it represents the granularity in bytes at which the copy operation recognizes dirty blocks that need copying, as an unsigned int.  Hypervisors may restrict this to be a power of two or fall within a certain range. Specifying 0 is the same as omitting this parameter, to request the hypervisor default."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_GROUP_NAME","file":"libvirt-domain","string":"group_name"},"info":["Macro for the BlockIoTune tunable weight: it represents a group name to allow sharing of I/O throttling quota between multiple drives, as a string."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC","file":"libvirt-domain","string":"read_bytes_sec"},"info":["Macro for the BlockIoTune tunable weight: it represents the read bytes per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX","file":"libvirt-domain","string":"read_bytes_sec_max"},"info":["Macro for the BlockIoTune tunable weight: it represents the maximum read bytes per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_READ_BYTES_SEC_MAX_LENGTH","file":"libvirt-domain","string":"read_bytes_sec_max_length"},"info":["Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by read_bytes_sec_max, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC","file":"libvirt-domain","string":"read_iops_sec"},"info":["Macro for the BlockIoTune tunable weight: it represents the read I/O operations per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX","file":"libvirt-domain","string":"read_iops_sec_max"},"info":["Macro for the BlockIoTune tunable weight: it represents the maximum read I/O operations per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_READ_IOPS_SEC_MAX_LENGTH","file":"libvirt-domain","string":"read_iops_sec_max_length"},"info":["Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by read_iops_sec_max, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_SIZE_IOPS_SEC","file":"libvirt-domain","string":"size_iops_sec"},"info":["Macro for the BlockIoTune tunable weight: it represents the size I/O operations per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC","file":"libvirt-domain","string":"total_bytes_sec"},"info":["Macro for the BlockIoTune tunable weight: it represents the total bytes per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX","file":"libvirt-domain","string":"total_bytes_sec_max"},"info":["Macro for the BlockIoTune tunable weight: it represents the maximum total bytes per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_BYTES_SEC_MAX_LENGTH","file":"libvirt-domain","string":"total_bytes_sec_max_length"},"info":["Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by total_bytes_sec_max, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC","file":"libvirt-domain","string":"total_iops_sec"},"info":["Macro for the BlockIoTune tunable weight: it represents the total I/O operations per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX","file":"libvirt-domain","string":"total_iops_sec_max"},"info":["Macro for the BlockIoTune tunable weight: it represents the maximum I/O operations per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_TOTAL_IOPS_SEC_MAX_LENGTH","file":"libvirt-domain","string":"total_iops_sec_max_length"},"info":["Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by total_iops_sec_max, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC","file":"libvirt-domain","string":"write_bytes_sec"},"info":["Macro for the BlockIoTune tunable weight: it represents the write bytes per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX","file":"libvirt-domain","string":"write_bytes_sec_max"},"info":["Macro for the BlockIoTune tunable weight: it represents the maximum write bytes per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_BYTES_SEC_MAX_LENGTH","file":"libvirt-domain","string":"write_bytes_sec_max_length"},"info":["Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by write_bytes_sec_max, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC","file":"libvirt-domain","string":"write_iops_sec"},"info":["Macro for the BlockIoTune tunable weight: it represents the write I/O operations per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX","file":"libvirt-domain","string":"write_iops_sec_max"},"info":["Macro for the BlockIoTune tunable weight: it represents the maximum write I/O operations per second permitted through a block device, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_IOTUNE_WRITE_IOPS_SEC_MAX_LENGTH","file":"libvirt-domain","string":"write_iops_sec_max_length"},"info":["Macro for the BlockIoTune tunable weight: it represents the duration in seconds for the burst allowed by write_iops_sec_max, as a ullong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_ERRS","file":"libvirt-domain","string":"errs"},"info":["In Xen this returns the mysterious 'oo_req', as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_FIELD_LENGTH","file":"libvirt-domain"},"info":["Macro providing the field length of parameter names when using virDomainBlockStatsFlags()."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_FLUSH_REQ","file":"libvirt-domain","string":"flush_operations"},"info":["Macro represents the total flush requests of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_FLUSH_TOTAL_TIMES","file":"libvirt-domain","string":"flush_total_times"},"info":["Macro represents the total time spend on cache flushing in nano-seconds of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_READ_BYTES","file":"libvirt-domain","string":"rd_bytes"},"info":["Macro represents the total number of read bytes of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_READ_REQ","file":"libvirt-domain","string":"rd_operations"},"info":["Macro represents the total read requests of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_READ_TOTAL_TIMES","file":"libvirt-domain","string":"rd_total_times"},"info":["Macro represents the total time spend on cache reads in nano-seconds of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_WRITE_BYTES","file":"libvirt-domain","string":"wr_bytes"},"info":["Macro represents the total number of write bytes of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_WRITE_REQ","file":"libvirt-domain","string":"wr_operations"},"info":["Macro represents the total write requests of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_BLOCK_STATS_WRITE_TOTAL_TIMES","file":"libvirt-domain","string":"wr_total_times"},"info":["Macro represents the total time spend on cache writes in nano-seconds of the block device, as an llong."]},{"$":{"name":"VIR_DOMAIN_CPU_STATS_CPUTIME","file":"libvirt-domain","string":"cpu_time"},"info":["cpu usage (sum of both vcpu and hypervisor usage) in nanoseconds, as a ullong"]},{"$":{"name":"VIR_DOMAIN_CPU_STATS_SYSTEMTIME","file":"libvirt-domain","string":"system_time"},"info":["cpu time charged to system instructions in nanoseconds, as a ullong"]},{"$":{"name":"VIR_DOMAIN_CPU_STATS_USERTIME","file":"libvirt-domain","string":"user_time"},"info":["cpu time charged to user instructions in nanoseconds, as a ullong"]},{"$":{"name":"VIR_DOMAIN_CPU_STATS_VCPUTIME","file":"libvirt-domain","string":"vcpu_time"},"info":["vcpu usage in nanoseconds (cpu_time excluding hypervisor time), as a ullong"]},{"$":{"name":"VIR_DOMAIN_EVENT_CALLBACK","file":"libvirt-domain"},"info":["Used to cast the event specific callback into the generic one for use for virConnectDomainEventRegisterAny()"]},{"$":{"name":"VIR_DOMAIN_JOB_AUTO_CONVERGE_THROTTLE","file":"libvirt-domain","string":"auto_converge_throttle"},"info":["virDomainGetJobStats field: current percentage guest CPUs are throttled to when auto-convergence decided migration was not converging, as VIR_TYPED_PARAM_INT."]},{"$":{"name":"VIR_DOMAIN_JOB_COMPRESSION_BYTES","file":"libvirt-domain","string":"compression_bytes"},"info":["virDomainGetJobStats field: number of compressed bytes transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_COMPRESSION_CACHE","file":"libvirt-domain","string":"compression_cache"},"info":["virDomainGetJobStats field: size of the cache (in bytes) used for compressing repeatedly transferred memory pages during live migration, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_COMPRESSION_CACHE_MISSES","file":"libvirt-domain","string":"compression_cache_misses"},"info":["virDomainGetJobStats field: number of repeatedly changing pages that were not found in compression cache and thus could not be compressed, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_COMPRESSION_OVERFLOW","file":"libvirt-domain","string":"compression_overflow"},"info":["virDomainGetJobStats field: number of repeatedly changing pages that were found in compression cache but were sent uncompressed because the result of compression was larger than the original page as a whole, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_COMPRESSION_PAGES","file":"libvirt-domain","string":"compression_pages"},"info":["virDomainGetJobStats field: number of compressed pages transferred since the beginning of migration, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_DATA_PROCESSED","file":"libvirt-domain","string":"data_processed"},"info":["virDomainGetJobStats field: number of bytes transferred from the beginning of the job, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to dataProcessed field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_DATA_REMAINING","file":"libvirt-domain","string":"data_remaining"},"info":["virDomainGetJobStats field: number of bytes that still need to be transferred, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to dataRemaining field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_DATA_TOTAL","file":"libvirt-domain","string":"data_total"},"info":["virDomainGetJobStats field: total number of bytes supposed to be transferred, as VIR_TYPED_PARAM_ULLONG. For VIR_DOMAIN_JOB_UNBOUNDED jobs, this may be less than the sum of VIR_DOMAIN_JOB_DATA_PROCESSED and VIR_DOMAIN_JOB_DATA_REMAINING in the event that the hypervisor has to repeat some data, e.g., due to dirtied pages during migration. For VIR_DOMAIN_JOB_BOUNDED jobs, VIR_DOMAIN_JOB_DATA_TOTAL shall always equal VIR_DOMAIN_JOB_DATA_PROCESSED + VIR_DOMAIN_JOB_DATA_REMAINING.  This field corresponds to dataTotal field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_DISK_BPS","file":"libvirt-domain","string":"disk_bps"},"info":["virDomainGetJobStats field: network throughput used while migrating disks in Bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_DISK_PROCESSED","file":"libvirt-domain","string":"disk_processed"},"info":["virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_PROCESSED but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to fileProcessed field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_DISK_REMAINING","file":"libvirt-domain","string":"disk_remaining"},"info":["virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_REMAINING but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to fileRemaining field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_DISK_TOTAL","file":"libvirt-domain","string":"disk_total"},"info":["virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_TOTAL but only tracking guest disk progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to fileTotal field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_DOWNTIME","file":"libvirt-domain","string":"downtime"},"info":["virDomainGetJobStats field: downtime (ms) that is expected to happen during migration, as VIR_TYPED_PARAM_ULLONG. The real computed downtime between the time guest CPUs were paused and the time they were resumed is reported for completed migration."]},{"$":{"name":"VIR_DOMAIN_JOB_DOWNTIME_NET","file":"libvirt-domain","string":"downtime_net"},"info":["virDomainGetJobStats field: real measured downtime (ms) NOT including the time required to transfer control flow from the source host to the destination host, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_BPS","file":"libvirt-domain","string":"memory_bps"},"info":["virDomainGetJobStats field: network throughput used while migrating memory in Bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_CONSTANT","file":"libvirt-domain","string":"memory_constant"},"info":["virDomainGetJobStats field: number of pages filled with a constant byte (all bytes in a single page are identical) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG.  The most common example of such pages are zero pages, i.e., pages filled with zero bytes."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE","file":"libvirt-domain","string":"memory_dirty_rate"},"info":["virDomainGetJobStats field: number of memory pages dirtied by the guest per second, as VIR_TYPED_PARAM_ULLONG. This statistics makes sense only when live migration is running."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_ITERATION","file":"libvirt-domain","string":"memory_iteration"},"info":["virDomainGetJobStats field: current iteration over domain's memory during live migration, as VIR_TYPED_PARAM_ULLONG. This is set to zero when memory starts to be transferred and the value is increased by one every time a new iteration is started to transfer memory pages dirtied since the last iteration."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_NORMAL","file":"libvirt-domain","string":"memory_normal"},"info":["virDomainGetJobStats field: number of pages that were transferred without any kind of compression (i.e., pages which were not filled with a constant byte and which could not be compressed) transferred since the beginning of the migration job, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_NORMAL_BYTES","file":"libvirt-domain","string":"memory_normal_bytes"},"info":["virDomainGetJobStats field: number of bytes transferred as normal pages, as VIR_TYPED_PARAM_ULLONG.  See VIR_DOMAIN_JOB_MEMORY_NORMAL for more details."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_PAGE_SIZE","file":"libvirt-domain","string":"memory_page_size"},"info":["virDomainGetJobStats field: memory page size in bytes, as VIR_TYPED_PARAM_ULLONG. If present, this parameter can be used to convert other page based statistics, such as VIR_DOMAIN_JOB_MEMORY_DIRTY_RATE or VIR_DOMAIN_JOB_COMPRESSION_PAGES to bytes."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_PROCESSED","file":"libvirt-domain","string":"memory_processed"},"info":["virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_PROCESSED but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to memProcessed field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_REMAINING","file":"libvirt-domain","string":"memory_remaining"},"info":["virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_REMAINING but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to memRemaining field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_MEMORY_TOTAL","file":"libvirt-domain","string":"memory_total"},"info":["virDomainGetJobStats field: as VIR_DOMAIN_JOB_DATA_TOTAL but only tracking guest memory progress, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to memTotal field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION","file":"libvirt-domain","string":"operation"},"info":["virDomainGetJobStats field: the operation which started the job as VIR_TYPED_PARAM_INT. The values correspond to the items in virDomainJobOperation enum."]},{"$":{"name":"VIR_DOMAIN_JOB_SETUP_TIME","file":"libvirt-domain","string":"setup_time"},"info":["virDomainGetJobStats field: total time in milliseconds spent preparing the migration in the 'setup' phase before the iterations begin, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_TIME_ELAPSED","file":"libvirt-domain","string":"time_elapsed"},"info":["virDomainGetJobStats field: time (ms) since the beginning of the job, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to timeElapsed field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_JOB_TIME_ELAPSED_NET","file":"libvirt-domain","string":"time_elapsed_net"},"info":["virDomainGetJobStats field: time (ms) since the beginning of the migration job NOT including the time required to transfer control flow from the source host to the destination host, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_JOB_TIME_REMAINING","file":"libvirt-domain","string":"time_remaining"},"info":["virDomainGetJobStats field: remaining time (ms) for VIR_DOMAIN_JOB_BOUNDED jobs, as VIR_TYPED_PARAM_ULLONG.  This field corresponds to timeRemaining field in virDomainJobInfo."]},{"$":{"name":"VIR_DOMAIN_MEMORY_FIELD_LENGTH","file":"libvirt-domain"},"info":["Macro providing the field length of virMemoryParameter.  Provided for backwards compatibility; VIR_TYPED_PARAM_FIELD_LENGTH is the preferred value since 0.9.2."]},{"$":{"name":"VIR_DOMAIN_MEMORY_HARD_LIMIT","file":"libvirt-domain","string":"hard_limit"},"info":["Macro for the memory tunable hard_limit: it represents the maximum memory the guest can use, as a ullong."]},{"$":{"name":"VIR_DOMAIN_MEMORY_MIN_GUARANTEE","file":"libvirt-domain","string":"min_guarantee"},"info":["Macro for the memory tunable min_guarantee: it represents the minimum memory guaranteed to be reserved for the guest, as a ullong."]},{"$":{"name":"VIR_DOMAIN_MEMORY_PARAM_UNLIMITED","file":"libvirt-domain"},"info":["Macro providing the virMemoryParameter value that indicates \"unlimited\""]},{"$":{"name":"VIR_DOMAIN_MEMORY_SOFT_LIMIT","file":"libvirt-domain","string":"soft_limit"},"info":["Macro for the memory tunable soft_limit: it represents the memory upper limit enforced during memory contention, as a ullong."]},{"$":{"name":"VIR_DOMAIN_MEMORY_SWAP_HARD_LIMIT","file":"libvirt-domain","string":"swap_hard_limit"},"info":["Macro for the swap tunable swap_hard_limit: it represents the maximum swap plus memory the guest can use, as a ullong. This limit has to be more than VIR_DOMAIN_MEMORY_HARD_LIMIT."]},{"$":{"name":"VIR_DOMAIN_NUMA_MODE","file":"libvirt-domain","string":"numa_mode"},"info":["Macro for typed parameter name that lists the numa mode of a domain, as an int containing a virDomainNumatuneMemMode value."]},{"$":{"name":"VIR_DOMAIN_NUMA_NODESET","file":"libvirt-domain","string":"numa_nodeset"},"info":["Macro for typed parameter name that lists the numa nodeset of a domain, as a string."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_CAP","file":"libvirt-domain","string":"cap"},"info":["Macro represents the maximum scheduler cap, when using the credit scheduler, as a uint."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_CPU_SHARES","file":"libvirt-domain","string":"cpu_shares"},"info":["Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as a ullong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_EMULATOR_PERIOD","file":"libvirt-domain","string":"emulator_period"},"info":["Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as a ullong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_EMULATOR_QUOTA","file":"libvirt-domain","string":"emulator_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an llong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_GLOBAL_PERIOD","file":"libvirt-domain","string":"global_period"},"info":["Macro represents the enforcement period for a quota, in microseconds, for whole domain, when using the posix scheduler, as a ullong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_GLOBAL_QUOTA","file":"libvirt-domain","string":"global_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for whole domain, when using the posix scheduler, as an llong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_IOTHREAD_PERIOD","file":"libvirt-domain","string":"iothread_period"},"info":["Macro represents the enforcement period for a quota, in microseconds, for IOThreads only, when using the posix scheduler, as a ullong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_IOTHREAD_QUOTA","file":"libvirt-domain","string":"iothread_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for IOThreads only, when using the posix scheduler, as an llong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_LIMIT","file":"libvirt-domain","string":"limit"},"info":["Macro represents the scheduler limit value, when using the allocation scheduler, as an llong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_RESERVATION","file":"libvirt-domain","string":"reservation"},"info":["Macro represents the scheduler reservation value, when using the allocation scheduler, as an llong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_SHARES","file":"libvirt-domain","string":"shares"},"info":["Macro represents the scheduler shares value, when using the allocation scheduler, as an int."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_VCPU_PERIOD","file":"libvirt-domain","string":"vcpu_period"},"info":["Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as a ullong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_VCPU_QUOTA","file":"libvirt-domain","string":"vcpu_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as an llong."]},{"$":{"name":"VIR_DOMAIN_SCHEDULER_WEIGHT","file":"libvirt-domain","string":"weight"},"info":["Macro represents the relative weight,  when using the credit scheduler, as a uint."]},{"$":{"name":"VIR_DOMAIN_SCHED_FIELD_LENGTH","file":"libvirt-domain"},"info":["Macro providing the field length of virSchedParameter.  Provided for backwards compatibility; VIR_TYPED_PARAM_FIELD_LENGTH is the preferred value since 0.9.2."]},{"$":{"name":"VIR_DOMAIN_SEND_KEY_MAX_KEYS","file":"libvirt-domain"},"info":["Maximum number of keycodes that can be sent in one virDomainSendKey() call."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_DISK","file":"libvirt-domain","string":"blkdeviotune.disk"},"info":["Macro represents the name of guest disk for which the values are updated, as VIR_TYPED_PARAM_STRING."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_GROUP_NAME","file":"libvirt-domain","string":"blkdeviotune.group_name"},"info":["Macro represents the group name to be used, as VIR_TYPED_PARAM_STRING."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC","file":"libvirt-domain","string":"blkdeviotune.read_bytes_sec"},"info":["Macro represents the read throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX","file":"libvirt-domain","string":"blkdeviotune.read_bytes_sec_max"},"info":["Macro represents the read throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_BYTES_SEC_MAX_LENGTH","file":"libvirt-domain","string":"blkdeviotune.read_bytes_sec_max_length"},"info":["Macro represents the length in seconds allowed for a burst period for the blkdeviotune.read_bytes_sec_max as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC","file":"libvirt-domain","string":"blkdeviotune.read_iops_sec"},"info":["Macro represents the read I/O operations per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX","file":"libvirt-domain","string":"blkdeviotune.read_iops_sec_max"},"info":["Macro represents the read maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_READ_IOPS_SEC_MAX_LENGTH","file":"libvirt-domain","string":"blkdeviotune.read_iops_sec_max_length"},"info":["Macro represents the length in seconds allowed for a burst period for the blkdeviotune.read_iops_sec_max as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_SIZE_IOPS_SEC","file":"libvirt-domain","string":"blkdeviotune.size_iops_sec"},"info":["Macro represents the size maximum I/O operations per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC","file":"libvirt-domain","string":"blkdeviotune.total_bytes_sec"},"info":["Macro represents the total throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX","file":"libvirt-domain","string":"blkdeviotune.total_bytes_sec_max"},"info":["Macro represents the total throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_BYTES_SEC_MAX_LENGTH","file":"libvirt-domain","string":"blkdeviotune.total_bytes_sec_max_length"},"info":["Macro represents the length in seconds allowed for a burst period for the blkdeviotune.total_bytes_sec_max, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC","file":"libvirt-domain","string":"blkdeviotune.total_iops_sec"},"info":["Macro represents the total I/O operations per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX","file":"libvirt-domain","string":"blkdeviotune.total_iops_sec_max"},"info":["Macro represents the total maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_TOTAL_IOPS_SEC_MAX_LENGTH","file":"libvirt-domain","string":"blkdeviotune.total_iops_sec_max_length"},"info":["Macro represents the length in seconds allowed for a burst period for the blkdeviotune.total_iops_sec_max as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC","file":"libvirt-domain","string":"blkdeviotune.write_bytes_sec"},"info":["Macro represents the write throughput limit in bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX","file":"libvirt-domain","string":"blkdeviotune.write_bytes_sec_max"},"info":["Macro represents the write throughput limit during bursts in maximum bytes per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_BYTES_SEC_MAX_LENGTH","file":"libvirt-domain","string":"blkdeviotune.write_bytes_sec_max_length"},"info":["Macro represents the length in seconds allowed for a burst period for the blkdeviotune.write_bytes_sec_max as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC","file":"libvirt-domain","string":"blkdeviotune.write_iops_sec"},"info":["Macro represents the write I/O operations per second, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX","file":"libvirt-domain","string":"blkdeviotune.write_iops_sec_max"},"info":["Macro represents the write maximum I/O operations per second during bursts, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_BLKDEV_WRITE_IOPS_SEC_MAX_LENGTH","file":"libvirt-domain","string":"blkdeviotune.write_iops_sec_max_length"},"info":["Macro represents the length in seconds allowed for a burst period for the blkdeviotune.write_iops_sec_max as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_CPU_SHARES","file":"libvirt-domain","string":"cputune.cpu_shares"},"info":["Macro represents proportional weight of the scheduler used on the host cpu, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_EMULATORPIN","file":"libvirt-domain","string":"cputune.emulatorpin"},"info":["Macro represents formatted pinning for emulator process, as VIR_TYPED_PARAM_STRING."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_EMULATOR_PERIOD","file":"libvirt-domain","string":"cputune.emulator_period"},"info":["Macro represents the enforcement period for a quota in microseconds, when using the posix scheduler, for all emulator activity not tied to vcpus, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_EMULATOR_QUOTA","file":"libvirt-domain","string":"cputune.emulator_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for all emulator activity not tied to vcpus, when using the posix scheduler, as an VIR_TYPED_PARAM_LLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_GLOBAL_PERIOD","file":"libvirt-domain","string":"cputune.global_period"},"info":["Macro represents the enforcement period for a quota, in microseconds, for whole domain, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_GLOBAL_QUOTA","file":"libvirt-domain","string":"cputune.global_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for whole domain, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_IOTHREADSPIN","file":"libvirt-domain","string":"cputune.iothreadpin%u"},"info":["Macro represents formatted pinning for one IOThread specified by id which is appended to the parameter name, for example \"cputune.iothreadpin1\", as VIR_TYPED_PARAM_STRING."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_PERIOD","file":"libvirt-domain","string":"cputune.iothread_period"},"info":["Macro represents the enforcement period for a quota, in microseconds, for iothreads only, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_IOTHREAD_QUOTA","file":"libvirt-domain","string":"cputune.iothread_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for iothreads only, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_VCPUPIN","file":"libvirt-domain","string":"cputune.vcpupin%u"},"info":["Macro represents formatted pinning for one vcpu specified by id which is appended to the parameter name, for example \"cputune.vcpupin1\", as VIR_TYPED_PARAM_STRING."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_VCPU_PERIOD","file":"libvirt-domain","string":"cputune.vcpu_period"},"info":["Macro represents the enforcement period for a quota, in microseconds, for vcpus only, when using the posix scheduler, as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_DOMAIN_TUNABLE_CPU_VCPU_QUOTA","file":"libvirt-domain","string":"cputune.vcpu_quota"},"info":["Macro represents the maximum bandwidth to be used within a period for vcpus only, when using the posix scheduler, as VIR_TYPED_PARAM_LLONG."]},{"$":{"name":"VIR_GET_CPUMAP","file":"libvirt-domain"},"info":["This macro is to be used in conjunction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_GET_CPUMAP macro returns a pointer to the cpumap of the specified vcpu from cpumaps array."],"arg":[{"$":{"name":"cpumaps","info":"pointer to an array of cpumap (in 8-bit bytes) (IN)"}},{"$":{"name":"maplen","info":"the length (in bytes) of one cpumap"}},{"$":{"name":"vcpu","info":"the virtual CPU number"}}]},{"$":{"name":"VIR_KEYCODE_SET_RFB","file":"libvirt-domain"},"info":["Compatibility alias for VIR_KEYCODE_SET_QNUM, which replaced it since 4.2.0."]},{"$":{"name":"VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT","file":"libvirt-domain","string":"auto_converge.increment"},"info":["virDomainMigrate* params field: the increment added to VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL whenever the hypervisor decides the current rate is not enough to ensure convergence of the migration. As VIR_TYPED_PARAM_INT."]},{"$":{"name":"VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL","file":"libvirt-domain","string":"auto_converge.initial"},"info":["virDomainMigrate* params field: the initial percentage guest CPUs are throttled to when auto-convergence decides migration is not converging. As VIR_TYPED_PARAM_INT."]},{"$":{"name":"VIR_MIGRATE_PARAM_BANDWIDTH","file":"libvirt-domain","string":"bandwidth"},"info":["virDomainMigrate* params field: the maximum bandwidth (in MiB/s) that will be used for migration as VIR_TYPED_PARAM_ULLONG. If set to 0 or omitted, libvirt will choose a suitable default. Some hypervisors do not support this feature and will return an error if this field is used and is not 0."]},{"$":{"name":"VIR_MIGRATE_PARAM_COMPRESSION","file":"libvirt-domain","string":"compression"},"info":["virDomainMigrate* params multiple field: name of the method used to compress migration traffic. Supported compression methods: xbzrle, mt. The parameter may be specified multiple times if more than one method should be used."]},{"$":{"name":"VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS","file":"libvirt-domain","string":"compression.mt.dthreads"},"info":["virDomainMigrate* params field: the number of decompression threads for multithread compression as VIR_TYPED_PARAM_INT."]},{"$":{"name":"VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL","file":"libvirt-domain","string":"compression.mt.level"},"info":["virDomainMigrate* params field: the level of compression for multithread compression as VIR_TYPED_PARAM_INT. Accepted values are in range 0-9. 0 is no compression, 1 is maximum speed and 9 is maximum compression."]},{"$":{"name":"VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS","file":"libvirt-domain","string":"compression.mt.threads"},"info":["virDomainMigrate* params field: the number of compression threads for multithread compression as VIR_TYPED_PARAM_INT."]},{"$":{"name":"VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE","file":"libvirt-domain","string":"compression.xbzrle.cache"},"info":["virDomainMigrate* params field: the size of page cache for xbzrle compression as VIR_TYPED_PARAM_ULLONG."]},{"$":{"name":"VIR_MIGRATE_PARAM_DEST_NAME","file":"libvirt-domain","string":"destination_name"},"info":["virDomainMigrate* params field: the name to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. Omitting this parameter keeps the domain name the same. This field is only allowed to be used with hypervisors that support domain renaming during migration."]},{"$":{"name":"VIR_MIGRATE_PARAM_DEST_XML","file":"libvirt-domain","string":"destination_xml"},"info":["virDomainMigrate* params field: the new configuration to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. The configuration must include an identical set of virtual devices, to ensure a stable guest ABI across migration. Only parameters related to host side configuration can be changed in the XML. Hypervisors which support this field will forbid migration if the provided XML would cause a change in the guest ABI. This field cannot be used to rename the domain during migration (use VIR_MIGRATE_PARAM_DEST_NAME field for that purpose). Domain name in the destination XML must match the original domain name.  Omitting this parameter keeps the original domain configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure."]},{"$":{"name":"VIR_MIGRATE_PARAM_DISKS_PORT","file":"libvirt-domain","string":"disks_port"},"info":["virDomainMigrate* params field: port that destination server should use for incoming disks migration. Type is VIR_TYPED_PARAM_INT. If set to 0 or omitted, libvirt will choose a suitable default. At the moment this is only supported by the QEMU driver."]},{"$":{"name":"VIR_MIGRATE_PARAM_GRAPHICS_URI","file":"libvirt-domain","string":"graphics_uri"},"info":["virDomainMigrate* params field: URI to use for migrating client's connection to domain's graphical console as VIR_TYPED_PARAM_STRING. If specified, the client will be asked to automatically reconnect using these parameters instead of the automatically computed ones. This can be useful if, e.g., the client does not have a direct access to the network virtualization hosts are connected to and needs to connect through a proxy. The URI is formed as follows:  protocol://hostname[:port]/[?parameters]  where protocol is either \"spice\" or \"vnc\" and parameters is a list of protocol specific parameters separated by '&'. Currently recognized parameters are \"tlsPort\" and \"tlsSubject\". For example,  spice://target.host.com:1234/?tlsPort=4567"]},{"$":{"name":"VIR_MIGRATE_PARAM_LISTEN_ADDRESS","file":"libvirt-domain","string":"listen_address"},"info":["virDomainMigrate* params field: The listen address that hypervisor on the destination side should bind to for incoming migration. Both IPv4 and IPv6 addresses are accepted as well as hostnames (the resolving is done on destination). Some hypervisors do not support this feature and will return an error if this field is used."]},{"$":{"name":"VIR_MIGRATE_PARAM_MIGRATE_DISKS","file":"libvirt-domain","string":"migrate_disks"},"info":["virDomainMigrate* params multiple field: The multiple values that list the block devices to be migrated. At the moment this is only supported by the QEMU driver but not for the tunnelled migration."]},{"$":{"name":"VIR_MIGRATE_PARAM_PERSIST_XML","file":"libvirt-domain","string":"persistent_xml"},"info":["virDomainMigrate* params field: the new persistent configuration to be used for the domain on the destination host as VIR_TYPED_PARAM_STRING. This field cannot be used to rename the domain during migration (use VIR_MIGRATE_PARAM_DEST_NAME field for that purpose). Domain name in the destination XML must match the original domain name.  Omitting this parameter keeps the original domain persistent configuration. Using this field with hypervisors that do not support changing domain configuration during migration will result in a failure."]},{"$":{"name":"VIR_MIGRATE_PARAM_URI","file":"libvirt-domain","string":"migrate_uri"},"info":["virDomainMigrate* params field: URI to use for initiating domain migration as VIR_TYPED_PARAM_STRING. It takes a hypervisor specific format. The uri_transports element of the hypervisor capabilities XML includes details of the supported URI schemes. When omitted libvirt will auto-generate suitable default URI. It is typically only necessary to specify this URI if the destination host has multiple interfaces and a specific interface is required to transmit migration data.  This field may not be used when VIR_MIGRATE_TUNNELLED flag is set."]},{"$":{"name":"VIR_NETWORK_EVENT_CALLBACK","file":"libvirt-network"},"info":["Used to cast the event specific callback into the generic one for use for virConnectNetworkEventRegisterAny()"]},{"$":{"name":"VIR_NODEINFO_MAXCPUS","file":"libvirt-host"},"info":["This macro is to calculate the total number of CPUs supported but not necessary active in the host."],"arg":[{"$":{"name":"nodeinfo","info":"virNodeInfo instance"}}]},{"$":{"name":"VIR_NODE_CPU_STATS_FIELD_LENGTH","file":"libvirt-host"},"info":["Macro providing the field length of virNodeCPUStats"]},{"$":{"name":"VIR_NODE_CPU_STATS_IDLE","file":"libvirt-host","string":"idle"},"info":["The cumulative idle CPU time, since the node booting up (in nanoseconds)."]},{"$":{"name":"VIR_NODE_CPU_STATS_INTR","file":"libvirt-host","string":"intr"},"info":["The cumulative interrupt CPU time, since the node booting up (in nanoseconds)."]},{"$":{"name":"VIR_NODE_CPU_STATS_IOWAIT","file":"libvirt-host","string":"iowait"},"info":["The cumulative I/O wait CPU time, since the node booting up (in nanoseconds)."]},{"$":{"name":"VIR_NODE_CPU_STATS_KERNEL","file":"libvirt-host","string":"kernel"},"info":["Macro for the cumulative CPU time which was spent by the kernel, since the node booting up (in nanoseconds)."]},{"$":{"name":"VIR_NODE_CPU_STATS_USER","file":"libvirt-host","string":"user"},"info":["The cumulative CPU time which was spent by user processes, since the node booting up (in nanoseconds)."]},{"$":{"name":"VIR_NODE_CPU_STATS_UTILIZATION","file":"libvirt-host","string":"utilization"},"info":["The CPU utilization of a node. The usage value is in percent and 100% represents all CPUs of the node."]},{"$":{"name":"VIR_NODE_DEVICE_EVENT_CALLBACK","file":"libvirt-nodedev"},"info":["Used to cast the event specific callback into the generic one for use for virConnectNodeDeviceEventRegisterAny()"]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_FULL_SCANS","file":"libvirt-host","string":"shm_full_scans"},"info":["Macro for typed parameter that represents how many times all mergeable areas have been scanned."]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_MERGE_ACROSS_NODES","file":"libvirt-host","string":"shm_merge_across_nodes"},"info":["Macro for typed parameter that represents whether pages from different NUMA nodes can be merged. The parameter has type int, when its value is 0, only pages which physically reside in the memory area of same NUMA node are merged; When its value is 1, pages from all nodes can be merged. Other values are reserved for future use."]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_PAGES_SHARED","file":"libvirt-host","string":"shm_pages_shared"},"info":["Macro for typed parameter that represents how many the shared memory pages are being used."]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_PAGES_SHARING","file":"libvirt-host","string":"shm_pages_sharing"},"info":["Macro for typed parameter that represents how many sites are sharing the pages i.e. how much saved."]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_PAGES_TO_SCAN","file":"libvirt-host","string":"shm_pages_to_scan"},"info":["Macro for typed parameter that represents how many present pages to scan before the shared memory service goes to sleep."]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_PAGES_UNSHARED","file":"libvirt-host","string":"shm_pages_unshared"},"info":["Macro for typed parameter that represents how many pages unique but repeatedly checked for merging."]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_PAGES_VOLATILE","file":"libvirt-host","string":"shm_pages_volatile"},"info":["Macro for typed parameter that represents how many pages changing too fast to be placed in a tree."]},{"$":{"name":"VIR_NODE_MEMORY_SHARED_SLEEP_MILLISECS","file":"libvirt-host","string":"shm_sleep_millisecs"},"info":["Macro for typed parameter that represents how many milliseconds the shared memory service should sleep before next scan."]},{"$":{"name":"VIR_NODE_MEMORY_STATS_BUFFERS","file":"libvirt-host","string":"buffers"},"info":["Macro for the buffer memory: On Linux, it is only returned in case of VIR_NODE_MEMORY_STATS_ALL_CELLS."]},{"$":{"name":"VIR_NODE_MEMORY_STATS_CACHED","file":"libvirt-host","string":"cached"},"info":["Macro for the cached memory: On Linux, it is only returned in case of VIR_NODE_MEMORY_STATS_ALL_CELLS."]},{"$":{"name":"VIR_NODE_MEMORY_STATS_FIELD_LENGTH","file":"libvirt-host"},"info":["Macro providing the field length of virNodeMemoryStats"]},{"$":{"name":"VIR_NODE_MEMORY_STATS_FREE","file":"libvirt-host","string":"free"},"info":["Macro for the free memory of specified cell: On Linux, it includes buffer and cached memory, in case of VIR_NODE_MEMORY_STATS_ALL_CELLS."]},{"$":{"name":"VIR_NODE_MEMORY_STATS_TOTAL","file":"libvirt-host","string":"total"},"info":["Macro for the total memory of specified cell: it represents the maximum memory."]},{"$":{"name":"VIR_PERF_PARAM_ALIGNMENT_FAULTS","file":"libvirt-domain","string":"alignment_faults"},"info":["Macro for typed parameter name that represents alignment_faults perf event which can be used to measure the count of alignment faults by applications running on the platform. It corresponds to the \"perf.alignment_faults\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_BRANCH_INSTRUCTIONS","file":"libvirt-domain","string":"branch_instructions"},"info":["Macro for typed parameter name that represents branch_instructions perf event which can be used to measure the count of branch instructions by applications running on the platform. It corresponds to the \"perf.branch_instructions\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_BRANCH_MISSES","file":"libvirt-domain","string":"branch_misses"},"info":["Macro for typed parameter name that represents branch_misses perf event which can be used to measure the count of branch misses by applications running on the platform. It corresponds to the \"perf.branch_misses\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_BUS_CYCLES","file":"libvirt-domain","string":"bus_cycles"},"info":["Macro for typed parameter name that represents bus_cycles perf event which can be used to measure the count of bus cycles by applications running on the platform. It corresponds to the \"perf.bus_cycles\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_CACHE_MISSES","file":"libvirt-domain","string":"cache_misses"},"info":["Macro for typed parameter name that represents cache_misses perf event which can be used to measure the count of cache misses by applications running on the platform. It corresponds to the \"perf.cache_misses\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_CACHE_REFERENCES","file":"libvirt-domain","string":"cache_references"},"info":["Macro for typed parameter name that represents cache_references perf event which can be used to measure the count of cache hits by applications running on the platform. It corresponds to the \"perf.cache_references\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_CMT","file":"libvirt-domain","string":"cmt"},"info":["Macro for typed parameter name that represents CMT perf event which can be used to measure the usage of cache (bytes) by applications running on the platform. It corresponds to the \"perf.cmt\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_CONTEXT_SWITCHES","file":"libvirt-domain","string":"context_switches"},"info":["Macro for typed parameter name that represents context_switches perf event which can be used to measure the count of context switches by applications running on the platform. It corresponds to the \"perf.context_switches\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_CPU_CLOCK","file":"libvirt-domain","string":"cpu_clock"},"info":["Macro for typed parameter name that represents cpu_clock perf event which can be used to measure the count of cpu clock time by applications running on the platform. It corresponds to the \"perf.cpu_clock\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_CPU_CYCLES","file":"libvirt-domain","string":"cpu_cycles"},"info":["Macro for typed parameter name that represents cpu_cycles perf event describing the total/elapsed cpu cycles. This can be used to measure how many cpu cycles one instruction needs. It corresponds to the \"perf.cpu_cycles\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_CPU_MIGRATIONS","file":"libvirt-domain","string":"cpu_migrations"},"info":["Macro for typed parameter name that represents cpu_migrations perf event which can be used to measure the count of cpu migrations by applications running on the platform. It corresponds to the \"perf.cpu_migrations\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_EMULATION_FAULTS","file":"libvirt-domain","string":"emulation_faults"},"info":["Macro for typed parameter name that represents emulation_faults perf event which can be used to measure the count of emulation faults by applications running on the platform. It corresponds to the \"perf.emulation_faults\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_INSTRUCTIONS","file":"libvirt-domain","string":"instructions"},"info":["Macro for typed parameter name that represents instructions perf event which can be used to measure the count of instructions by applications running on the platform. It corresponds to the \"perf.instructions\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_MBML","file":"libvirt-domain","string":"mbml"},"info":["Macro for typed parameter name that represents MBML perf event which can be used to monitor the amount of data (bytes/s) sent through the memory controller on the socket. It corresponds to the \"perf.mbml\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_MBMT","file":"libvirt-domain","string":"mbmt"},"info":["Macro for typed parameter name that represents MBMT perf event which can be used to monitor total system bandwidth (bytes/s) from one level of cache to another. It corresponds to the \"perf.mbmt\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_PAGE_FAULTS","file":"libvirt-domain","string":"page_faults"},"info":["Macro for typed parameter name that represents page_faults perf event which can be used to measure the count of page faults by applications running on the platform. It corresponds to the \"perf.page_faults\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_PAGE_FAULTS_MAJ","file":"libvirt-domain","string":"page_faults_maj"},"info":["Macro for typed parameter name that represents page_faults_maj perf event which can be used to measure the count of major page faults by applications running on the platform. It corresponds to the \"perf.page_faults_maj\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_PAGE_FAULTS_MIN","file":"libvirt-domain","string":"page_faults_min"},"info":["Macro for typed parameter name that represents page_faults_min perf event which can be used to measure the count of minor page faults by applications running on the platform. It corresponds to the \"perf.page_faults_min\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_REF_CPU_CYCLES","file":"libvirt-domain","string":"ref_cpu_cycles"},"info":["Macro for typed parameter name that represents ref_cpu_cycles perf event which can be used to measure the count of total cpu cycles not affected by CPU frequency scaling by applications running on the platform. It corresponds to the \"perf.ref_cpu_cycles\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_STALLED_CYCLES_BACKEND","file":"libvirt-domain","string":"stalled_cycles_backend"},"info":["Macro for typed parameter name that represents stalled_cycles_backend perf event which can be used to measure the count of stalled cpu cycles in the backend of the instruction processor pipeline by application running on the platform. It corresponds to the \"perf.stalled_cycles_backend\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_STALLED_CYCLES_FRONTEND","file":"libvirt-domain","string":"stalled_cycles_frontend"},"info":["Macro for typed parameter name that represents stalled_cycles_frontend perf event which can be used to measure the count of stalled cpu cycles in the frontend of the instruction processor pipeline by applications running on the platform. It corresponds to the \"perf.stalled_cycles_frontend\" field in the *Stats APIs."]},{"$":{"name":"VIR_PERF_PARAM_TASK_CLOCK","file":"libvirt-domain","string":"task_clock"},"info":["Macro for typed parameter name that represents task_clock perf event which can be used to measure the count of task clock time by applications running on the platform. It corresponds to the \"perf.task_clock\" field in the *Stats APIs."]},{"$":{"name":"VIR_SECRET_EVENT_CALLBACK","file":"libvirt-secret"},"info":["Used to cast the event specific callback into the generic one for use for virConnectSecretEventRegisterAny()"]},{"$":{"name":"VIR_SECURITY_DOI_BUFLEN","file":"libvirt-host"},"info":["Macro providing the maximum length of the virSecurityModel doi string."]},{"$":{"name":"VIR_SECURITY_LABEL_BUFLEN","file":"libvirt-host"},"info":["Macro providing the maximum length of the virSecurityLabel label string. Note that this value is based on that used by Labeled NFS."]},{"$":{"name":"VIR_SECURITY_MODEL_BUFLEN","file":"libvirt-host"},"info":["Macro providing the maximum length of the virSecurityModel model string."]},{"$":{"name":"VIR_STORAGE_POOL_EVENT_CALLBACK","file":"libvirt-storage"},"info":["Used to cast the event specific callback into the generic one for use for virConnectStoragePoolEventRegisterAny()"]},{"$":{"name":"VIR_TYPED_PARAM_FIELD_LENGTH","file":"libvirt-common"},"info":["Macro providing the field length of virTypedParameter name"]},{"$":{"name":"VIR_UNUSE_CPU","file":"libvirt-domain"},"info":["This macro is to be used in conjunction with virDomainPinVcpu() API. It resets the bit (CPU not usable) of the related cpu in cpumap."],"arg":[{"$":{"name":"cpumap","info":"pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)"}},{"$":{"name":"cpu","info":"the physical CPU number"}}]},{"$":{"name":"VIR_USE_CPU","file":"libvirt-domain"},"info":["This macro is to be used in conjunction with virDomainPinVcpu() API. It sets the bit (CPU usable) of the related cpu in cpumap."],"arg":[{"$":{"name":"cpumap","info":"pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)"}},{"$":{"name":"cpu","info":"the physical CPU number"}}]},{"$":{"name":"VIR_UUID_BUFLEN","file":"libvirt-host"},"info":["This macro provides the length of the buffer required for virDomainGetUUID()"]},{"$":{"name":"VIR_UUID_STRING_BUFLEN","file":"libvirt-host"},"info":["This macro provides the length of the buffer required for virDomainGetUUIDString()"]},{"$":{"name":"_virBlkioParameter","file":"libvirt-domain"}},{"$":{"name":"_virMemoryParameter","file":"libvirt-domain"}},{"$":{"name":"_virSchedParameter","file":"libvirt-domain"}}],"enum":[{"$":{"name":"VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES","file":"libvirt-host","value":"1","type":"virConnectBaselineCPUFlags","info":"show all features"}},{"$":{"name":"VIR_CONNECT_BASELINE_CPU_MIGRATABLE","file":"libvirt-host","value":"2","type":"virConnectBaselineCPUFlags","info":"filter out non-migratable features"}},{"$":{"name":"VIR_CONNECT_CLOSE_REASON_CLIENT","file":"libvirt-common","value":"3","type":"virConnectCloseReason","info":"Client requested it"}},{"$":{"name":"VIR_CONNECT_CLOSE_REASON_EOF","file":"libvirt-common","value":"1","type":"virConnectCloseReason","info":"End-of-file from server"}},{"$":{"name":"VIR_CONNECT_CLOSE_REASON_ERROR","file":"libvirt-common","value":"0","type":"virConnectCloseReason","info":"Misc I/O error"}},{"$":{"name":"VIR_CONNECT_CLOSE_REASON_KEEPALIVE","file":"libvirt-common","value":"2","type":"virConnectCloseReason","info":"Keepalive timer triggered"}},{"$":{"name":"VIR_CONNECT_CLOSE_REASON_LAST","file":"libvirt-common","value":"4","type":"virConnectCloseReason"}},{"$":{"name":"VIR_CONNECT_COMPARE_CPU_FAIL_INCOMPATIBLE","file":"libvirt-host","value":"1","type":"virConnectCompareCPUFlags","info":"treat incompatible\nCPUs as failure"}},{"$":{"name":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL","file":"libvirt-domain","value":"2","type":"virConnectDomainEventAgentLifecycleReason","info":"channel state changed"}},{"$":{"name":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED","file":"libvirt-domain","value":"1","type":"virConnectDomainEventAgentLifecycleReason","info":"state changed due to domain start"}},{"$":{"name":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_LAST","file":"libvirt-domain","value":"3","type":"virConnectDomainEventAgentLifecycleReason"}},{"$":{"name":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_UNKNOWN","file":"libvirt-domain","value":"0","type":"virConnectDomainEventAgentLifecycleReason","info":"unknown state change reason"}},{"$":{"name":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_CONNECTED","file":"libvirt-domain","value":"1","type":"virConnectDomainEventAgentLifecycleState","info":"agent connected"}},{"$":{"name":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_DISCONNECTED","file":"libvirt-domain","value":"2","type":"virConnectDomainEventAgentLifecycleState","info":"agent disconnected"}},{"$":{"name":"VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_STATE_LAST","file":"libvirt-domain","value":"3","type":"virConnectDomainEventAgentLifecycleState"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_ACTIVE","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING","file":"libvirt-domain","value":"1073741824","type":"virConnectGetAllDomainStatsFlags","info":"include backing chain for block stats"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS","file":"libvirt-domain","value":"2147483648","type":"virConnectGetAllDomainStatsFlags","info":"enforce requested stats"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_INACTIVE","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_OTHER","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_PAUSED","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_PERSISTENT","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_RUNNING","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_SHUTOFF","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT","file":"libvirt-domain","value":"VIR_CONNECT_LIST_DOMAINS_TRANSIENT","type":"virConnectGetAllDomainStatsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_ACTIVE","file":"libvirt-domain","value":"1","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_AUTOSTART","file":"libvirt-domain","value":"1024","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT","file":"libvirt-domain","value":"4096","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_INACTIVE","file":"libvirt-domain","value":"2","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE","file":"libvirt-domain","value":"256","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART","file":"libvirt-domain","value":"2048","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE","file":"libvirt-domain","value":"512","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT","file":"libvirt-domain","value":"8192","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_OTHER","file":"libvirt-domain","value":"128","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_PAUSED","file":"libvirt-domain","value":"32","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_PERSISTENT","file":"libvirt-domain","value":"4","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_RUNNING","file":"libvirt-domain","value":"16","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_SHUTOFF","file":"libvirt-domain","value":"64","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_DOMAINS_TRANSIENT","file":"libvirt-domain","value":"8","type":"virConnectListAllDomainsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_INTERFACES_ACTIVE","file":"libvirt-interface","value":"2","type":"virConnectListAllInterfacesFlags"}},{"$":{"name":"VIR_CONNECT_LIST_INTERFACES_INACTIVE","file":"libvirt-interface","value":"1","type":"virConnectListAllInterfacesFlags"}},{"$":{"name":"VIR_CONNECT_LIST_NETWORKS_ACTIVE","file":"libvirt-network","value":"2","type":"virConnectListAllNetworksFlags"}},{"$":{"name":"VIR_CONNECT_LIST_NETWORKS_AUTOSTART","file":"libvirt-network","value":"16","type":"virConnectListAllNetworksFlags"}},{"$":{"name":"VIR_CONNECT_LIST_NETWORKS_INACTIVE","file":"libvirt-network","value":"1","type":"virConnectListAllNetworksFlags"}},{"$":{"name":"VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART","file":"libvirt-network","value":"32","type":"virConnectListAllNetworksFlags"}},{"$":{"name":"VIR_CONNECT_LIST_NETWORKS_PERSISTENT","file":"libvirt-network","value":"4","type":"virConnectListAllNetworksFlags"}},{"$":{"name":"VIR_CONNECT_LIST_NETWORKS_TRANSIENT","file":"libvirt-network","value":"8","type":"virConnectListAllNetworksFlags"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV","file":"libvirt-nodedev","value":"32768","type":"virConnectListAllNodeDeviceFlags","info":"CCW device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM","file":"libvirt-nodedev","value":"4096","type":"virConnectListAllNodeDeviceFlags","info":"DRM device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST","file":"libvirt-nodedev","value":"512","type":"virConnectListAllNodeDeviceFlags","info":"FC Host Bus Adapter"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV","file":"libvirt-nodedev","value":"16384","type":"virConnectListAllNodeDeviceFlags","info":"Mediated device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES","file":"libvirt-nodedev","value":"8192","type":"virConnectListAllNodeDeviceFlags","info":"Capable of mediated devices"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET","file":"libvirt-nodedev","value":"16","type":"virConnectListAllNodeDeviceFlags","info":"Network device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV","file":"libvirt-nodedev","value":"2","type":"virConnectListAllNodeDeviceFlags","info":"PCI device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI","file":"libvirt-nodedev","value":"128","type":"virConnectListAllNodeDeviceFlags","info":"SCSI device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC","file":"libvirt-nodedev","value":"2048","type":"virConnectListAllNodeDeviceFlags","info":"Capable of scsi_generic"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST","file":"libvirt-nodedev","value":"32","type":"virConnectListAllNodeDeviceFlags","info":"SCSI Host Bus Adapter"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET","file":"libvirt-nodedev","value":"64","type":"virConnectListAllNodeDeviceFlags","info":"SCSI Target"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE","file":"libvirt-nodedev","value":"256","type":"virConnectListAllNodeDeviceFlags","info":"Storage device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM","file":"libvirt-nodedev","value":"1","type":"virConnectListAllNodeDeviceFlags","info":"System capability"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV","file":"libvirt-nodedev","value":"4","type":"virConnectListAllNodeDeviceFlags","info":"USB device"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE","file":"libvirt-nodedev","value":"8","type":"virConnectListAllNodeDeviceFlags","info":"USB interface"}},{"$":{"name":"VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS","file":"libvirt-nodedev","value":"1024","type":"virConnectListAllNodeDeviceFlags","info":"Capable of vport"}},{"$":{"name":"VIR_CONNECT_LIST_SECRETS_EPHEMERAL","file":"libvirt-secret","value":"1","type":"virConnectListAllSecretsFlags","info":"kept in memory, never\nstored persistently"}},{"$":{"name":"VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL","file":"libvirt-secret","value":"2","type":"virConnectListAllSecretsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_SECRETS_NO_PRIVATE","file":"libvirt-secret","value":"8","type":"virConnectListAllSecretsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_SECRETS_PRIVATE","file":"libvirt-secret","value":"4","type":"virConnectListAllSecretsFlags","info":"not revealed to any caller\nof libvirt, nor to any other\nnode"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE","file":"libvirt-storage","value":"2","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART","file":"libvirt-storage","value":"16","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_DIR","file":"libvirt-storage","value":"64","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_DISK","file":"libvirt-storage","value":"1024","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_FS","file":"libvirt-storage","value":"128","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_GLUSTER","file":"libvirt-storage","value":"65536","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE","file":"libvirt-storage","value":"1","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_ISCSI","file":"libvirt-storage","value":"2048","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL","file":"libvirt-storage","value":"512","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_MPATH","file":"libvirt-storage","value":"8192","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_NETFS","file":"libvirt-storage","value":"256","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART","file":"libvirt-storage","value":"32","type":"virConnectListAllStoragePoolsFlags","info":"List pools by type"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_PERSISTENT","file":"libvirt-storage","value":"4","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_RBD","file":"libvirt-storage","value":"16384","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_SCSI","file":"libvirt-storage","value":"4096","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG","file":"libvirt-storage","value":"32768","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT","file":"libvirt-storage","value":"8","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_VSTORAGE","file":"libvirt-storage","value":"262144","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_LIST_STORAGE_POOLS_ZFS","file":"libvirt-storage","value":"131072","type":"virConnectListAllStoragePoolsFlags"}},{"$":{"name":"VIR_CONNECT_NO_ALIASES","file":"libvirt-host","value":"2","type":"virConnectFlags","info":"Don't try to resolve URI aliases"}},{"$":{"name":"VIR_CONNECT_RO","file":"libvirt-host","value":"1","type":"virConnectFlags","info":"A readonly connection"}},{"$":{"name":"VIR_CPU_COMPARE_ERROR","file":"libvirt-host","value":"-1","type":"virCPUCompareResult"}},{"$":{"name":"VIR_CPU_COMPARE_IDENTICAL","file":"libvirt-host","value":"1","type":"virCPUCompareResult"}},{"$":{"name":"VIR_CPU_COMPARE_INCOMPATIBLE","file":"libvirt-host","value":"0","type":"virCPUCompareResult"}},{"$":{"name":"VIR_CPU_COMPARE_LAST","file":"libvirt-host","value":"3","type":"virCPUCompareResult"}},{"$":{"name":"VIR_CPU_COMPARE_SUPERSET","file":"libvirt-host","value":"2","type":"virCPUCompareResult"}},{"$":{"name":"VIR_CRED_AUTHNAME","file":"libvirt-host","value":"2","type":"virConnectCredentialType","info":"Identify to authorize as"}},{"$":{"name":"VIR_CRED_CNONCE","file":"libvirt-host","value":"4","type":"virConnectCredentialType","info":"client supplies a nonce"}},{"$":{"name":"VIR_CRED_ECHOPROMPT","file":"libvirt-host","value":"6","type":"virConnectCredentialType","info":"Challenge response"}},{"$":{"name":"VIR_CRED_EXTERNAL","file":"libvirt-host","value":"9","type":"virConnectCredentialType","info":"Externally managed credential"}},{"$":{"name":"VIR_CRED_LANGUAGE","file":"libvirt-host","value":"3","type":"virConnectCredentialType","info":"RFC 1766 languages, comma separated"}},{"$":{"name":"VIR_CRED_LAST","file":"libvirt-host","value":"10","type":"virConnectCredentialType","info":"More may be added - expect the unexpected"}},{"$":{"name":"VIR_CRED_NOECHOPROMPT","file":"libvirt-host","value":"7","type":"virConnectCredentialType","info":"Challenge response"}},{"$":{"name":"VIR_CRED_PASSPHRASE","file":"libvirt-host","value":"5","type":"virConnectCredentialType","info":"Passphrase secret"}},{"$":{"name":"VIR_CRED_REALM","file":"libvirt-host","value":"8","type":"virConnectCredentialType","info":"Authentication realm"}},{"$":{"name":"VIR_CRED_USERNAME","file":"libvirt-host","value":"1","type":"virConnectCredentialType","info":"Identity to act as"}},{"$":{"name":"VIR_DOMAIN_AFFECT_CONFIG","file":"libvirt-domain","value":"2","type":"virDomainModificationImpact","info":"Affect persistent domain state.  1 << 2 is reserved for virTypedParameterFlags"}},{"$":{"name":"VIR_DOMAIN_AFFECT_CURRENT","file":"libvirt-domain","value":"0","type":"virDomainModificationImpact","info":"Affect current domain state."}},{"$":{"name":"VIR_DOMAIN_AFFECT_LIVE","file":"libvirt-domain","value":"1","type":"virDomainModificationImpact","info":"Affect running domain state."}},{"$":{"name":"VIR_DOMAIN_BLKIO_PARAM_BOOLEAN","file":"libvirt-domain","value":"VIR_TYPED_PARAM_BOOLEAN","type":"virBlkioParameterType"}},{"$":{"name":"VIR_DOMAIN_BLKIO_PARAM_DOUBLE","file":"libvirt-domain","value":"VIR_TYPED_PARAM_DOUBLE","type":"virBlkioParameterType"}},{"$":{"name":"VIR_DOMAIN_BLKIO_PARAM_INT","file":"libvirt-domain","value":"VIR_TYPED_PARAM_INT","type":"virBlkioParameterType"}},{"$":{"name":"VIR_DOMAIN_BLKIO_PARAM_LLONG","file":"libvirt-domain","value":"VIR_TYPED_PARAM_LLONG","type":"virBlkioParameterType"}},{"$":{"name":"VIR_DOMAIN_BLKIO_PARAM_UINT","file":"libvirt-domain","value":"VIR_TYPED_PARAM_UINT","type":"virBlkioParameterType"}},{"$":{"name":"VIR_DOMAIN_BLKIO_PARAM_ULLONG","file":"libvirt-domain","value":"VIR_TYPED_PARAM_ULLONG","type":"virBlkioParameterType"}},{"$":{"name":"VIR_DOMAIN_BLOCKED","file":"libvirt-domain","value":"2","type":"virDomainState","info":"the domain is blocked on resource"}},{"$":{"name":"VIR_DOMAIN_BLOCKED_LAST","file":"libvirt-domain","value":"1","type":"virDomainBlockedReason"}},{"$":{"name":"VIR_DOMAIN_BLOCKED_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainBlockedReason","info":"the reason is unknown"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COMMIT_ACTIVE","file":"libvirt-domain","value":"4","type":"virDomainBlockCommitFlags","info":"Allow a two-phase commit when\ntop is the active layer"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES","file":"libvirt-domain","value":"16","type":"virDomainBlockCommitFlags","info":"bandwidth in bytes/s\ninstead of MiB/s"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COMMIT_DELETE","file":"libvirt-domain","value":"2","type":"virDomainBlockCommitFlags","info":"Delete any files that are now\ninvalid after their contents\nhave been committed"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COMMIT_RELATIVE","file":"libvirt-domain","value":"8","type":"virDomainBlockCommitFlags","info":"keep the backing chain\nreferenced using relative\nnames"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COMMIT_SHALLOW","file":"libvirt-domain","value":"1","type":"virDomainBlockCommitFlags","info":"NULL base means next backing\nfile, not whole chain"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COPY_REUSE_EXT","file":"libvirt-domain","value":"2","type":"virDomainBlockCopyFlags","info":"Reuse existing external\nfile for a copy"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COPY_SHALLOW","file":"libvirt-domain","value":"1","type":"virDomainBlockCopyFlags","info":"Limit copy to top of source\nbacking chain"}},{"$":{"name":"VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB","file":"libvirt-domain","value":"4","type":"virDomainBlockCopyFlags","info":"Don't force usage of\nrecoverable job for the\ncopy operation"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC","file":"libvirt-domain","value":"1","type":"virDomainBlockJobAbortFlags"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT","file":"libvirt-domain","value":"2","type":"virDomainBlockJobAbortFlags"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_CANCELED","file":"libvirt-domain","value":"2","type":"virConnectDomainEventBlockJobStatus"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_COMPLETED","file":"libvirt-domain","value":"0","type":"virConnectDomainEventBlockJobStatus"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_FAILED","file":"libvirt-domain","value":"1","type":"virConnectDomainEventBlockJobStatus"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES","file":"libvirt-domain","value":"1","type":"virDomainBlockJobInfoFlags","info":"bandwidth in bytes/s\ninstead of MiB/s"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_LAST","file":"libvirt-domain","value":"4","type":"virConnectDomainEventBlockJobStatus"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_READY","file":"libvirt-domain","value":"3","type":"virConnectDomainEventBlockJobStatus"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES","file":"libvirt-domain","value":"1","type":"virDomainBlockJobSetSpeedFlags","info":"bandwidth in bytes/s\ninstead of MiB/s"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT","file":"libvirt-domain","value":"4","type":"virDomainBlockJobType"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT","file":"libvirt-domain","value":"3","type":"virDomainBlockJobType","info":"Active Block Commit (virDomainBlockCommit with flags), job\n exists as long as sync is active"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_TYPE_COPY","file":"libvirt-domain","value":"2","type":"virDomainBlockJobType","info":"Block Commit (virDomainBlockCommit without flags), job ends on\n completion"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_TYPE_LAST","file":"libvirt-domain","value":"5","type":"virDomainBlockJobType"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_TYPE_PULL","file":"libvirt-domain","value":"1","type":"virDomainBlockJobType","info":"Block Copy (virDomainBlockCopy, or virDomainBlockRebase with\n flags), job exists as long as mirroring is active"}},{"$":{"name":"VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainBlockJobType","info":"Placeholder Block Pull (virDomainBlockPull, or virDomainBlockRebase without\n flags), job ends on completion"}},{"$":{"name":"VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES","file":"libvirt-domain","value":"64","type":"virDomainBlockPullFlags","info":"bandwidth in bytes/s\ninstead of MiB/s"}},{"$":{"name":"VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES","file":"libvirt-domain","value":"64","type":"virDomainBlockRebaseFlags","info":"bandwidth in bytes/s\ninstead of MiB/s"}},{"$":{"name":"VIR_DOMAIN_BLOCK_REBASE_COPY","file":"libvirt-domain","value":"8","type":"virDomainBlockRebaseFlags","info":"Start a copy job"}},{"$":{"name":"VIR_DOMAIN_BLOCK_REBASE_COPY_DEV","file":"libvirt-domain","value":"32","type":"virDomainBlockRebaseFlags","info":"Treat destination as block\ndevice instead of file"}},{"$":{"name":"VIR_DOMAIN_BLOCK_REBASE_COPY_RAW","file":"libvirt-domain","value":"4","type":"virDomainBlockRebaseFlags","info":"Make destination file raw"}},{"$":{"name":"VIR_DOMAIN_BLOCK_REBASE_RELATIVE","file":"libvirt-domain","value":"16","type":"virDomainBlockRebaseFlags","info":"Keep backing chain\nreferenced using relative\nnames"}},{"$":{"name":"VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT","file":"libvirt-domain","value":"2","type":"virDomainBlockRebaseFlags","info":"Reuse existing external\nfile for a copy"}},{"$":{"name":"VIR_DOMAIN_BLOCK_REBASE_SHALLOW","file":"libvirt-domain","value":"1","type":"virDomainBlockRebaseFlags","info":"Limit copy to top of source\nbacking chain"}},{"$":{"name":"VIR_DOMAIN_BLOCK_RESIZE_BYTES","file":"libvirt-domain","value":"1","type":"virDomainBlockResizeFlags","info":"size in bytes instead of KiB"}},{"$":{"name":"VIR_DOMAIN_CHANNEL_FORCE","file":"libvirt-domain","value":"1","type":"virDomainChannelFlags","info":"abort a (possibly) active channel\nconnection to force a new\nconnection"}},{"$":{"name":"VIR_DOMAIN_CONSOLE_FORCE","file":"libvirt-domain","value":"1","type":"virDomainConsoleFlags","info":"abort a (possibly) active console\nconnection to force a new\nconnection"}},{"$":{"name":"VIR_DOMAIN_CONSOLE_SAFE","file":"libvirt-domain","value":"2","type":"virDomainConsoleFlags","info":"check if the console driver supports\nsafe console operations"}},{"$":{"name":"VIR_DOMAIN_CONTROL_ERROR","file":"libvirt-domain","value":"3","type":"virDomainControlState","info":"unusable, domain cannot be fully\noperated, possible reason is provided\nin the details field"}},{"$":{"name":"VIR_DOMAIN_CONTROL_ERROR_REASON_INTERNAL","file":"libvirt-domain","value":"3","type":"virDomainControlErrorReason","info":"error caused due to\ninternal failure in libvirt"}},{"$":{"name":"VIR_DOMAIN_CONTROL_ERROR_REASON_LAST","file":"libvirt-domain","value":"4","type":"virDomainControlErrorReason"}},{"$":{"name":"VIR_DOMAIN_CONTROL_ERROR_REASON_MONITOR","file":"libvirt-domain","value":"2","type":"virDomainControlErrorReason","info":"monitor connection is\nbroken"}},{"$":{"name":"VIR_DOMAIN_CONTROL_ERROR_REASON_NONE","file":"libvirt-domain","value":"0","type":"virDomainControlErrorReason","info":"server didn't provide a\nreason"}},{"$":{"name":"VIR_DOMAIN_CONTROL_ERROR_REASON_UNKNOWN","file":"libvirt-domain","value":"1","type":"virDomainControlErrorReason","info":"unknown reason for the\nerror"}},{"$":{"name":"VIR_DOMAIN_CONTROL_JOB","file":"libvirt-domain","value":"1","type":"virDomainControlState","info":"background job is running (can be\nmonitored by virDomainGetJobInfo); only\nlimited set of commands may be allowed"}},{"$":{"name":"VIR_DOMAIN_CONTROL_LAST","file":"libvirt-domain","value":"4","type":"virDomainControlState"}},{"$":{"name":"VIR_DOMAIN_CONTROL_OCCUPIED","file":"libvirt-domain","value":"2","type":"virDomainControlState","info":"occupied by a running command"}},{"$":{"name":"VIR_DOMAIN_CONTROL_OK","file":"libvirt-domain","value":"0","type":"virDomainControlState","info":"operational, ready to accept commands"}},{"$":{"name":"VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_LZO","file":"libvirt-domain","value":"2","type":"virDomainCoreDumpFormat","info":"kdump-compressed format, with\n lzo compression"}},{"$":{"name":"VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_SNAPPY","file":"libvirt-domain","value":"3","type":"virDomainCoreDumpFormat","info":"kdump-compressed format, with\n snappy compression"}},{"$":{"name":"VIR_DOMAIN_CORE_DUMP_FORMAT_KDUMP_ZLIB","file":"libvirt-domain","value":"1","type":"virDomainCoreDumpFormat","info":"kdump-compressed format, with\n zlib compression"}},{"$":{"name":"VIR_DOMAIN_CORE_DUMP_FORMAT_LAST","file":"libvirt-domain","value":"4","type":"virDomainCoreDumpFormat","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last state supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_DOMAIN_CORE_DUMP_FORMAT_RAW","file":"libvirt-domain","value":"0","type":"virDomainCoreDumpFormat","info":"dump guest memory in raw format"}},{"$":{"name":"VIR_DOMAIN_CRASHED","file":"libvirt-domain","value":"6","type":"virDomainState","info":"the domain is crashed"}},{"$":{"name":"VIR_DOMAIN_CRASHED_LAST","file":"libvirt-domain","value":"2","type":"virDomainCrashedReason"}},{"$":{"name":"VIR_DOMAIN_CRASHED_PANICKED","file":"libvirt-domain","value":"1","type":"virDomainCrashedReason","info":"domain panicked"}},{"$":{"name":"VIR_DOMAIN_CRASHED_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainCrashedReason","info":"crashed for unknown reason"}},{"$":{"name":"VIR_DOMAIN_DEFINE_VALIDATE","file":"libvirt-domain","value":"1","type":"virDomainDefineFlags","info":"Validate the XML document against schema"}},{"$":{"name":"VIR_DOMAIN_DESTROY_DEFAULT","file":"libvirt-domain","value":"0","type":"virDomainDestroyFlagsValues","info":"Default behavior - could lead to data loss!!"}},{"$":{"name":"VIR_DOMAIN_DESTROY_GRACEFUL","file":"libvirt-domain","value":"1","type":"virDomainDestroyFlagsValues","info":"only SIGTERM, no SIGKILL"}},{"$":{"name":"VIR_DOMAIN_DEVICE_MODIFY_CONFIG","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_CONFIG","type":"virDomainDeviceModifyFlags"}},{"$":{"name":"VIR_DOMAIN_DEVICE_MODIFY_CURRENT","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_CURRENT","type":"virDomainDeviceModifyFlags","info":"See virDomainModificationImpact for these flags."}},{"$":{"name":"VIR_DOMAIN_DEVICE_MODIFY_FORCE","file":"libvirt-domain","value":"4","type":"virDomainDeviceModifyFlags","info":"Additionally, these flags may be bitwise-OR'd in."}},{"$":{"name":"VIR_DOMAIN_DEVICE_MODIFY_LIVE","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_LIVE","type":"virDomainDeviceModifyFlags"}},{"$":{"name":"VIR_DOMAIN_DISK_ERROR_LAST","file":"libvirt-domain","value":"3","type":"virDomainDiskErrorCode"}},{"$":{"name":"VIR_DOMAIN_DISK_ERROR_NONE","file":"libvirt-domain","value":"0","type":"virDomainDiskErrorCode","info":"no error"}},{"$":{"name":"VIR_DOMAIN_DISK_ERROR_NO_SPACE","file":"libvirt-domain","value":"2","type":"virDomainDiskErrorCode","info":"no space left on the device"}},{"$":{"name":"VIR_DOMAIN_DISK_ERROR_UNSPEC","file":"libvirt-domain","value":"1","type":"virDomainDiskErrorCode","info":"unspecified I/O error"}},{"$":{"name":"VIR_DOMAIN_EVENT_CRASHED","file":"libvirt-domain","value":"8","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_CRASHED_LAST","file":"libvirt-domain","value":"1","type":"virDomainEventCrashedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_CRASHED_PANICKED","file":"libvirt-domain","value":"0","type":"virDomainEventCrashedDetailType","info":"Guest was panicked"}},{"$":{"name":"VIR_DOMAIN_EVENT_DEFINED","file":"libvirt-domain","value":"0","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_DEFINED_ADDED","file":"libvirt-domain","value":"0","type":"virDomainEventDefinedDetailType","info":"Newly created config file"}},{"$":{"name":"VIR_DOMAIN_EVENT_DEFINED_FROM_SNAPSHOT","file":"libvirt-domain","value":"3","type":"virDomainEventDefinedDetailType","info":"Config was restored from a snapshot"}},{"$":{"name":"VIR_DOMAIN_EVENT_DEFINED_LAST","file":"libvirt-domain","value":"4","type":"virDomainEventDefinedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_DEFINED_RENAMED","file":"libvirt-domain","value":"2","type":"virDomainEventDefinedDetailType","info":"Domain was renamed"}},{"$":{"name":"VIR_DOMAIN_EVENT_DEFINED_UPDATED","file":"libvirt-domain","value":"1","type":"virDomainEventDefinedDetailType","info":"Changed config file"}},{"$":{"name":"VIR_DOMAIN_EVENT_DISK_CHANGE_LAST","file":"libvirt-domain","value":"2","type":"virConnectDomainEventDiskChangeReason"}},{"$":{"name":"VIR_DOMAIN_EVENT_DISK_CHANGE_MISSING_ON_START","file":"libvirt-domain","value":"0","type":"virConnectDomainEventDiskChangeReason","info":"Removable media changed to empty according to startup policy as source\n was missing. oldSrcPath is set, newSrcPath is NULL"}},{"$":{"name":"VIR_DOMAIN_EVENT_DISK_DROP_MISSING_ON_START","file":"libvirt-domain","value":"1","type":"virConnectDomainEventDiskChangeReason","info":"Disk was dropped from domain as source file was missing.\n oldSrcPath is set, newSrcPath is NULL"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV4","file":"libvirt-domain","value":"0","type":"virDomainEventGraphicsAddressType","info":"IPv4 address"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_IPV6","file":"libvirt-domain","value":"1","type":"virDomainEventGraphicsAddressType","info":"IPv6 address"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_LAST","file":"libvirt-domain","value":"3","type":"virDomainEventGraphicsAddressType"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_ADDRESS_UNIX","file":"libvirt-domain","value":"2","type":"virDomainEventGraphicsAddressType","info":"UNIX socket path"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_CONNECT","file":"libvirt-domain","value":"0","type":"virDomainEventGraphicsPhase","info":"Initial socket connection established"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_DISCONNECT","file":"libvirt-domain","value":"2","type":"virDomainEventGraphicsPhase","info":"Final socket disconnection"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_INITIALIZE","file":"libvirt-domain","value":"1","type":"virDomainEventGraphicsPhase","info":"Authentication & setup completed"}},{"$":{"name":"VIR_DOMAIN_EVENT_GRAPHICS_LAST","file":"libvirt-domain","value":"3","type":"virDomainEventGraphicsPhase"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE","file":"libvirt-domain","value":"18","type":"virDomainEventID","info":"virConnectDomainEventAgentLifecycleCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_BALLOON_CHANGE","file":"libvirt-domain","value":"13","type":"virDomainEventID","info":"virConnectDomainEventBalloonChangeCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_BLOCK_JOB","file":"libvirt-domain","value":"8","type":"virDomainEventID","info":"virConnectDomainEventBlockJobCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2","file":"libvirt-domain","value":"16","type":"virDomainEventID","info":"virConnectDomainEventBlockJobCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD","file":"libvirt-domain","value":"24","type":"virDomainEventID","info":"virConnectDomainEventBlockThresholdCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_CONTROL_ERROR","file":"libvirt-domain","value":"7","type":"virDomainEventID","info":"virConnectDomainEventGenericCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_DEVICE_ADDED","file":"libvirt-domain","value":"19","type":"virDomainEventID","info":"virConnectDomainEventDeviceAddedCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED","file":"libvirt-domain","value":"22","type":"virDomainEventID","info":"virConnectDomainEventDeviceRemovalFailedCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED","file":"libvirt-domain","value":"15","type":"virDomainEventID","info":"virConnectDomainEventDeviceRemovedCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_DISK_CHANGE","file":"libvirt-domain","value":"9","type":"virDomainEventID","info":"virConnectDomainEventDiskChangeCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_GRAPHICS","file":"libvirt-domain","value":"5","type":"virDomainEventID","info":"virConnectDomainEventGraphicsCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_IO_ERROR","file":"libvirt-domain","value":"4","type":"virDomainEventID","info":"virConnectDomainEventIOErrorCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_IO_ERROR_REASON","file":"libvirt-domain","value":"6","type":"virDomainEventID","info":"virConnectDomainEventIOErrorReasonCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_JOB_COMPLETED","file":"libvirt-domain","value":"21","type":"virDomainEventID","info":"virConnectDomainEventJobCompletedCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_LAST","file":"libvirt-domain","value":"25","type":"virDomainEventID","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last event ID supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_LIFECYCLE","file":"libvirt-domain","value":"0","type":"virDomainEventID","info":"virConnectDomainEventCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_METADATA_CHANGE","file":"libvirt-domain","value":"23","type":"virDomainEventID","info":"virConnectDomainEventMetadataChangeCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION","file":"libvirt-domain","value":"20","type":"virDomainEventID","info":"virConnectDomainEventMigrationIterationCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_PMSUSPEND","file":"libvirt-domain","value":"12","type":"virDomainEventID","info":"virConnectDomainEventPMSuspendCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK","file":"libvirt-domain","value":"14","type":"virDomainEventID","info":"virConnectDomainEventPMSuspendDiskCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_PMWAKEUP","file":"libvirt-domain","value":"11","type":"virDomainEventID","info":"virConnectDomainEventPMWakeupCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_REBOOT","file":"libvirt-domain","value":"1","type":"virDomainEventID","info":"virConnectDomainEventGenericCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_RTC_CHANGE","file":"libvirt-domain","value":"2","type":"virDomainEventID","info":"virConnectDomainEventRTCChangeCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_TRAY_CHANGE","file":"libvirt-domain","value":"10","type":"virDomainEventID","info":"virConnectDomainEventTrayChangeCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_TUNABLE","file":"libvirt-domain","value":"17","type":"virDomainEventID","info":"virConnectDomainEventTunableCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_ID_WATCHDOG","file":"libvirt-domain","value":"3","type":"virDomainEventID","info":"virConnectDomainEventWatchdogCallback"}},{"$":{"name":"VIR_DOMAIN_EVENT_IO_ERROR_LAST","file":"libvirt-domain","value":"3","type":"virDomainEventIOErrorAction"}},{"$":{"name":"VIR_DOMAIN_EVENT_IO_ERROR_NONE","file":"libvirt-domain","value":"0","type":"virDomainEventIOErrorAction","info":"No action, IO error ignored"}},{"$":{"name":"VIR_DOMAIN_EVENT_IO_ERROR_PAUSE","file":"libvirt-domain","value":"1","type":"virDomainEventIOErrorAction","info":"Guest CPUs are paused"}},{"$":{"name":"VIR_DOMAIN_EVENT_IO_ERROR_REPORT","file":"libvirt-domain","value":"2","type":"virDomainEventIOErrorAction","info":"IO error reported to guest OS"}},{"$":{"name":"VIR_DOMAIN_EVENT_LAST","file":"libvirt-domain","value":"9","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_PMSUSPENDED","file":"libvirt-domain","value":"7","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_PMSUSPENDED_DISK","file":"libvirt-domain","value":"1","type":"virDomainEventPMSuspendedDetailType","info":"Guest was PM suspended to disk"}},{"$":{"name":"VIR_DOMAIN_EVENT_PMSUSPENDED_LAST","file":"libvirt-domain","value":"2","type":"virDomainEventPMSuspendedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY","file":"libvirt-domain","value":"0","type":"virDomainEventPMSuspendedDetailType","info":"Guest was PM suspended to memory"}},{"$":{"name":"VIR_DOMAIN_EVENT_RESUMED","file":"libvirt-domain","value":"4","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_RESUMED_FROM_SNAPSHOT","file":"libvirt-domain","value":"2","type":"virDomainEventResumedDetailType","info":"Resumed from snapshot"}},{"$":{"name":"VIR_DOMAIN_EVENT_RESUMED_LAST","file":"libvirt-domain","value":"4","type":"virDomainEventResumedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_RESUMED_MIGRATED","file":"libvirt-domain","value":"1","type":"virDomainEventResumedDetailType","info":"Resumed for completion of migration"}},{"$":{"name":"VIR_DOMAIN_EVENT_RESUMED_POSTCOPY","file":"libvirt-domain","value":"3","type":"virDomainEventResumedDetailType","info":"Resumed, but migration is still\nrunning in post-copy mode"}},{"$":{"name":"VIR_DOMAIN_EVENT_RESUMED_UNPAUSED","file":"libvirt-domain","value":"0","type":"virDomainEventResumedDetailType","info":"Normal resume due to admin unpause"}},{"$":{"name":"VIR_DOMAIN_EVENT_SHUTDOWN","file":"libvirt-domain","value":"6","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED","file":"libvirt-domain","value":"0","type":"virDomainEventShutdownDetailType","info":"Guest finished shutdown sequence"}},{"$":{"name":"VIR_DOMAIN_EVENT_SHUTDOWN_GUEST","file":"libvirt-domain","value":"1","type":"virDomainEventShutdownDetailType","info":"Domain finished shutting down after request from the guest itself\n (e.g. hardware-specific action)"}},{"$":{"name":"VIR_DOMAIN_EVENT_SHUTDOWN_HOST","file":"libvirt-domain","value":"2","type":"virDomainEventShutdownDetailType","info":"Domain finished shutting down after request from the host (e.g. killed by\n a signal)"}},{"$":{"name":"VIR_DOMAIN_EVENT_SHUTDOWN_LAST","file":"libvirt-domain","value":"3","type":"virDomainEventShutdownDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_STARTED","file":"libvirt-domain","value":"2","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_STARTED_BOOTED","file":"libvirt-domain","value":"0","type":"virDomainEventStartedDetailType","info":"Normal startup from boot"}},{"$":{"name":"VIR_DOMAIN_EVENT_STARTED_FROM_SNAPSHOT","file":"libvirt-domain","value":"3","type":"virDomainEventStartedDetailType","info":"Restored from snapshot"}},{"$":{"name":"VIR_DOMAIN_EVENT_STARTED_LAST","file":"libvirt-domain","value":"5","type":"virDomainEventStartedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_STARTED_MIGRATED","file":"libvirt-domain","value":"1","type":"virDomainEventStartedDetailType","info":"Incoming migration from another host"}},{"$":{"name":"VIR_DOMAIN_EVENT_STARTED_RESTORED","file":"libvirt-domain","value":"2","type":"virDomainEventStartedDetailType","info":"Restored from a state file"}},{"$":{"name":"VIR_DOMAIN_EVENT_STARTED_WAKEUP","file":"libvirt-domain","value":"4","type":"virDomainEventStartedDetailType","info":"Started due to wakeup event"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED","file":"libvirt-domain","value":"5","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_CRASHED","file":"libvirt-domain","value":"2","type":"virDomainEventStoppedDetailType","info":"Guest crashed"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_DESTROYED","file":"libvirt-domain","value":"1","type":"virDomainEventStoppedDetailType","info":"Forced poweroff from host"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_FAILED","file":"libvirt-domain","value":"5","type":"virDomainEventStoppedDetailType","info":"Host emulator/mgmt failed"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_FROM_SNAPSHOT","file":"libvirt-domain","value":"6","type":"virDomainEventStoppedDetailType","info":"offline snapshot loaded"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_LAST","file":"libvirt-domain","value":"7","type":"virDomainEventStoppedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_MIGRATED","file":"libvirt-domain","value":"3","type":"virDomainEventStoppedDetailType","info":"Migrated off to another host"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_SAVED","file":"libvirt-domain","value":"4","type":"virDomainEventStoppedDetailType","info":"Saved to a state file"}},{"$":{"name":"VIR_DOMAIN_EVENT_STOPPED_SHUTDOWN","file":"libvirt-domain","value":"0","type":"virDomainEventStoppedDetailType","info":"Normal shutdown"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED","file":"libvirt-domain","value":"3","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_API_ERROR","file":"libvirt-domain","value":"6","type":"virDomainEventSuspendedDetailType","info":"suspended after failure during libvirt API call"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_FROM_SNAPSHOT","file":"libvirt-domain","value":"5","type":"virDomainEventSuspendedDetailType","info":"Restored from paused snapshot"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_IOERROR","file":"libvirt-domain","value":"2","type":"virDomainEventSuspendedDetailType","info":"Suspended due to a disk I/O error"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_LAST","file":"libvirt-domain","value":"9","type":"virDomainEventSuspendedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED","file":"libvirt-domain","value":"1","type":"virDomainEventSuspendedDetailType","info":"Suspended for offline migration"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_PAUSED","file":"libvirt-domain","value":"0","type":"virDomainEventSuspendedDetailType","info":"Normal suspend due to admin pause"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY","file":"libvirt-domain","value":"7","type":"virDomainEventSuspendedDetailType","info":"suspended for post-copy migration"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED","file":"libvirt-domain","value":"8","type":"virDomainEventSuspendedDetailType","info":"suspended after failed post-copy"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_RESTORED","file":"libvirt-domain","value":"4","type":"virDomainEventSuspendedDetailType","info":"Restored from paused state file"}},{"$":{"name":"VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG","file":"libvirt-domain","value":"3","type":"virDomainEventSuspendedDetailType","info":"Suspended due to a watchdog firing"}},{"$":{"name":"VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE","file":"libvirt-domain","value":"1","type":"virDomainEventTrayChangeReason"}},{"$":{"name":"VIR_DOMAIN_EVENT_TRAY_CHANGE_LAST","file":"libvirt-domain","value":"2","type":"virDomainEventTrayChangeReason"}},{"$":{"name":"VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN","file":"libvirt-domain","value":"0","type":"virDomainEventTrayChangeReason"}},{"$":{"name":"VIR_DOMAIN_EVENT_UNDEFINED","file":"libvirt-domain","value":"1","type":"virDomainEventType"}},{"$":{"name":"VIR_DOMAIN_EVENT_UNDEFINED_LAST","file":"libvirt-domain","value":"2","type":"virDomainEventUndefinedDetailType"}},{"$":{"name":"VIR_DOMAIN_EVENT_UNDEFINED_REMOVED","file":"libvirt-domain","value":"0","type":"virDomainEventUndefinedDetailType","info":"Deleted the config file"}},{"$":{"name":"VIR_DOMAIN_EVENT_UNDEFINED_RENAMED","file":"libvirt-domain","value":"1","type":"virDomainEventUndefinedDetailType","info":"Domain was renamed"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_DEBUG","file":"libvirt-domain","value":"5","type":"virDomainEventWatchdogAction","info":"No action, a debug message logged"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_INJECTNMI","file":"libvirt-domain","value":"6","type":"virDomainEventWatchdogAction","info":"Inject a non-maskable interrupt into guest"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_LAST","file":"libvirt-domain","value":"7","type":"virDomainEventWatchdogAction"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_NONE","file":"libvirt-domain","value":"0","type":"virDomainEventWatchdogAction","info":"No action, watchdog ignored"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_PAUSE","file":"libvirt-domain","value":"1","type":"virDomainEventWatchdogAction","info":"Guest CPUs are paused"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_POWEROFF","file":"libvirt-domain","value":"3","type":"virDomainEventWatchdogAction","info":"Guest is forcibly powered off"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_RESET","file":"libvirt-domain","value":"2","type":"virDomainEventWatchdogAction","info":"Guest CPUs are reset"}},{"$":{"name":"VIR_DOMAIN_EVENT_WATCHDOG_SHUTDOWN","file":"libvirt-domain","value":"4","type":"virDomainEventWatchdogAction","info":"Guest is requested to gracefully shutdown"}},{"$":{"name":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT","file":"libvirt-domain","value":"1","type":"virDomainInterfaceAddressesSource","info":"Query qemu guest agent"}},{"$":{"name":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP","file":"libvirt-domain","value":"2","type":"virDomainInterfaceAddressesSource","info":"Query ARP tables"}},{"$":{"name":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LAST","file":"libvirt-domain","value":"3","type":"virDomainInterfaceAddressesSource"}},{"$":{"name":"VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE","file":"libvirt-domain","value":"0","type":"virDomainInterfaceAddressesSource","info":"Parse DHCP lease file"}},{"$":{"name":"VIR_DOMAIN_JOB_BOUNDED","file":"libvirt-domain","value":"1","type":"virDomainJobType","info":"Job with a finite completion time"}},{"$":{"name":"VIR_DOMAIN_JOB_CANCELLED","file":"libvirt-domain","value":"5","type":"virDomainJobType","info":"Job was aborted, but isn't cleaned up"}},{"$":{"name":"VIR_DOMAIN_JOB_COMPLETED","file":"libvirt-domain","value":"3","type":"virDomainJobType","info":"Job has finished, but isn't cleaned up"}},{"$":{"name":"VIR_DOMAIN_JOB_FAILED","file":"libvirt-domain","value":"4","type":"virDomainJobType","info":"Job hit error, but isn't cleaned up"}},{"$":{"name":"VIR_DOMAIN_JOB_LAST","file":"libvirt-domain","value":"6","type":"virDomainJobType"}},{"$":{"name":"VIR_DOMAIN_JOB_NONE","file":"libvirt-domain","value":"0","type":"virDomainJobType","info":"No job is active"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_DUMP","file":"libvirt-domain","value":"8","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_LAST","file":"libvirt-domain","value":"9","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN","file":"libvirt-domain","value":"4","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT","file":"libvirt-domain","value":"5","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_RESTORE","file":"libvirt-domain","value":"3","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_SAVE","file":"libvirt-domain","value":"2","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_SNAPSHOT","file":"libvirt-domain","value":"6","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_SNAPSHOT_REVERT","file":"libvirt-domain","value":"7","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_START","file":"libvirt-domain","value":"1","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_OPERATION_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainJobOperation"}},{"$":{"name":"VIR_DOMAIN_JOB_STATS_COMPLETED","file":"libvirt-domain","value":"1","type":"virDomainGetJobStatsFlags","info":"return stats of a recently\n completed job"}},{"$":{"name":"VIR_DOMAIN_JOB_UNBOUNDED","file":"libvirt-domain","value":"2","type":"virDomainJobType","info":"Job without a finite completion time"}},{"$":{"name":"VIR_DOMAIN_LAST","file":"libvirt-domain","value":"8","type":"virDomainState","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last state supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY","file":"libvirt-domain","value":"4","type":"virDomainLifecycleAction"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_RESTART","file":"libvirt-domain","value":"5","type":"virDomainLifecycleAction"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY","file":"libvirt-domain","value":"0","type":"virDomainLifecycleAction"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_ACTION_LAST","file":"libvirt-domain","value":"6","type":"virDomainLifecycleAction"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE","file":"libvirt-domain","value":"3","type":"virDomainLifecycleAction"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_ACTION_RESTART","file":"libvirt-domain","value":"1","type":"virDomainLifecycleAction"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_ACTION_RESTART_RENAME","file":"libvirt-domain","value":"2","type":"virDomainLifecycleAction"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_CRASH","file":"libvirt-domain","value":"2","type":"virDomainLifecycle"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_LAST","file":"libvirt-domain","value":"3","type":"virDomainLifecycle"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_POWEROFF","file":"libvirt-domain","value":"0","type":"virDomainLifecycle"}},{"$":{"name":"VIR_DOMAIN_LIFECYCLE_REBOOT","file":"libvirt-domain","value":"1","type":"virDomainLifecycle"}},{"$":{"name":"VIR_DOMAIN_MEMORY_PARAM_BOOLEAN","file":"libvirt-domain","value":"VIR_TYPED_PARAM_BOOLEAN","type":"virMemoryParameterType"}},{"$":{"name":"VIR_DOMAIN_MEMORY_PARAM_DOUBLE","file":"libvirt-domain","value":"VIR_TYPED_PARAM_DOUBLE","type":"virMemoryParameterType"}},{"$":{"name":"VIR_DOMAIN_MEMORY_PARAM_INT","file":"libvirt-domain","value":"VIR_TYPED_PARAM_INT","type":"virMemoryParameterType"}},{"$":{"name":"VIR_DOMAIN_MEMORY_PARAM_LLONG","file":"libvirt-domain","value":"VIR_TYPED_PARAM_LLONG","type":"virMemoryParameterType"}},{"$":{"name":"VIR_DOMAIN_MEMORY_PARAM_UINT","file":"libvirt-domain","value":"VIR_TYPED_PARAM_UINT","type":"virMemoryParameterType"}},{"$":{"name":"VIR_DOMAIN_MEMORY_PARAM_ULLONG","file":"libvirt-domain","value":"VIR_TYPED_PARAM_ULLONG","type":"virMemoryParameterType"}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON","file":"libvirt-domain","value":"6","type":"virDomainMemoryStatTags","info":"Current balloon value (in KB)."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_AVAILABLE","file":"libvirt-domain","value":"5","type":"virDomainMemoryStatTags","info":"The total amount of usable memory as seen by the domain.  This value\n may be less than the amount of memory assigned to the domain if a\n balloon driver is in use or if the guest OS does not initialize all\n assigned pages.  This value is expressed in kB."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_LAST","file":"libvirt-domain","value":"VIR_DOMAIN_MEMORY_STAT_NR","type":"virDomainMemoryStatTags"}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_LAST_UPDATE","file":"libvirt-domain","value":"9","type":"virDomainMemoryStatTags","info":"Timestamp of the last update of statistics, in seconds."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT","file":"libvirt-domain","value":"2","type":"virDomainMemoryStatTags","info":"Page faults occur when a process makes a valid access to virtual memory\n that is not available.  When servicing the page fault, if disk IO is\n required, it is considered a major fault.  If not, it is a minor fault.\n These are expressed as the number of faults that have occurred."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT","file":"libvirt-domain","value":"3","type":"virDomainMemoryStatTags"}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_NR","file":"libvirt-domain","value":"10","type":"virDomainMemoryStatTags","info":"The number of statistics supported by this version of the interface.\n To add new statistics, add them to the enum and increase this value."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_RSS","file":"libvirt-domain","value":"7","type":"virDomainMemoryStatTags","info":"Resident Set Size of the process running the domain. This value\n is in kB"}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_SWAP_IN","file":"libvirt-domain","value":"0","type":"virDomainMemoryStatTags","info":"The total amount of data read from swap space (in kB)."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_SWAP_OUT","file":"libvirt-domain","value":"1","type":"virDomainMemoryStatTags","info":"The total amount of memory written out to swap space (in kB)."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_UNUSED","file":"libvirt-domain","value":"4","type":"virDomainMemoryStatTags","info":"The amount of memory left completely unused by the system.  Memory that\n is available but used for reclaimable caches should NOT be reported as\n free.  This value is expressed in kB."}},{"$":{"name":"VIR_DOMAIN_MEMORY_STAT_USABLE","file":"libvirt-domain","value":"8","type":"virDomainMemoryStatTags","info":"How much the balloon can be inflated without pushing the guest system\n to swap, corresponds to 'Available' in /proc/meminfo"}},{"$":{"name":"VIR_DOMAIN_MEM_CONFIG","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_CONFIG","type":"virDomainMemoryModFlags"}},{"$":{"name":"VIR_DOMAIN_MEM_CURRENT","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_CURRENT","type":"virDomainMemoryModFlags","info":"See virDomainModificationImpact for these flags."}},{"$":{"name":"VIR_DOMAIN_MEM_LIVE","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_LIVE","type":"virDomainMemoryModFlags"}},{"$":{"name":"VIR_DOMAIN_MEM_MAXIMUM","file":"libvirt-domain","value":"4","type":"virDomainMemoryModFlags","info":"Additionally, these flags may be bitwise-OR'd in."}},{"$":{"name":"VIR_DOMAIN_METADATA_DESCRIPTION","file":"libvirt-domain","value":"0","type":"virDomainMetadataType","info":"Operate on <description>"}},{"$":{"name":"VIR_DOMAIN_METADATA_ELEMENT","file":"libvirt-domain","value":"2","type":"virDomainMetadataType","info":"Operate on <metadata>"}},{"$":{"name":"VIR_DOMAIN_METADATA_LAST","file":"libvirt-domain","value":"3","type":"virDomainMetadataType"}},{"$":{"name":"VIR_DOMAIN_METADATA_TITLE","file":"libvirt-domain","value":"1","type":"virDomainMetadataType","info":"Operate on <title>"}},{"$":{"name":"VIR_DOMAIN_NONE","file":"libvirt-domain","value":"0","type":"virDomainCreateFlags","info":"Default behavior"}},{"$":{"name":"VIR_DOMAIN_NOSTATE","file":"libvirt-domain","value":"0","type":"virDomainState","info":"no state"}},{"$":{"name":"VIR_DOMAIN_NOSTATE_LAST","file":"libvirt-domain","value":"1","type":"virDomainNostateReason"}},{"$":{"name":"VIR_DOMAIN_NOSTATE_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainNostateReason"}},{"$":{"name":"VIR_DOMAIN_NUMATUNE_MEM_INTERLEAVE","file":"libvirt-domain","value":"2","type":"virDomainNumatuneMemMode"}},{"$":{"name":"VIR_DOMAIN_NUMATUNE_MEM_LAST","file":"libvirt-domain","value":"3","type":"virDomainNumatuneMemMode","info":"This constant is subject to change"}},{"$":{"name":"VIR_DOMAIN_NUMATUNE_MEM_PREFERRED","file":"libvirt-domain","value":"1","type":"virDomainNumatuneMemMode"}},{"$":{"name":"VIR_DOMAIN_NUMATUNE_MEM_STRICT","file":"libvirt-domain","value":"0","type":"virDomainNumatuneMemMode"}},{"$":{"name":"VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH","file":"libvirt-domain","value":"1","type":"virDomainOpenGraphicsFlags"}},{"$":{"name":"VIR_DOMAIN_PASSWORD_ENCRYPTED","file":"libvirt-domain","value":"1","type":"virDomainSetUserPasswordFlags","info":"the password is already encrypted"}},{"$":{"name":"VIR_DOMAIN_PAUSED","file":"libvirt-domain","value":"3","type":"virDomainState","info":"the domain is paused by user"}},{"$":{"name":"VIR_DOMAIN_PAUSED_CRASHED","file":"libvirt-domain","value":"10","type":"virDomainPausedReason","info":"paused due to a guest crash"}},{"$":{"name":"VIR_DOMAIN_PAUSED_DUMP","file":"libvirt-domain","value":"4","type":"virDomainPausedReason","info":"paused for offline core dump"}},{"$":{"name":"VIR_DOMAIN_PAUSED_FROM_SNAPSHOT","file":"libvirt-domain","value":"7","type":"virDomainPausedReason","info":"paused after restoring from snapshot"}},{"$":{"name":"VIR_DOMAIN_PAUSED_IOERROR","file":"libvirt-domain","value":"5","type":"virDomainPausedReason","info":"paused due to a disk I/O error"}},{"$":{"name":"VIR_DOMAIN_PAUSED_LAST","file":"libvirt-domain","value":"14","type":"virDomainPausedReason"}},{"$":{"name":"VIR_DOMAIN_PAUSED_MIGRATION","file":"libvirt-domain","value":"2","type":"virDomainPausedReason","info":"paused for offline migration"}},{"$":{"name":"VIR_DOMAIN_PAUSED_POSTCOPY","file":"libvirt-domain","value":"12","type":"virDomainPausedReason","info":"paused for post-copy migration"}},{"$":{"name":"VIR_DOMAIN_PAUSED_POSTCOPY_FAILED","file":"libvirt-domain","value":"13","type":"virDomainPausedReason","info":"paused after failed post-copy"}},{"$":{"name":"VIR_DOMAIN_PAUSED_SAVE","file":"libvirt-domain","value":"3","type":"virDomainPausedReason","info":"paused for save"}},{"$":{"name":"VIR_DOMAIN_PAUSED_SHUTTING_DOWN","file":"libvirt-domain","value":"8","type":"virDomainPausedReason","info":"paused during shutdown process"}},{"$":{"name":"VIR_DOMAIN_PAUSED_SNAPSHOT","file":"libvirt-domain","value":"9","type":"virDomainPausedReason","info":"paused while creating a snapshot"}},{"$":{"name":"VIR_DOMAIN_PAUSED_STARTING_UP","file":"libvirt-domain","value":"11","type":"virDomainPausedReason","info":"the domain is being started"}},{"$":{"name":"VIR_DOMAIN_PAUSED_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainPausedReason","info":"the reason is unknown"}},{"$":{"name":"VIR_DOMAIN_PAUSED_USER","file":"libvirt-domain","value":"1","type":"virDomainPausedReason","info":"paused on user request"}},{"$":{"name":"VIR_DOMAIN_PAUSED_WATCHDOG","file":"libvirt-domain","value":"6","type":"virDomainPausedReason","info":"paused due to a watchdog event"}},{"$":{"name":"VIR_DOMAIN_PMSUSPENDED","file":"libvirt-domain","value":"7","type":"virDomainState","info":"the domain is suspended by guest\npower management"}},{"$":{"name":"VIR_DOMAIN_PMSUSPENDED_DISK_LAST","file":"libvirt-domain","value":"1","type":"virDomainPMSuspendedDiskReason"}},{"$":{"name":"VIR_DOMAIN_PMSUSPENDED_DISK_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainPMSuspendedDiskReason"}},{"$":{"name":"VIR_DOMAIN_PMSUSPENDED_LAST","file":"libvirt-domain","value":"1","type":"virDomainPMSuspendedReason"}},{"$":{"name":"VIR_DOMAIN_PMSUSPENDED_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainPMSuspendedReason"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_ABRT","file":"libvirt-domain","value":"6","type":"virDomainProcessSignal","info":"SIGABRT"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_ALRM","file":"libvirt-domain","value":"14","type":"virDomainProcessSignal","info":"SIGALRM"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_BUS","file":"libvirt-domain","value":"7","type":"virDomainProcessSignal","info":"SIGBUS"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_CHLD","file":"libvirt-domain","value":"17","type":"virDomainProcessSignal","info":"SIGCHLD"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_CONT","file":"libvirt-domain","value":"18","type":"virDomainProcessSignal","info":"SIGCONT"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_FPE","file":"libvirt-domain","value":"8","type":"virDomainProcessSignal","info":"SIGFPE"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_HUP","file":"libvirt-domain","value":"1","type":"virDomainProcessSignal","info":"SIGHUP"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_ILL","file":"libvirt-domain","value":"4","type":"virDomainProcessSignal","info":"SIGILL"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_INT","file":"libvirt-domain","value":"2","type":"virDomainProcessSignal","info":"SIGINT"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_KILL","file":"libvirt-domain","value":"9","type":"virDomainProcessSignal","info":"SIGKILL"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_LAST","file":"libvirt-domain","value":"65","type":"virDomainProcessSignal"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_NOP","file":"libvirt-domain","value":"0","type":"virDomainProcessSignal","info":"No constant in POSIX/Linux"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_PIPE","file":"libvirt-domain","value":"13","type":"virDomainProcessSignal","info":"SIGPIPE"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_POLL","file":"libvirt-domain","value":"29","type":"virDomainProcessSignal","info":"SIGPOLL (also known as SIGIO on Linux)"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_PROF","file":"libvirt-domain","value":"27","type":"virDomainProcessSignal","info":"SIGPROF"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_PWR","file":"libvirt-domain","value":"30","type":"virDomainProcessSignal","info":"Not in POSIX (SIGPWR on Linux)"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_QUIT","file":"libvirt-domain","value":"3","type":"virDomainProcessSignal","info":"SIGQUIT"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT0","file":"libvirt-domain","value":"32","type":"virDomainProcessSignal","info":"SIGRTMIN"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT1","file":"libvirt-domain","value":"33","type":"virDomainProcessSignal","info":"SIGRTMIN + 1"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT10","file":"libvirt-domain","value":"42","type":"virDomainProcessSignal","info":"SIGRTMIN + 10"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT11","file":"libvirt-domain","value":"43","type":"virDomainProcessSignal","info":"SIGRTMIN + 11"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT12","file":"libvirt-domain","value":"44","type":"virDomainProcessSignal","info":"SIGRTMIN + 12"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT13","file":"libvirt-domain","value":"45","type":"virDomainProcessSignal","info":"SIGRTMIN + 13"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT14","file":"libvirt-domain","value":"46","type":"virDomainProcessSignal","info":"SIGRTMIN + 14"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT15","file":"libvirt-domain","value":"47","type":"virDomainProcessSignal","info":"SIGRTMIN + 15"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT16","file":"libvirt-domain","value":"48","type":"virDomainProcessSignal","info":"SIGRTMIN + 16"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT17","file":"libvirt-domain","value":"49","type":"virDomainProcessSignal","info":"SIGRTMIN + 17"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT18","file":"libvirt-domain","value":"50","type":"virDomainProcessSignal","info":"SIGRTMIN + 18"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT19","file":"libvirt-domain","value":"51","type":"virDomainProcessSignal","info":"SIGRTMIN + 19"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT2","file":"libvirt-domain","value":"34","type":"virDomainProcessSignal","info":"SIGRTMIN + 2"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT20","file":"libvirt-domain","value":"52","type":"virDomainProcessSignal","info":"SIGRTMIN + 20"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT21","file":"libvirt-domain","value":"53","type":"virDomainProcessSignal","info":"SIGRTMIN + 21"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT22","file":"libvirt-domain","value":"54","type":"virDomainProcessSignal","info":"SIGRTMIN + 22"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT23","file":"libvirt-domain","value":"55","type":"virDomainProcessSignal","info":"SIGRTMIN + 23"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT24","file":"libvirt-domain","value":"56","type":"virDomainProcessSignal","info":"SIGRTMIN + 24"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT25","file":"libvirt-domain","value":"57","type":"virDomainProcessSignal","info":"SIGRTMIN + 25"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT26","file":"libvirt-domain","value":"58","type":"virDomainProcessSignal","info":"SIGRTMIN + 26"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT27","file":"libvirt-domain","value":"59","type":"virDomainProcessSignal","info":"SIGRTMIN + 27"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT28","file":"libvirt-domain","value":"60","type":"virDomainProcessSignal","info":"SIGRTMIN + 28"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT29","file":"libvirt-domain","value":"61","type":"virDomainProcessSignal","info":"SIGRTMIN + 29"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT3","file":"libvirt-domain","value":"35","type":"virDomainProcessSignal","info":"SIGRTMIN + 3"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT30","file":"libvirt-domain","value":"62","type":"virDomainProcessSignal","info":"SIGRTMIN + 30"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT31","file":"libvirt-domain","value":"63","type":"virDomainProcessSignal","info":"SIGRTMIN + 31"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT32","file":"libvirt-domain","value":"64","type":"virDomainProcessSignal","info":"SIGRTMIN + 32 / SIGRTMAX"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT4","file":"libvirt-domain","value":"36","type":"virDomainProcessSignal","info":"SIGRTMIN + 4"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT5","file":"libvirt-domain","value":"37","type":"virDomainProcessSignal","info":"SIGRTMIN + 5"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT6","file":"libvirt-domain","value":"38","type":"virDomainProcessSignal","info":"SIGRTMIN + 6"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT7","file":"libvirt-domain","value":"39","type":"virDomainProcessSignal","info":"SIGRTMIN + 7"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT8","file":"libvirt-domain","value":"40","type":"virDomainProcessSignal","info":"SIGRTMIN + 8"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_RT9","file":"libvirt-domain","value":"41","type":"virDomainProcessSignal","info":"SIGRTMIN + 9"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_SEGV","file":"libvirt-domain","value":"11","type":"virDomainProcessSignal","info":"SIGSEGV"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_STKFLT","file":"libvirt-domain","value":"16","type":"virDomainProcessSignal","info":"Not in POSIX (SIGSTKFLT on Linux"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_STOP","file":"libvirt-domain","value":"19","type":"virDomainProcessSignal","info":"SIGSTOP"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_SYS","file":"libvirt-domain","value":"31","type":"virDomainProcessSignal","info":"SIGSYS (also known as SIGUNUSED on Linux)"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_TERM","file":"libvirt-domain","value":"15","type":"virDomainProcessSignal","info":"SIGTERM"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_TRAP","file":"libvirt-domain","value":"5","type":"virDomainProcessSignal","info":"SIGTRAP"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_TSTP","file":"libvirt-domain","value":"20","type":"virDomainProcessSignal","info":"SIGTSTP"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_TTIN","file":"libvirt-domain","value":"21","type":"virDomainProcessSignal","info":"SIGTTIN"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_TTOU","file":"libvirt-domain","value":"22","type":"virDomainProcessSignal","info":"SIGTTOU"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_URG","file":"libvirt-domain","value":"23","type":"virDomainProcessSignal","info":"SIGURG"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_USR1","file":"libvirt-domain","value":"10","type":"virDomainProcessSignal","info":"SIGUSR1"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_USR2","file":"libvirt-domain","value":"12","type":"virDomainProcessSignal","info":"SIGUSR2"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_VTALRM","file":"libvirt-domain","value":"26","type":"virDomainProcessSignal","info":"SIGVTALRM"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_WINCH","file":"libvirt-domain","value":"28","type":"virDomainProcessSignal","info":"Not in POSIX (SIGWINCH on Linux)"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_XCPU","file":"libvirt-domain","value":"24","type":"virDomainProcessSignal","info":"SIGXCPU"}},{"$":{"name":"VIR_DOMAIN_PROCESS_SIGNAL_XFSZ","file":"libvirt-domain","value":"25","type":"virDomainProcessSignal","info":"SIGXFSZ"}},{"$":{"name":"VIR_DOMAIN_REBOOT_ACPI_POWER_BTN","file":"libvirt-domain","value":"1","type":"virDomainRebootFlagValues","info":"Send ACPI event"}},{"$":{"name":"VIR_DOMAIN_REBOOT_DEFAULT","file":"libvirt-domain","value":"0","type":"virDomainRebootFlagValues","info":"hypervisor choice"}},{"$":{"name":"VIR_DOMAIN_REBOOT_GUEST_AGENT","file":"libvirt-domain","value":"2","type":"virDomainRebootFlagValues","info":"Use guest agent"}},{"$":{"name":"VIR_DOMAIN_REBOOT_INITCTL","file":"libvirt-domain","value":"4","type":"virDomainRebootFlagValues","info":"Use initctl"}},{"$":{"name":"VIR_DOMAIN_REBOOT_PARAVIRT","file":"libvirt-domain","value":"16","type":"virDomainRebootFlagValues","info":"Use paravirt guest control"}},{"$":{"name":"VIR_DOMAIN_REBOOT_SIGNAL","file":"libvirt-domain","value":"8","type":"virDomainRebootFlagValues","info":"Send a signal"}},{"$":{"name":"VIR_DOMAIN_RUNNING","file":"libvirt-domain","value":"1","type":"virDomainState","info":"the domain is running"}},{"$":{"name":"VIR_DOMAIN_RUNNING_BOOTED","file":"libvirt-domain","value":"1","type":"virDomainRunningReason","info":"normal startup from boot"}},{"$":{"name":"VIR_DOMAIN_RUNNING_CRASHED","file":"libvirt-domain","value":"9","type":"virDomainRunningReason","info":"resumed from crashed"}},{"$":{"name":"VIR_DOMAIN_RUNNING_FROM_SNAPSHOT","file":"libvirt-domain","value":"4","type":"virDomainRunningReason","info":"restored from snapshot"}},{"$":{"name":"VIR_DOMAIN_RUNNING_LAST","file":"libvirt-domain","value":"11","type":"virDomainRunningReason"}},{"$":{"name":"VIR_DOMAIN_RUNNING_MIGRATED","file":"libvirt-domain","value":"2","type":"virDomainRunningReason","info":"migrated from another host"}},{"$":{"name":"VIR_DOMAIN_RUNNING_MIGRATION_CANCELED","file":"libvirt-domain","value":"6","type":"virDomainRunningReason","info":"returned from migration"}},{"$":{"name":"VIR_DOMAIN_RUNNING_POSTCOPY","file":"libvirt-domain","value":"10","type":"virDomainRunningReason","info":"running in post-copy migration mode"}},{"$":{"name":"VIR_DOMAIN_RUNNING_RESTORED","file":"libvirt-domain","value":"3","type":"virDomainRunningReason","info":"restored from a state file"}},{"$":{"name":"VIR_DOMAIN_RUNNING_SAVE_CANCELED","file":"libvirt-domain","value":"7","type":"virDomainRunningReason","info":"returned from failed save process"}},{"$":{"name":"VIR_DOMAIN_RUNNING_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainRunningReason"}},{"$":{"name":"VIR_DOMAIN_RUNNING_UNPAUSED","file":"libvirt-domain","value":"5","type":"virDomainRunningReason","info":"returned from paused state"}},{"$":{"name":"VIR_DOMAIN_RUNNING_WAKEUP","file":"libvirt-domain","value":"8","type":"virDomainRunningReason","info":"returned from pmsuspended due to\nwakeup event"}},{"$":{"name":"VIR_DOMAIN_SAVE_BYPASS_CACHE","file":"libvirt-domain","value":"1","type":"virDomainSaveRestoreFlags","info":"Avoid file system cache pollution"}},{"$":{"name":"VIR_DOMAIN_SAVE_PAUSED","file":"libvirt-domain","value":"4","type":"virDomainSaveRestoreFlags","info":"Favor paused over running"}},{"$":{"name":"VIR_DOMAIN_SAVE_RUNNING","file":"libvirt-domain","value":"2","type":"virDomainSaveRestoreFlags","info":"Favor running over paused"}},{"$":{"name":"VIR_DOMAIN_SCHED_FIELD_BOOLEAN","file":"libvirt-domain","value":"VIR_TYPED_PARAM_BOOLEAN","type":"virSchedParameterType"}},{"$":{"name":"VIR_DOMAIN_SCHED_FIELD_DOUBLE","file":"libvirt-domain","value":"VIR_TYPED_PARAM_DOUBLE","type":"virSchedParameterType"}},{"$":{"name":"VIR_DOMAIN_SCHED_FIELD_INT","file":"libvirt-domain","value":"VIR_TYPED_PARAM_INT","type":"virSchedParameterType"}},{"$":{"name":"VIR_DOMAIN_SCHED_FIELD_LLONG","file":"libvirt-domain","value":"VIR_TYPED_PARAM_LLONG","type":"virSchedParameterType"}},{"$":{"name":"VIR_DOMAIN_SCHED_FIELD_UINT","file":"libvirt-domain","value":"VIR_TYPED_PARAM_UINT","type":"virSchedParameterType"}},{"$":{"name":"VIR_DOMAIN_SCHED_FIELD_ULLONG","file":"libvirt-domain","value":"VIR_TYPED_PARAM_ULLONG","type":"virSchedParameterType"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN","file":"libvirt-domain","value":"4","type":"virDomainState","info":"the domain is being shut down"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_ACPI_POWER_BTN","file":"libvirt-domain","value":"1","type":"virDomainShutdownFlagValues","info":"Send ACPI event"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_DEFAULT","file":"libvirt-domain","value":"0","type":"virDomainShutdownFlagValues","info":"hypervisor choice"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_GUEST_AGENT","file":"libvirt-domain","value":"2","type":"virDomainShutdownFlagValues","info":"Use guest agent"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_INITCTL","file":"libvirt-domain","value":"4","type":"virDomainShutdownFlagValues","info":"Use initctl"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_LAST","file":"libvirt-domain","value":"2","type":"virDomainShutdownReason"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_PARAVIRT","file":"libvirt-domain","value":"16","type":"virDomainShutdownFlagValues","info":"Use paravirt guest control"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_SIGNAL","file":"libvirt-domain","value":"8","type":"virDomainShutdownFlagValues","info":"Send a signal"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainShutdownReason","info":"the reason is unknown"}},{"$":{"name":"VIR_DOMAIN_SHUTDOWN_USER","file":"libvirt-domain","value":"1","type":"virDomainShutdownReason","info":"shutting down on user request"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF","file":"libvirt-domain","value":"5","type":"virDomainState","info":"the domain is shut off"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_CRASHED","file":"libvirt-domain","value":"3","type":"virDomainShutoffReason","info":"domain crashed"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_DESTROYED","file":"libvirt-domain","value":"2","type":"virDomainShutoffReason","info":"forced poweroff"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_FAILED","file":"libvirt-domain","value":"6","type":"virDomainShutoffReason","info":"domain failed to start"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_FROM_SNAPSHOT","file":"libvirt-domain","value":"7","type":"virDomainShutoffReason","info":"restored from a snapshot which was\n taken while domain was shutoff"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_LAST","file":"libvirt-domain","value":"8","type":"virDomainShutoffReason"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_MIGRATED","file":"libvirt-domain","value":"4","type":"virDomainShutoffReason","info":"migrated to another host"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_SAVED","file":"libvirt-domain","value":"5","type":"virDomainShutoffReason","info":"saved to a file"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_SHUTDOWN","file":"libvirt-domain","value":"1","type":"virDomainShutoffReason","info":"normal shutdown"}},{"$":{"name":"VIR_DOMAIN_SHUTOFF_UNKNOWN","file":"libvirt-domain","value":"0","type":"virDomainShutoffReason","info":"the reason is unknown"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC","file":"libvirt-domain-snapshot","value":"128","type":"virDomainSnapshotCreateFlags","info":"atomically avoid\npartial changes"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT","file":"libvirt-domain-snapshot","value":"2","type":"virDomainSnapshotCreateFlags","info":"With redefine, make\nsnapshot current"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY","file":"libvirt-domain-snapshot","value":"16","type":"virDomainSnapshotCreateFlags","info":"disk snapshot, not\nsystem checkpoint"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_HALT","file":"libvirt-domain-snapshot","value":"8","type":"virDomainSnapshotCreateFlags","info":"Stop running guest\nafter snapshot"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_LIVE","file":"libvirt-domain-snapshot","value":"256","type":"virDomainSnapshotCreateFlags","info":"create the snapshot\nwhile the guest is\nrunning"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA","file":"libvirt-domain-snapshot","value":"4","type":"virDomainSnapshotCreateFlags","info":"Make snapshot without\nremembering it"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE","file":"libvirt-domain-snapshot","value":"64","type":"virDomainSnapshotCreateFlags","info":"use guest agent to\nquiesce all mounted\nfile systems within\nthe domain"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE","file":"libvirt-domain-snapshot","value":"1","type":"virDomainSnapshotCreateFlags","info":"Restore or alter\nmetadata"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT","file":"libvirt-domain-snapshot","value":"32","type":"virDomainSnapshotCreateFlags","info":"reuse any existing\nexternal files"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN","file":"libvirt-domain-snapshot","value":"1","type":"virDomainSnapshotDeleteFlags","info":"Also delete children"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY","file":"libvirt-domain-snapshot","value":"4","type":"virDomainSnapshotDeleteFlags","info":"Delete just children"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY","file":"libvirt-domain-snapshot","value":"2","type":"virDomainSnapshotDeleteFlags","info":"Delete just metadata"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_ACTIVE","file":"libvirt-domain-snapshot","value":"64","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\ntaken while guest was\nactive, and with\nmemory state"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS","file":"libvirt-domain-snapshot","value":"1","type":"virDomainSnapshotListFlags","info":"List all descendants,\nnot just children, when\nlisting a snapshot For historical reasons, groups do not use contiguous bits."}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY","file":"libvirt-domain-snapshot","value":"128","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\ntaken while guest was\nactive, but without\nmemory state"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL","file":"libvirt-domain-snapshot","value":"512","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\nthat use files external\nto disk images"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE","file":"libvirt-domain-snapshot","value":"32","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\ntaken while guest was\nshut off"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL","file":"libvirt-domain-snapshot","value":"256","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\nstored internal to\ndisk images"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_LEAVES","file":"libvirt-domain-snapshot","value":"4","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\nwith no children"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_METADATA","file":"libvirt-domain-snapshot","value":"2","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\nwhich have metadata"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES","file":"libvirt-domain-snapshot","value":"8","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\nthat have children"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA","file":"libvirt-domain-snapshot","value":"16","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\nwith no metadata"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_LIST_ROOTS","file":"libvirt-domain-snapshot","value":"1","type":"virDomainSnapshotListFlags","info":"Filter by snapshots\nwith no parents, when\nlisting a domain"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_REVERT_FORCE","file":"libvirt-domain-snapshot","value":"4","type":"virDomainSnapshotRevertFlags","info":"Allow risky reverts"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED","file":"libvirt-domain-snapshot","value":"2","type":"virDomainSnapshotRevertFlags","info":"Pause after revert"}},{"$":{"name":"VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING","file":"libvirt-domain-snapshot","value":"1","type":"virDomainSnapshotRevertFlags","info":"Run after revert"}},{"$":{"name":"VIR_DOMAIN_START_AUTODESTROY","file":"libvirt-domain","value":"2","type":"virDomainCreateFlags","info":"Automatically kill guest when virConnectPtr is closed"}},{"$":{"name":"VIR_DOMAIN_START_BYPASS_CACHE","file":"libvirt-domain","value":"4","type":"virDomainCreateFlags","info":"Avoid file system cache pollution"}},{"$":{"name":"VIR_DOMAIN_START_FORCE_BOOT","file":"libvirt-domain","value":"8","type":"virDomainCreateFlags","info":"Boot, discarding any managed save"}},{"$":{"name":"VIR_DOMAIN_START_PAUSED","file":"libvirt-domain","value":"1","type":"virDomainCreateFlags","info":"Launch guest in paused state"}},{"$":{"name":"VIR_DOMAIN_START_VALIDATE","file":"libvirt-domain","value":"16","type":"virDomainCreateFlags","info":"Validate the XML document against schema"}},{"$":{"name":"VIR_DOMAIN_STATS_BALLOON","file":"libvirt-domain","value":"4","type":"virDomainStatsTypes","info":"return domain balloon info"}},{"$":{"name":"VIR_DOMAIN_STATS_BLOCK","file":"libvirt-domain","value":"32","type":"virDomainStatsTypes","info":"return domain block info"}},{"$":{"name":"VIR_DOMAIN_STATS_CPU_TOTAL","file":"libvirt-domain","value":"2","type":"virDomainStatsTypes","info":"return domain CPU info"}},{"$":{"name":"VIR_DOMAIN_STATS_INTERFACE","file":"libvirt-domain","value":"16","type":"virDomainStatsTypes","info":"return domain interfaces info"}},{"$":{"name":"VIR_DOMAIN_STATS_PERF","file":"libvirt-domain","value":"64","type":"virDomainStatsTypes","info":"return domain perf event info"}},{"$":{"name":"VIR_DOMAIN_STATS_STATE","file":"libvirt-domain","value":"1","type":"virDomainStatsTypes","info":"return domain state"}},{"$":{"name":"VIR_DOMAIN_STATS_VCPU","file":"libvirt-domain","value":"8","type":"virDomainStatsTypes","info":"return domain virtual CPU info"}},{"$":{"name":"VIR_DOMAIN_TIME_SYNC","file":"libvirt-domain","value":"1","type":"virDomainSetTimeFlags","info":"Re-sync domain time from domain's RTC"}},{"$":{"name":"VIR_DOMAIN_UNDEFINE_KEEP_NVRAM","file":"libvirt-domain","value":"8","type":"virDomainUndefineFlagsValues","info":"Keep nvram file Future undefine control flags should come here."}},{"$":{"name":"VIR_DOMAIN_UNDEFINE_MANAGED_SAVE","file":"libvirt-domain","value":"1","type":"virDomainUndefineFlagsValues","info":"Also remove any\nmanaged save"}},{"$":{"name":"VIR_DOMAIN_UNDEFINE_NVRAM","file":"libvirt-domain","value":"4","type":"virDomainUndefineFlagsValues","info":"Also remove any\nnvram file"}},{"$":{"name":"VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA","file":"libvirt-domain","value":"2","type":"virDomainUndefineFlagsValues","info":"If last use of domain,\nthen also remove any\nsnapshot metadata"}},{"$":{"name":"VIR_DOMAIN_VCPU_CONFIG","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_CONFIG","type":"virDomainVcpuFlags"}},{"$":{"name":"VIR_DOMAIN_VCPU_CURRENT","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_CURRENT","type":"virDomainVcpuFlags","info":"See virDomainModificationImpact for these flags."}},{"$":{"name":"VIR_DOMAIN_VCPU_GUEST","file":"libvirt-domain","value":"8","type":"virDomainVcpuFlags","info":"Max rather than current count"}},{"$":{"name":"VIR_DOMAIN_VCPU_HOTPLUGGABLE","file":"libvirt-domain","value":"16","type":"virDomainVcpuFlags","info":"Modify state of the cpu in the guest"}},{"$":{"name":"VIR_DOMAIN_VCPU_LIVE","file":"libvirt-domain","value":"VIR_DOMAIN_AFFECT_LIVE","type":"virDomainVcpuFlags"}},{"$":{"name":"VIR_DOMAIN_VCPU_MAXIMUM","file":"libvirt-domain","value":"4","type":"virDomainVcpuFlags","info":"Additionally, these flags may be bitwise-OR'd in."}},{"$":{"name":"VIR_DOMAIN_XML_INACTIVE","file":"libvirt-domain","value":"2","type":"virDomainXMLFlags","info":"dump inactive domain information"}},{"$":{"name":"VIR_DOMAIN_XML_MIGRATABLE","file":"libvirt-domain","value":"8","type":"virDomainXMLFlags","info":"dump XML suitable for migration"}},{"$":{"name":"VIR_DOMAIN_XML_SECURE","file":"libvirt-domain","value":"1","type":"virDomainXMLFlags","info":"dump security sensitive information too"}},{"$":{"name":"VIR_DOMAIN_XML_UPDATE_CPU","file":"libvirt-domain","value":"4","type":"virDomainXMLFlags","info":"update guest CPU requirements according to host CPU"}},{"$":{"name":"VIR_DUMP_BYPASS_CACHE","file":"libvirt-domain","value":"4","type":"virDomainCoreDumpFlags","info":"avoid file system cache pollution"}},{"$":{"name":"VIR_DUMP_CRASH","file":"libvirt-domain","value":"1","type":"virDomainCoreDumpFlags","info":"crash after dump"}},{"$":{"name":"VIR_DUMP_LIVE","file":"libvirt-domain","value":"2","type":"virDomainCoreDumpFlags","info":"live dump"}},{"$":{"name":"VIR_DUMP_MEMORY_ONLY","file":"libvirt-domain","value":"16","type":"virDomainCoreDumpFlags","info":"use dump-guest-memory"}},{"$":{"name":"VIR_DUMP_RESET","file":"libvirt-domain","value":"8","type":"virDomainCoreDumpFlags","info":"reset domain after dump finishes"}},{"$":{"name":"VIR_ERR_ACCESS_DENIED","file":"virterror","value":"88","type":"virErrorNumber","info":"operation on the object/resource\nwas denied"}},{"$":{"name":"VIR_ERR_AGENT_UNRESPONSIVE","file":"virterror","value":"86","type":"virErrorNumber","info":"guest agent is unresponsive,\nnot running or not usable"}},{"$":{"name":"VIR_ERR_AGENT_UNSYNCED","file":"virterror","value":"97","type":"virErrorNumber","info":"guest agent replies with wrong id\nto guest-sync command (DEPRECATED"}},{"$":{"name":"VIR_ERR_ARGUMENT_UNSUPPORTED","file":"virterror","value":"74","type":"virErrorNumber","info":"valid API use but unsupported by\nthe given driver"}},{"$":{"name":"VIR_ERR_AUTH_CANCELLED","file":"virterror","value":"79","type":"virErrorNumber","info":"authentication cancelled"}},{"$":{"name":"VIR_ERR_AUTH_FAILED","file":"virterror","value":"45","type":"virErrorNumber","info":"authentication failed"}},{"$":{"name":"VIR_ERR_AUTH_UNAVAILABLE","file":"virterror","value":"94","type":"virErrorNumber","info":"authentication unavailable"}},{"$":{"name":"VIR_ERR_BLOCK_COPY_ACTIVE","file":"virterror","value":"83","type":"virErrorNumber","info":"action prevented by block copy job"}},{"$":{"name":"VIR_ERR_BUILD_FIREWALL","file":"virterror","value":"63","type":"virErrorNumber","info":"nw filter pool not found"}},{"$":{"name":"VIR_ERR_CALL_FAILED","file":"virterror","value":"26","type":"virErrorNumber","info":"not supported by the drivers\n(DEPRECATED)"}},{"$":{"name":"VIR_ERR_CONFIG_UNSUPPORTED","file":"virterror","value":"67","type":"virErrorNumber","info":"unsupported configuration\nconstruct"}},{"$":{"name":"VIR_ERR_CONF_SYNTAX","file":"virterror","value":"33","type":"virErrorNumber","info":"failed to parse the syntax of a\nconf file"}},{"$":{"name":"VIR_ERR_CPU_INCOMPATIBLE","file":"virterror","value":"91","type":"virErrorNumber","info":"given CPU is incompatible with host\nCP"}},{"$":{"name":"VIR_ERR_DBUS_SERVICE","file":"virterror","value":"89","type":"virErrorNumber","info":"error from a dbus service"}},{"$":{"name":"VIR_ERR_DEVICE_MISSING","file":"virterror","value":"99","type":"virErrorNumber","info":"fail to find the desired device"}},{"$":{"name":"VIR_ERR_DOMAIN_LAST","file":"virterror","value":"68","type":"virErrorDomain"}},{"$":{"name":"VIR_ERR_DOM_EXIST","file":"virterror","value":"28","type":"virErrorNumber","info":"the domain already exist"}},{"$":{"name":"VIR_ERR_DRIVER_FULL","file":"virterror","value":"25","type":"virErrorNumber","info":"too many drivers registered"}},{"$":{"name":"VIR_ERR_ERROR","file":"virterror","value":"2","type":"virErrorLevel","info":"An error"}},{"$":{"name":"VIR_ERR_GET_FAILED","file":"virterror","value":"10","type":"virErrorNumber","info":"a HTTP GET command to failed"}},{"$":{"name":"VIR_ERR_GNUTLS_ERROR","file":"virterror","value":"40","type":"virErrorNumber","info":"error from a GNUTLS call"}},{"$":{"name":"VIR_ERR_HOOK_SCRIPT_FAILED","file":"virterror","value":"70","type":"virErrorNumber","info":"a synchronous hook script failed"}},{"$":{"name":"VIR_ERR_HTTP_ERROR","file":"virterror","value":"12","type":"virErrorNumber","info":"unexpected HTTP error code"}},{"$":{"name":"VIR_ERR_INTERNAL_ERROR","file":"virterror","value":"1","type":"virErrorNumber","info":"internal error"}},{"$":{"name":"VIR_ERR_INVALID_ARG","file":"virterror","value":"8","type":"virErrorNumber","info":"invalid function argument"}},{"$":{"name":"VIR_ERR_INVALID_CONN","file":"virterror","value":"6","type":"virErrorNumber","info":"invalid connection object"}},{"$":{"name":"VIR_ERR_INVALID_DOMAIN","file":"virterror","value":"7","type":"virErrorNumber","info":"invalid domain object"}},{"$":{"name":"VIR_ERR_INVALID_DOMAIN_SNAPSHOT","file":"virterror","value":"71","type":"virErrorNumber","info":"invalid domain snapshot"}},{"$":{"name":"VIR_ERR_INVALID_INTERFACE","file":"virterror","value":"58","type":"virErrorNumber","info":"invalid interface object"}},{"$":{"name":"VIR_ERR_INVALID_MAC","file":"virterror","value":"44","type":"virErrorNumber","info":"invalid MAC address"}},{"$":{"name":"VIR_ERR_INVALID_NETWORK","file":"virterror","value":"36","type":"virErrorNumber","info":"invalid network object"}},{"$":{"name":"VIR_ERR_INVALID_NODE_DEVICE","file":"virterror","value":"52","type":"virErrorNumber","info":"invalid node device object"}},{"$":{"name":"VIR_ERR_INVALID_NWFILTER","file":"virterror","value":"61","type":"virErrorNumber","info":"invalid nwfilter object"}},{"$":{"name":"VIR_ERR_INVALID_SECRET","file":"virterror","value":"65","type":"virErrorNumber","info":"invalid secret"}},{"$":{"name":"VIR_ERR_INVALID_STORAGE_POOL","file":"virterror","value":"46","type":"virErrorNumber","info":"invalid storage pool object"}},{"$":{"name":"VIR_ERR_INVALID_STORAGE_VOL","file":"virterror","value":"47","type":"virErrorNumber","info":"invalid storage vol object"}},{"$":{"name":"VIR_ERR_INVALID_STREAM","file":"virterror","value":"73","type":"virErrorNumber","info":"stream pointer not valid"}},{"$":{"name":"VIR_ERR_LIBSSH","file":"virterror","value":"98","type":"virErrorNumber","info":"error in libssh transport driver"}},{"$":{"name":"VIR_ERR_MIGRATE_FINISH_OK","file":"virterror","value":"93","type":"virErrorNumber","info":"Finish API succeeded but it is expected to return NULL"}},{"$":{"name":"VIR_ERR_MIGRATE_PERSIST_FAILED","file":"virterror","value":"69","type":"virErrorNumber","info":"a migration worked, but making the\nVM persist on the dest host failed"}},{"$":{"name":"VIR_ERR_MIGRATE_UNSAFE","file":"virterror","value":"81","type":"virErrorNumber","info":"Migration is not safe"}},{"$":{"name":"VIR_ERR_MULTIPLE_INTERFACES","file":"virterror","value":"59","type":"virErrorNumber","info":"more than one matching interface\nfound"}},{"$":{"name":"VIR_ERR_NETWORK_EXIST","file":"virterror","value":"37","type":"virErrorNumber","info":"the network already exist"}},{"$":{"name":"VIR_ERR_NONE","file":"virterror","value":"0","type":"virErrorLevel"}},{"$":{"name":"VIR_ERR_NO_CLIENT","file":"virterror","value":"96","type":"virErrorNumber","info":"Client was not found"}},{"$":{"name":"VIR_ERR_NO_CONNECT","file":"virterror","value":"5","type":"virErrorNumber","info":"can't connect to hypervisor"}},{"$":{"name":"VIR_ERR_NO_DEVICE","file":"virterror","value":"23","type":"virErrorNumber","info":"missing domain devices information"}},{"$":{"name":"VIR_ERR_NO_DOMAIN","file":"virterror","value":"42","type":"virErrorNumber","info":"domain not found or unexpectedly\ndisappeared"}},{"$":{"name":"VIR_ERR_NO_DOMAIN_METADATA","file":"virterror","value":"80","type":"virErrorNumber","info":"The metadata is not present"}},{"$":{"name":"VIR_ERR_NO_DOMAIN_SNAPSHOT","file":"virterror","value":"72","type":"virErrorNumber","info":"domain snapshot not found"}},{"$":{"name":"VIR_ERR_NO_INTERFACE","file":"virterror","value":"57","type":"virErrorNumber","info":"interface driver not running"}},{"$":{"name":"VIR_ERR_NO_KERNEL","file":"virterror","value":"17","type":"virErrorNumber","info":"missing kernel information"}},{"$":{"name":"VIR_ERR_NO_MEMORY","file":"virterror","value":"2","type":"virErrorNumber","info":"memory allocation failure"}},{"$":{"name":"VIR_ERR_NO_NAME","file":"virterror","value":"21","type":"virErrorNumber","info":"missing domain name information"}},{"$":{"name":"VIR_ERR_NO_NETWORK","file":"virterror","value":"43","type":"virErrorNumber","info":"network not found"}},{"$":{"name":"VIR_ERR_NO_NODE_DEVICE","file":"virterror","value":"53","type":"virErrorNumber","info":"node device not found"}},{"$":{"name":"VIR_ERR_NO_NWFILTER","file":"virterror","value":"62","type":"virErrorNumber","info":"nw filter pool not found"}},{"$":{"name":"VIR_ERR_NO_OS","file":"virterror","value":"22","type":"virErrorNumber","info":"missing domain OS information"}},{"$":{"name":"VIR_ERR_NO_ROOT","file":"virterror","value":"18","type":"virErrorNumber","info":"missing root device information"}},{"$":{"name":"VIR_ERR_NO_SECRET","file":"virterror","value":"66","type":"virErrorNumber","info":"secret not found"}},{"$":{"name":"VIR_ERR_NO_SECURITY_MODEL","file":"virterror","value":"54","type":"virErrorNumber","info":"security model not found"}},{"$":{"name":"VIR_ERR_NO_SERVER","file":"virterror","value":"95","type":"virErrorNumber","info":"Server was not found"}},{"$":{"name":"VIR_ERR_NO_SOURCE","file":"virterror","value":"19","type":"virErrorNumber","info":"missing source device information"}},{"$":{"name":"VIR_ERR_NO_STORAGE_POOL","file":"virterror","value":"49","type":"virErrorNumber","info":"storage pool not found"}},{"$":{"name":"VIR_ERR_NO_STORAGE_VOL","file":"virterror","value":"50","type":"virErrorNumber","info":"storage volume not found"}},{"$":{"name":"VIR_ERR_NO_SUPPORT","file":"virterror","value":"3","type":"virErrorNumber","info":"no support for this function"}},{"$":{"name":"VIR_ERR_NO_TARGET","file":"virterror","value":"20","type":"virErrorNumber","info":"missing target device information"}},{"$":{"name":"VIR_ERR_NO_XEN","file":"virterror","value":"14","type":"virErrorNumber","info":"could not open Xen hypervisor\ncontrol"}},{"$":{"name":"VIR_ERR_NO_XENSTORE","file":"virterror","value":"24","type":"virErrorNumber","info":"could not open Xen Store control"}},{"$":{"name":"VIR_ERR_OK","file":"virterror","value":"0","type":"virErrorNumber"}},{"$":{"name":"VIR_ERR_OPEN_FAILED","file":"virterror","value":"30","type":"virErrorNumber","info":"failed to open a conf file"}},{"$":{"name":"VIR_ERR_OPERATION_ABORTED","file":"virterror","value":"78","type":"virErrorNumber","info":"operation on a domain was\ncanceled/aborted by user"}},{"$":{"name":"VIR_ERR_OPERATION_DENIED","file":"virterror","value":"29","type":"virErrorNumber","info":"operation forbidden on read-only\nconnections"}},{"$":{"name":"VIR_ERR_OPERATION_FAILED","file":"virterror","value":"9","type":"virErrorNumber","info":"a command to hypervisor failed"}},{"$":{"name":"VIR_ERR_OPERATION_INVALID","file":"virterror","value":"55","type":"virErrorNumber","info":"operation is not applicable at this\ntime"}},{"$":{"name":"VIR_ERR_OPERATION_TIMEOUT","file":"virterror","value":"68","type":"virErrorNumber","info":"timeout occurred during operation"}},{"$":{"name":"VIR_ERR_OPERATION_UNSUPPORTED","file":"virterror","value":"84","type":"virErrorNumber","info":"The requested operation is not\nsupported"}},{"$":{"name":"VIR_ERR_OS_TYPE","file":"virterror","value":"16","type":"virErrorNumber","info":"unknown OS type"}},{"$":{"name":"VIR_ERR_OVERFLOW","file":"virterror","value":"82","type":"virErrorNumber","info":"integer overflow"}},{"$":{"name":"VIR_ERR_PARSE_FAILED","file":"virterror","value":"32","type":"virErrorNumber","info":"failed to parse a conf file"}},{"$":{"name":"VIR_ERR_POST_FAILED","file":"virterror","value":"11","type":"virErrorNumber","info":"a HTTP POST command to failed"}},{"$":{"name":"VIR_ERR_READ_FAILED","file":"virterror","value":"31","type":"virErrorNumber","info":"failed to read a conf file"}},{"$":{"name":"VIR_ERR_RESOURCE_BUSY","file":"virterror","value":"87","type":"virErrorNumber","info":"resource is already in use"}},{"$":{"name":"VIR_ERR_RPC","file":"virterror","value":"39","type":"virErrorNumber","info":"some sort of RPC error"}},{"$":{"name":"VIR_ERR_SEXPR_SERIAL","file":"virterror","value":"13","type":"virErrorNumber","info":"failure to serialize an S-Expr"}},{"$":{"name":"VIR_ERR_SNAPSHOT_REVERT_RISKY","file":"virterror","value":"77","type":"virErrorNumber","info":"force was not requested for a\nrisky domain snapshot revert"}},{"$":{"name":"VIR_ERR_SSH","file":"virterror","value":"85","type":"virErrorNumber","info":"error in ssh transport driver"}},{"$":{"name":"VIR_ERR_STORAGE_POOL_BUILT","file":"virterror","value":"76","type":"virErrorNumber","info":"storage pool already built"}},{"$":{"name":"VIR_ERR_STORAGE_PROBE_FAILED","file":"virterror","value":"75","type":"virErrorNumber","info":"storage pool probe failed"}},{"$":{"name":"VIR_ERR_STORAGE_VOL_EXIST","file":"virterror","value":"90","type":"virErrorNumber","info":"the storage vol already exists"}},{"$":{"name":"VIR_ERR_SYSTEM_ERROR","file":"virterror","value":"38","type":"virErrorNumber","info":"general system call failure"}},{"$":{"name":"VIR_ERR_UNKNOWN_HOST","file":"virterror","value":"4","type":"virErrorNumber","info":"could not resolve hostname"}},{"$":{"name":"VIR_ERR_WARNING","file":"virterror","value":"1","type":"virErrorLevel","info":"A simple warning"}},{"$":{"name":"VIR_ERR_WRITE_FAILED","file":"virterror","value":"34","type":"virErrorNumber","info":"failed to write a conf file"}},{"$":{"name":"VIR_ERR_XEN_CALL","file":"virterror","value":"15","type":"virErrorNumber","info":"failure doing an hypervisor call"}},{"$":{"name":"VIR_ERR_XML_DETAIL","file":"virterror","value":"35","type":"virErrorNumber","info":"detail of an XML error"}},{"$":{"name":"VIR_ERR_XML_ERROR","file":"virterror","value":"27","type":"virErrorNumber","info":"an XML description is not well\nformed or broken"}},{"$":{"name":"VIR_ERR_XML_INVALID_SCHEMA","file":"virterror","value":"92","type":"virErrorNumber","info":"XML document doesn't validate against schema"}},{"$":{"name":"VIR_EVENT_HANDLE_ERROR","file":"libvirt-event","value":"4","type":"virEventHandleType"}},{"$":{"name":"VIR_EVENT_HANDLE_HANGUP","file":"libvirt-event","value":"8","type":"virEventHandleType"}},{"$":{"name":"VIR_EVENT_HANDLE_READABLE","file":"libvirt-event","value":"1","type":"virEventHandleType"}},{"$":{"name":"VIR_EVENT_HANDLE_WRITABLE","file":"libvirt-event","value":"2","type":"virEventHandleType"}},{"$":{"name":"VIR_FROM_ACCESS","file":"virterror","value":"55","type":"virErrorDomain","info":"Error from access control manager"}},{"$":{"name":"VIR_FROM_ADMIN","file":"virterror","value":"62","type":"virErrorDomain","info":"Error from admin backend"}},{"$":{"name":"VIR_FROM_AUDIT","file":"virterror","value":"36","type":"virErrorDomain","info":"Error from auditing subsystem"}},{"$":{"name":"VIR_FROM_AUTH","file":"virterror","value":"46","type":"virErrorDomain","info":"Error from auth handling"}},{"$":{"name":"VIR_FROM_BHYVE","file":"virterror","value":"57","type":"virErrorDomain","info":"Error from bhyve driver"}},{"$":{"name":"VIR_FROM_CAPABILITIES","file":"virterror","value":"44","type":"virErrorDomain","info":"Error from capabilities"}},{"$":{"name":"VIR_FROM_CGROUP","file":"virterror","value":"54","type":"virErrorDomain","info":"Error from cgroups"}},{"$":{"name":"VIR_FROM_CONF","file":"virterror","value":"9","type":"virErrorDomain","info":"Error in the configuration file handling"}},{"$":{"name":"VIR_FROM_CPU","file":"virterror","value":"31","type":"virErrorDomain","info":"Error from CPU driver"}},{"$":{"name":"VIR_FROM_CRYPTO","file":"virterror","value":"58","type":"virErrorDomain","info":"Error from crypto code"}},{"$":{"name":"VIR_FROM_DBUS","file":"virterror","value":"47","type":"virErrorDomain","info":"Error from DBus"}},{"$":{"name":"VIR_FROM_DEVICE","file":"virterror","value":"49","type":"virErrorDomain","info":"Error from Device"}},{"$":{"name":"VIR_FROM_DOM","file":"virterror","value":"6","type":"virErrorDomain","info":"Error when operating on a domain"}},{"$":{"name":"VIR_FROM_DOMAIN","file":"virterror","value":"20","type":"virErrorDomain","info":"Error from domain config"}},{"$":{"name":"VIR_FROM_DOMAIN_SNAPSHOT","file":"virterror","value":"35","type":"virErrorDomain","info":"Error from domain snapshot"}},{"$":{"name":"VIR_FROM_ESX","file":"virterror","value":"28","type":"virErrorDomain","info":"Error from ESX driver"}},{"$":{"name":"VIR_FROM_EVENT","file":"virterror","value":"40","type":"virErrorDomain","info":"Error from event loop impl"}},{"$":{"name":"VIR_FROM_FIREWALL","file":"virterror","value":"59","type":"virErrorDomain","info":"Error from firewall"}},{"$":{"name":"VIR_FROM_HOOK","file":"virterror","value":"34","type":"virErrorDomain","info":"Error from Synchronous hooks"}},{"$":{"name":"VIR_FROM_HYPERV","file":"virterror","value":"43","type":"virErrorDomain","info":"Error from Hyper-V driver"}},{"$":{"name":"VIR_FROM_IDENTITY","file":"virterror","value":"53","type":"virErrorDomain","info":"Error from identity code"}},{"$":{"name":"VIR_FROM_INITCTL","file":"virterror","value":"52","type":"virErrorDomain","info":"Error from initctl device communication"}},{"$":{"name":"VIR_FROM_INTERFACE","file":"virterror","value":"26","type":"virErrorDomain","info":"Error when operating on an interface"}},{"$":{"name":"VIR_FROM_LIBSSH","file":"virterror","value":"66","type":"virErrorDomain","info":"Error from libssh connection transport"}},{"$":{"name":"VIR_FROM_LIBXL","file":"virterror","value":"41","type":"virErrorDomain","info":"Error from libxenlight driver"}},{"$":{"name":"VIR_FROM_LOCKING","file":"virterror","value":"42","type":"virErrorDomain","info":"Error from lock manager"}},{"$":{"name":"VIR_FROM_LOCKSPACE","file":"virterror","value":"51","type":"virErrorDomain","info":"Error from lockspace"}},{"$":{"name":"VIR_FROM_LOGGING","file":"virterror","value":"63","type":"virErrorDomain","info":"Error from log manager"}},{"$":{"name":"VIR_FROM_LXC","file":"virterror","value":"17","type":"virErrorDomain","info":"Error from Linux Container driver"}},{"$":{"name":"VIR_FROM_NET","file":"virterror","value":"11","type":"virErrorDomain","info":"Error when operating on a network"}},{"$":{"name":"VIR_FROM_NETWORK","file":"virterror","value":"19","type":"virErrorDomain","info":"Error from network config"}},{"$":{"name":"VIR_FROM_NODEDEV","file":"virterror","value":"22","type":"virErrorDomain","info":"Error from node device monitor"}},{"$":{"name":"VIR_FROM_NONE","file":"virterror","value":"0","type":"virErrorDomain"}},{"$":{"name":"VIR_FROM_NWFILTER","file":"virterror","value":"33","type":"virErrorDomain","info":"Error from network filter driver"}},{"$":{"name":"VIR_FROM_ONE","file":"virterror","value":"27","type":"virErrorDomain","info":"The OpenNebula driver no longer exists.\nRetained for ABI/API compat only"}},{"$":{"name":"VIR_FROM_OPENVZ","file":"virterror","value":"14","type":"virErrorDomain","info":"Error from OpenVZ driver"}},{"$":{"name":"VIR_FROM_PARALLELS","file":"virterror","value":"48","type":"virErrorDomain","info":"Error from Parallels"}},{"$":{"name":"VIR_FROM_PERF","file":"virterror","value":"65","type":"virErrorDomain","info":"Error from perf"}},{"$":{"name":"VIR_FROM_PHYP","file":"virterror","value":"29","type":"virErrorDomain","info":"Error from IBM power hypervisor"}},{"$":{"name":"VIR_FROM_POLKIT","file":"virterror","value":"60","type":"virErrorDomain","info":"Error from polkit code"}},{"$":{"name":"VIR_FROM_PROXY","file":"virterror","value":"8","type":"virErrorDomain","info":"Error in the proxy code; unused since\n0.8.6"}},{"$":{"name":"VIR_FROM_QEMU","file":"virterror","value":"10","type":"virErrorDomain","info":"Error at the QEMU daemon"}},{"$":{"name":"VIR_FROM_REMOTE","file":"virterror","value":"13","type":"virErrorDomain","info":"Error from remote driver"}},{"$":{"name":"VIR_FROM_RESCTRL","file":"virterror","value":"67","type":"virErrorDomain","info":"Error from resource control"}},{"$":{"name":"VIR_FROM_RPC","file":"virterror","value":"7","type":"virErrorDomain","info":"Error in the XML-RPC code"}},{"$":{"name":"VIR_FROM_SECRET","file":"virterror","value":"30","type":"virErrorDomain","info":"Error from secret storage"}},{"$":{"name":"VIR_FROM_SECURITY","file":"virterror","value":"24","type":"virErrorDomain","info":"Error from security framework"}},{"$":{"name":"VIR_FROM_SEXPR","file":"virterror","value":"4","type":"virErrorDomain","info":"Error in the S-Expression code"}},{"$":{"name":"VIR_FROM_SSH","file":"virterror","value":"50","type":"virErrorDomain","info":"Error from libssh2 connection transport"}},{"$":{"name":"VIR_FROM_STATS_LINUX","file":"virterror","value":"16","type":"virErrorDomain","info":"Error in the Linux Stats code"}},{"$":{"name":"VIR_FROM_STORAGE","file":"virterror","value":"18","type":"virErrorDomain","info":"Error from storage driver"}},{"$":{"name":"VIR_FROM_STREAMS","file":"virterror","value":"38","type":"virErrorDomain","info":"Error from I/O streams"}},{"$":{"name":"VIR_FROM_SYSINFO","file":"virterror","value":"37","type":"virErrorDomain","info":"Error from sysinfo/SMBIOS"}},{"$":{"name":"VIR_FROM_SYSTEMD","file":"virterror","value":"56","type":"virErrorDomain","info":"Error from systemd code"}},{"$":{"name":"VIR_FROM_TEST","file":"virterror","value":"12","type":"virErrorDomain","info":"Error from test driver"}},{"$":{"name":"VIR_FROM_THREAD","file":"virterror","value":"61","type":"virErrorDomain","info":"Error from thread utils"}},{"$":{"name":"VIR_FROM_UML","file":"virterror","value":"21","type":"virErrorDomain","info":"Error at the UML driver"}},{"$":{"name":"VIR_FROM_URI","file":"virterror","value":"45","type":"virErrorDomain","info":"Error from URI handling"}},{"$":{"name":"VIR_FROM_VBOX","file":"virterror","value":"25","type":"virErrorDomain","info":"Error from VirtualBox driver"}},{"$":{"name":"VIR_FROM_VMWARE","file":"virterror","value":"39","type":"virErrorDomain","info":"Error from VMware driver"}},{"$":{"name":"VIR_FROM_XEN","file":"virterror","value":"1","type":"virErrorDomain","info":"Error at Xen hypervisor layer"}},{"$":{"name":"VIR_FROM_XENAPI","file":"virterror","value":"32","type":"virErrorDomain","info":"Error from XenAPI"}},{"$":{"name":"VIR_FROM_XEND","file":"virterror","value":"2","type":"virErrorDomain","info":"Error at connection with xend daemon"}},{"$":{"name":"VIR_FROM_XENSTORE","file":"virterror","value":"3","type":"virErrorDomain","info":"Error at connection with xen store"}},{"$":{"name":"VIR_FROM_XENXL","file":"virterror","value":"64","type":"virErrorDomain","info":"Error from Xen xl config code"}},{"$":{"name":"VIR_FROM_XENXM","file":"virterror","value":"15","type":"virErrorDomain","info":"Error at Xen XM layer"}},{"$":{"name":"VIR_FROM_XEN_INOTIFY","file":"virterror","value":"23","type":"virErrorDomain","info":"Error from xen inotify layer"}},{"$":{"name":"VIR_FROM_XML","file":"virterror","value":"5","type":"virErrorDomain","info":"Error in the XML code"}},{"$":{"name":"VIR_INTERFACE_XML_INACTIVE","file":"libvirt-interface","value":"1","type":"virInterfaceXMLFlags","info":"dump inactive interface information"}},{"$":{"name":"VIR_IP_ADDR_TYPE_IPV4","file":"libvirt-network","value":"0","type":"virIPAddrType"}},{"$":{"name":"VIR_IP_ADDR_TYPE_IPV6","file":"libvirt-network","value":"1","type":"virIPAddrType"}},{"$":{"name":"VIR_IP_ADDR_TYPE_LAST","file":"libvirt-network","value":"2","type":"virIPAddrType"}},{"$":{"name":"VIR_KEYCODE_SET_ATSET1","file":"libvirt-domain","value":"2","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_ATSET2","file":"libvirt-domain","value":"3","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_ATSET3","file":"libvirt-domain","value":"4","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_LAST","file":"libvirt-domain","value":"10","type":"virKeycodeSet","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last keycode set supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_KEYCODE_SET_LINUX","file":"libvirt-domain","value":"0","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_OSX","file":"libvirt-domain","value":"5","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_QNUM","file":"libvirt-domain","value":"9","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_USB","file":"libvirt-domain","value":"7","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_WIN32","file":"libvirt-domain","value":"8","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_XT","file":"libvirt-domain","value":"1","type":"virKeycodeSet"}},{"$":{"name":"VIR_KEYCODE_SET_XT_KBD","file":"libvirt-domain","value":"6","type":"virKeycodeSet"}},{"$":{"name":"VIR_MEMORY_PHYSICAL","file":"libvirt-domain","value":"2","type":"virDomainMemoryFlags","info":"addresses are physical addresses"}},{"$":{"name":"VIR_MEMORY_VIRTUAL","file":"libvirt-domain","value":"1","type":"virDomainMemoryFlags","info":"addresses are virtual addresses"}},{"$":{"name":"VIR_MIGRATE_ABORT_ON_ERROR","file":"libvirt-domain","value":"4096","type":"virDomainMigrateFlags","info":"Cancel migration if a soft error (such as I/O error) happens during\n migration."}},{"$":{"name":"VIR_MIGRATE_AUTO_CONVERGE","file":"libvirt-domain","value":"8192","type":"virDomainMigrateFlags","info":"Enable algorithms that ensure a live migration will eventually converge.\n This usually means the domain will be slowed down to make sure it does\n not change its memory faster than a hypervisor can transfer the changed\n memory to the destination host. VIR_MIGRATE_PARAM_AUTO_CONVERGE_*\n parameters can be used to tune the algorithm."}},{"$":{"name":"VIR_MIGRATE_CHANGE_PROTECTION","file":"libvirt-domain","value":"256","type":"virDomainMigrateFlags","info":"Protect against domain configuration changes during the migration\n process. This flag is used automatically when both sides support it.\n Explicitly setting this flag will cause migration to fail if either the\n source or the destination does not support it."}},{"$":{"name":"VIR_MIGRATE_COMPRESSED","file":"libvirt-domain","value":"2048","type":"virDomainMigrateFlags","info":"Compress migration data. The compression methods can be specified using\n VIR_MIGRATE_PARAM_COMPRESSION. A hypervisor default method will be used\n if this parameter is omitted. Individual compression methods can be\n tuned via their specific VIR_MIGRATE_PARAM_COMPRESSION_* parameters."}},{"$":{"name":"VIR_MIGRATE_LIVE","file":"libvirt-domain","value":"1","type":"virDomainMigrateFlags","info":"Do not pause the domain during migration. The domain's memory will\n be transferred to the destination host while the domain is running.\n The migration may never converge if the domain is changing its memory\n faster then it can be transferred. The domain can be manually paused\n anytime during migration using virDomainSuspend."}},{"$":{"name":"VIR_MIGRATE_NON_SHARED_DISK","file":"libvirt-domain","value":"64","type":"virDomainMigrateFlags","info":"Migrate full disk images in addition to domain's memory. By default\n only non-shared non-readonly disk images are transferred. The\n VIR_MIGRATE_PARAM_MIGRATE_DISKS parameter can be used to specify which\n disks should be migrated.\n\n This flag and VIR_MIGRATE_NON_SHARED_INC are mutually exclusive."}},{"$":{"name":"VIR_MIGRATE_NON_SHARED_INC","file":"libvirt-domain","value":"128","type":"virDomainMigrateFlags","info":"Migrate disk images in addition to domain's memory. This is similar to\n VIR_MIGRATE_NON_SHARED_DISK, but only the top level of each disk's\n backing chain is copied. That is, the rest of the backing chain is\n expected to be present on the destination and to be exactly the same as\n on the source host.\n\n This flag and VIR_MIGRATE_NON_SHARED_DISK are mutually exclusive."}},{"$":{"name":"VIR_MIGRATE_OFFLINE","file":"libvirt-domain","value":"1024","type":"virDomainMigrateFlags","info":"Migrate a domain definition without starting the domain on the\n destination and without stopping it on the source host. Offline\n migration requires VIR_MIGRATE_PERSIST_DEST to be set.\n\n Offline migration may not copy disk storage or any other file based\n storage (such as UEFI variables)."}},{"$":{"name":"VIR_MIGRATE_PAUSED","file":"libvirt-domain","value":"32","type":"virDomainMigrateFlags","info":"Leave the domain suspended on the destination host. virDomainResume (on\n the virDomainPtr returned by the migration API) has to be called\n explicitly to resume domain's virtual CPUs."}},{"$":{"name":"VIR_MIGRATE_PEER2PEER","file":"libvirt-domain","value":"2","type":"virDomainMigrateFlags","info":"Tell the source libvirtd to connect directly to the destination host.\n Without this flag the client (e.g., virsh) connects to both hosts and\n controls the migration process. In peer-to-peer mode, the source\n libvirtd controls the migration by calling the destination daemon\n directly."}},{"$":{"name":"VIR_MIGRATE_PERSIST_DEST","file":"libvirt-domain","value":"8","type":"virDomainMigrateFlags","info":"Define the domain as persistent on the destination host after successful\n migration. If the domain was persistent on the source host and\n VIR_MIGRATE_UNDEFINE_SOURCE is not used, it will end up persistent on\n both hosts."}},{"$":{"name":"VIR_MIGRATE_POSTCOPY","file":"libvirt-domain","value":"32768","type":"virDomainMigrateFlags","info":"Setting the VIR_MIGRATE_POSTCOPY flag tells libvirt to enable post-copy\n migration. However, the migration will start normally and\n virDomainMigrateStartPostCopy needs to be called to switch it into the\n post-copy mode. See virDomainMigrateStartPostCopy for more details."}},{"$":{"name":"VIR_MIGRATE_RDMA_PIN_ALL","file":"libvirt-domain","value":"16384","type":"virDomainMigrateFlags","info":"This flag can be used with RDMA migration (i.e., when\n VIR_MIGRATE_PARAM_URI starts with \"rdma://\") to tell the hypervisor\n to pin all domain's memory at once before migration starts rather then\n letting it pin memory pages as needed. This means that all memory pages\n belonging to the domain will be locked in host's memory and the host\n will not be allowed to swap them out.\n\n For QEMU/KVM this requires hard_limit memory tuning element (in the\n domain XML) to be used and set to the maximum memory configured for the\n domain plus any memory consumed by the QEMU process itself. Beware of\n setting the memory limit too high (and thus allowing the domain to lock\n most of the host's memory). Doing so may be dangerous to both the\n domain and the host itself since the host's kernel may run out of\n memory."}},{"$":{"name":"VIR_MIGRATE_TLS","file":"libvirt-domain","value":"65536","type":"virDomainMigrateFlags","info":"Setting the VIR_MIGRATE_TLS flag will cause the migration to attempt\n to use the TLS environment configured by the hypervisor in order to\n perform the migration. If incorrectly configured on either source or\n destination, the migration will fail."}},{"$":{"name":"VIR_MIGRATE_TUNNELLED","file":"libvirt-domain","value":"4","type":"virDomainMigrateFlags","info":"Tunnel migration data over libvirtd connection. Without this flag the\n source hypervisor sends migration data directly to the destination\n hypervisor. This flag can only be used when VIR_MIGRATE_PEER2PEER is\n set as well.\n\n Note the less-common spelling that we're stuck with:\n VIR_MIGRATE_TUNNELLED should be VIR_MIGRATE_TUNNELED."}},{"$":{"name":"VIR_MIGRATE_UNDEFINE_SOURCE","file":"libvirt-domain","value":"16","type":"virDomainMigrateFlags","info":"Undefine the domain on the source host once migration successfully\n finishes."}},{"$":{"name":"VIR_MIGRATE_UNSAFE","file":"libvirt-domain","value":"512","type":"virDomainMigrateFlags","info":"Force migration even if it is considered unsafe. In some cases libvirt\n may refuse to migrate the domain because doing so may lead to potential\n problems such as data corruption, and thus the migration is considered\n unsafe. For a QEMU domain this may happen if the domain uses disks\n without explicitly setting cache mode to \"none\". Migrating such domains\n is unsafe unless the disk images are stored on coherent clustered\n filesystem, such as GFS2 or GPFS."}},{"$":{"name":"VIR_NETWORK_EVENT_DEFINED","file":"libvirt-network","value":"0","type":"virNetworkEventLifecycleType"}},{"$":{"name":"VIR_NETWORK_EVENT_ID_LAST","file":"libvirt-network","value":"1","type":"virNetworkEventID","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last event ID supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_NETWORK_EVENT_ID_LIFECYCLE","file":"libvirt-network","value":"0","type":"virNetworkEventID","info":"virConnectNetworkEventLifecycleCallback"}},{"$":{"name":"VIR_NETWORK_EVENT_LAST","file":"libvirt-network","value":"4","type":"virNetworkEventLifecycleType"}},{"$":{"name":"VIR_NETWORK_EVENT_STARTED","file":"libvirt-network","value":"2","type":"virNetworkEventLifecycleType"}},{"$":{"name":"VIR_NETWORK_EVENT_STOPPED","file":"libvirt-network","value":"3","type":"virNetworkEventLifecycleType"}},{"$":{"name":"VIR_NETWORK_EVENT_UNDEFINED","file":"libvirt-network","value":"1","type":"virNetworkEventLifecycleType"}},{"$":{"name":"VIR_NETWORK_SECTION_BRIDGE","file":"libvirt-network","value":"1","type":"virNetworkUpdateSection","info":"<bridge>"}},{"$":{"name":"VIR_NETWORK_SECTION_DNS_HOST","file":"libvirt-network","value":"10","type":"virNetworkUpdateSection","info":"<dns>/<host>"}},{"$":{"name":"VIR_NETWORK_SECTION_DNS_SRV","file":"libvirt-network","value":"12","type":"virNetworkUpdateSection","info":"<dns>/<srv>"}},{"$":{"name":"VIR_NETWORK_SECTION_DNS_TXT","file":"libvirt-network","value":"11","type":"virNetworkUpdateSection","info":"<dns>/<txt>"}},{"$":{"name":"VIR_NETWORK_SECTION_DOMAIN","file":"libvirt-network","value":"2","type":"virNetworkUpdateSection","info":"<domain>"}},{"$":{"name":"VIR_NETWORK_SECTION_FORWARD","file":"libvirt-network","value":"6","type":"virNetworkUpdateSection","info":"<forward>"}},{"$":{"name":"VIR_NETWORK_SECTION_FORWARD_INTERFACE","file":"libvirt-network","value":"7","type":"virNetworkUpdateSection","info":"<forward>/<interface>"}},{"$":{"name":"VIR_NETWORK_SECTION_FORWARD_PF","file":"libvirt-network","value":"8","type":"virNetworkUpdateSection","info":"<forward>/<pf>"}},{"$":{"name":"VIR_NETWORK_SECTION_IP","file":"libvirt-network","value":"3","type":"virNetworkUpdateSection","info":"<ip>"}},{"$":{"name":"VIR_NETWORK_SECTION_IP_DHCP_HOST","file":"libvirt-network","value":"4","type":"virNetworkUpdateSection","info":"<ip>/<dhcp>/<host>"}},{"$":{"name":"VIR_NETWORK_SECTION_IP_DHCP_RANGE","file":"libvirt-network","value":"5","type":"virNetworkUpdateSection","info":"<ip>/<dhcp>/<range>"}},{"$":{"name":"VIR_NETWORK_SECTION_LAST","file":"libvirt-network","value":"13","type":"virNetworkUpdateSection"}},{"$":{"name":"VIR_NETWORK_SECTION_NONE","file":"libvirt-network","value":"0","type":"virNetworkUpdateSection","info":"(invalid)"}},{"$":{"name":"VIR_NETWORK_SECTION_PORTGROUP","file":"libvirt-network","value":"9","type":"virNetworkUpdateSection","info":"<portgroup>"}},{"$":{"name":"VIR_NETWORK_UPDATE_AFFECT_CONFIG","file":"libvirt-network","value":"2","type":"virNetworkUpdateFlags","info":"affect persistent config only"}},{"$":{"name":"VIR_NETWORK_UPDATE_AFFECT_CURRENT","file":"libvirt-network","value":"0","type":"virNetworkUpdateFlags","info":"affect live if network is active,\nconfig if it's not active"}},{"$":{"name":"VIR_NETWORK_UPDATE_AFFECT_LIVE","file":"libvirt-network","value":"1","type":"virNetworkUpdateFlags","info":"affect live state of network only"}},{"$":{"name":"VIR_NETWORK_UPDATE_COMMAND_ADD_FIRST","file":"libvirt-network","value":"4","type":"virNetworkUpdateCommand","info":"add an element at start of list"}},{"$":{"name":"VIR_NETWORK_UPDATE_COMMAND_ADD_LAST","file":"libvirt-network","value":"3","type":"virNetworkUpdateCommand","info":"add an element at end of list"}},{"$":{"name":"VIR_NETWORK_UPDATE_COMMAND_DELETE","file":"libvirt-network","value":"2","type":"virNetworkUpdateCommand","info":"delete an existing element"}},{"$":{"name":"VIR_NETWORK_UPDATE_COMMAND_LAST","file":"libvirt-network","value":"5","type":"virNetworkUpdateCommand"}},{"$":{"name":"VIR_NETWORK_UPDATE_COMMAND_MODIFY","file":"libvirt-network","value":"1","type":"virNetworkUpdateCommand","info":"modify an existing element"}},{"$":{"name":"VIR_NETWORK_UPDATE_COMMAND_NONE","file":"libvirt-network","value":"0","type":"virNetworkUpdateCommand","info":"(invalid)"}},{"$":{"name":"VIR_NETWORK_XML_INACTIVE","file":"libvirt-network","value":"1","type":"virNetworkXMLFlags","info":"dump inactive network information"}},{"$":{"name":"VIR_NODE_ALLOC_PAGES_ADD","file":"libvirt-host","value":"0","type":"virNodeAllocPagesFlags","info":"Add @pageCounts to the pages pool. This\ncan be used only to size up the pool."}},{"$":{"name":"VIR_NODE_ALLOC_PAGES_SET","file":"libvirt-host","value":"1","type":"virNodeAllocPagesFlags","info":"Don't add @pageCounts, instead set\npassed number of pages. This can be\nused to free allocated pages."}},{"$":{"name":"VIR_NODE_CPU_STATS_ALL_CPUS","file":"libvirt-host","value":"-1","type":"virNodeGetCPUStatsAllCPUs"}},{"$":{"name":"VIR_NODE_DEVICE_EVENT_CREATED","file":"libvirt-nodedev","value":"0","type":"virNodeDeviceEventLifecycleType"}},{"$":{"name":"VIR_NODE_DEVICE_EVENT_DELETED","file":"libvirt-nodedev","value":"1","type":"virNodeDeviceEventLifecycleType"}},{"$":{"name":"VIR_NODE_DEVICE_EVENT_ID_LAST","file":"libvirt-nodedev","value":"2","type":"virNodeDeviceEventID","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last event ID supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_NODE_DEVICE_EVENT_ID_LIFECYCLE","file":"libvirt-nodedev","value":"0","type":"virNodeDeviceEventID","info":"virConnectNodeDeviceEventLifecycleCallback"}},{"$":{"name":"VIR_NODE_DEVICE_EVENT_ID_UPDATE","file":"libvirt-nodedev","value":"1","type":"virNodeDeviceEventID","info":"virConnectNodeDeviceEventGenericCallback"}},{"$":{"name":"VIR_NODE_DEVICE_EVENT_LAST","file":"libvirt-nodedev","value":"2","type":"virNodeDeviceEventLifecycleType"}},{"$":{"name":"VIR_NODE_MEMORY_STATS_ALL_CELLS","file":"libvirt-host","value":"-1","type":"virNodeGetMemoryStatsAllCells"}},{"$":{"name":"VIR_NODE_SUSPEND_TARGET_DISK","file":"libvirt-host","value":"1","type":"virNodeSuspendTarget"}},{"$":{"name":"VIR_NODE_SUSPEND_TARGET_HYBRID","file":"libvirt-host","value":"2","type":"virNodeSuspendTarget"}},{"$":{"name":"VIR_NODE_SUSPEND_TARGET_LAST","file":"libvirt-host","value":"3","type":"virNodeSuspendTarget","info":"This constant is subject to change"}},{"$":{"name":"VIR_NODE_SUSPEND_TARGET_MEM","file":"libvirt-host","value":"0","type":"virNodeSuspendTarget"}},{"$":{"name":"VIR_SECRET_EVENT_DEFINED","file":"libvirt-secret","value":"0","type":"virSecretEventLifecycleType"}},{"$":{"name":"VIR_SECRET_EVENT_ID_LAST","file":"libvirt-secret","value":"2","type":"virSecretEventID","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last event ID supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_SECRET_EVENT_ID_LIFECYCLE","file":"libvirt-secret","value":"0","type":"virSecretEventID","info":"virConnectSecretEventLifecycleCallback"}},{"$":{"name":"VIR_SECRET_EVENT_ID_VALUE_CHANGED","file":"libvirt-secret","value":"1","type":"virSecretEventID","info":"virConnectSecretEventGenericCallback"}},{"$":{"name":"VIR_SECRET_EVENT_LAST","file":"libvirt-secret","value":"2","type":"virSecretEventLifecycleType"}},{"$":{"name":"VIR_SECRET_EVENT_UNDEFINED","file":"libvirt-secret","value":"1","type":"virSecretEventLifecycleType"}},{"$":{"name":"VIR_SECRET_USAGE_TYPE_CEPH","file":"libvirt-secret","value":"2","type":"virSecretUsageType"}},{"$":{"name":"VIR_SECRET_USAGE_TYPE_ISCSI","file":"libvirt-secret","value":"3","type":"virSecretUsageType"}},{"$":{"name":"VIR_SECRET_USAGE_TYPE_LAST","file":"libvirt-secret","value":"5","type":"virSecretUsageType","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last secret owner ID\n supported by this version of the libvirt API."}},{"$":{"name":"VIR_SECRET_USAGE_TYPE_NONE","file":"libvirt-secret","value":"0","type":"virSecretUsageType"}},{"$":{"name":"VIR_SECRET_USAGE_TYPE_TLS","file":"libvirt-secret","value":"4","type":"virSecretUsageType"}},{"$":{"name":"VIR_SECRET_USAGE_TYPE_VOLUME","file":"libvirt-secret","value":"1","type":"virSecretUsageType"}},{"$":{"name":"VIR_STORAGE_POOL_BUILDING","file":"libvirt-storage","value":"1","type":"virStoragePoolState","info":"Initializing pool, not available"}},{"$":{"name":"VIR_STORAGE_POOL_BUILD_NEW","file":"libvirt-storage","value":"0","type":"virStoragePoolBuildFlags","info":"Regular build from scratch"}},{"$":{"name":"VIR_STORAGE_POOL_BUILD_NO_OVERWRITE","file":"libvirt-storage","value":"4","type":"virStoragePoolBuildFlags","info":"Do not overwrite existing pool"}},{"$":{"name":"VIR_STORAGE_POOL_BUILD_OVERWRITE","file":"libvirt-storage","value":"8","type":"virStoragePoolBuildFlags","info":"Overwrite data"}},{"$":{"name":"VIR_STORAGE_POOL_BUILD_REPAIR","file":"libvirt-storage","value":"1","type":"virStoragePoolBuildFlags","info":"Repair / reinitialize"}},{"$":{"name":"VIR_STORAGE_POOL_BUILD_RESIZE","file":"libvirt-storage","value":"2","type":"virStoragePoolBuildFlags","info":"Extend existing pool"}},{"$":{"name":"VIR_STORAGE_POOL_CREATE_NORMAL","file":"libvirt-storage","value":"0","type":"virStoragePoolCreateFlags","info":"Create the pool and perform pool build without any flags"}},{"$":{"name":"VIR_STORAGE_POOL_CREATE_WITH_BUILD","file":"libvirt-storage","value":"1","type":"virStoragePoolCreateFlags","info":"Create the pool and perform pool build using the\n VIR_STORAGE_POOL_BUILD_OVERWRITE flag. This is mutually\n exclusive to VIR_STORAGE_POOL_CREATE_WITH_BUILD_NO_OVERWRITE"}},{"$":{"name":"VIR_STORAGE_POOL_CREATE_WITH_BUILD_NO_OVERWRITE","file":"libvirt-storage","value":"4","type":"virStoragePoolCreateFlags"}},{"$":{"name":"VIR_STORAGE_POOL_CREATE_WITH_BUILD_OVERWRITE","file":"libvirt-storage","value":"2","type":"virStoragePoolCreateFlags","info":"Create the pool and perform pool build using the\n VIR_STORAGE_POOL_BUILD_NO_OVERWRITE flag. This is mutually\n exclusive to VIR_STORAGE_POOL_CREATE_WITH_BUILD_OVERWRITE"}},{"$":{"name":"VIR_STORAGE_POOL_DEGRADED","file":"libvirt-storage","value":"3","type":"virStoragePoolState","info":"Running degraded"}},{"$":{"name":"VIR_STORAGE_POOL_DELETE_NORMAL","file":"libvirt-storage","value":"0","type":"virStoragePoolDeleteFlags","info":"Delete metadata only    (fast)"}},{"$":{"name":"VIR_STORAGE_POOL_DELETE_ZEROED","file":"libvirt-storage","value":"1","type":"virStoragePoolDeleteFlags","info":"Clear all data to zeros (slow)"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_CREATED","file":"libvirt-storage","value":"4","type":"virStoragePoolEventLifecycleType"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_DEFINED","file":"libvirt-storage","value":"0","type":"virStoragePoolEventLifecycleType"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_DELETED","file":"libvirt-storage","value":"5","type":"virStoragePoolEventLifecycleType"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_ID_LAST","file":"libvirt-storage","value":"2","type":"virStoragePoolEventID","info":"NB: this enum value will increase over time as new events are\n added to the libvirt API. It reflects the last event ID supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_ID_LIFECYCLE","file":"libvirt-storage","value":"0","type":"virStoragePoolEventID","info":"virConnectStoragePoolEventLifecycleCallback"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_ID_REFRESH","file":"libvirt-storage","value":"1","type":"virStoragePoolEventID","info":"virConnectStoragePoolEventGenericCallback"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_LAST","file":"libvirt-storage","value":"6","type":"virStoragePoolEventLifecycleType"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_STARTED","file":"libvirt-storage","value":"2","type":"virStoragePoolEventLifecycleType"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_STOPPED","file":"libvirt-storage","value":"3","type":"virStoragePoolEventLifecycleType"}},{"$":{"name":"VIR_STORAGE_POOL_EVENT_UNDEFINED","file":"libvirt-storage","value":"1","type":"virStoragePoolEventLifecycleType"}},{"$":{"name":"VIR_STORAGE_POOL_INACCESSIBLE","file":"libvirt-storage","value":"4","type":"virStoragePoolState","info":"Running, but not accessible"}},{"$":{"name":"VIR_STORAGE_POOL_INACTIVE","file":"libvirt-storage","value":"0","type":"virStoragePoolState","info":"Not running"}},{"$":{"name":"VIR_STORAGE_POOL_RUNNING","file":"libvirt-storage","value":"2","type":"virStoragePoolState","info":"Running normally"}},{"$":{"name":"VIR_STORAGE_POOL_STATE_LAST","file":"libvirt-storage","value":"5","type":"virStoragePoolState"}},{"$":{"name":"VIR_STORAGE_VOL_BLOCK","file":"libvirt-storage","value":"1","type":"virStorageVolType","info":"Block based volumes"}},{"$":{"name":"VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA","file":"libvirt-storage","value":"1","type":"virStorageVolCreateFlags"}},{"$":{"name":"VIR_STORAGE_VOL_CREATE_REFLINK","file":"libvirt-storage","value":"2","type":"virStorageVolCreateFlags","info":"perform a btrfs lightweight copy"}},{"$":{"name":"VIR_STORAGE_VOL_DELETE_NORMAL","file":"libvirt-storage","value":"0","type":"virStorageVolDeleteFlags","info":"Delete metadata only    (fast)"}},{"$":{"name":"VIR_STORAGE_VOL_DELETE_WITH_SNAPSHOTS","file":"libvirt-storage","value":"2","type":"virStorageVolDeleteFlags","info":"Force removal of volume, even if in use"}},{"$":{"name":"VIR_STORAGE_VOL_DELETE_ZEROED","file":"libvirt-storage","value":"1","type":"virStorageVolDeleteFlags","info":"Clear all data to zeros (slow)"}},{"$":{"name":"VIR_STORAGE_VOL_DIR","file":"libvirt-storage","value":"2","type":"virStorageVolType","info":"Directory-passthrough based volume"}},{"$":{"name":"VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM","file":"libvirt-storage","value":"1","type":"virStorageVolDownloadFlags","info":"Use sparse stream"}},{"$":{"name":"VIR_STORAGE_VOL_FILE","file":"libvirt-storage","value":"0","type":"virStorageVolType","info":"Regular file based volumes"}},{"$":{"name":"VIR_STORAGE_VOL_GET_PHYSICAL","file":"libvirt-storage","value":"1","type":"virStorageVolInfoFlags"}},{"$":{"name":"VIR_STORAGE_VOL_LAST","file":"libvirt-storage","value":"6","type":"virStorageVolType"}},{"$":{"name":"VIR_STORAGE_VOL_NETDIR","file":"libvirt-storage","value":"4","type":"virStorageVolType","info":"Network accessible directory that can\n contain other network volumes"}},{"$":{"name":"VIR_STORAGE_VOL_NETWORK","file":"libvirt-storage","value":"3","type":"virStorageVolType","info":"Network volumes like RBD (RADOS Block Device)"}},{"$":{"name":"VIR_STORAGE_VOL_PLOOP","file":"libvirt-storage","value":"5","type":"virStorageVolType","info":"Ploop based volumes"}},{"$":{"name":"VIR_STORAGE_VOL_RESIZE_ALLOCATE","file":"libvirt-storage","value":"1","type":"virStorageVolResizeFlags","info":"force allocation of new size"}},{"$":{"name":"VIR_STORAGE_VOL_RESIZE_DELTA","file":"libvirt-storage","value":"2","type":"virStorageVolResizeFlags","info":"size is relative to current"}},{"$":{"name":"VIR_STORAGE_VOL_RESIZE_SHRINK","file":"libvirt-storage","value":"4","type":"virStorageVolResizeFlags","info":"allow decrease in capacity"}},{"$":{"name":"VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM","file":"libvirt-storage","value":"1","type":"virStorageVolUploadFlags","info":"Use sparse stream"}},{"$":{"name":"VIR_STORAGE_VOL_USE_ALLOCATION","file":"libvirt-storage","value":"0","type":"virStorageVolInfoFlags","info":"Return the physical size in allocation"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_BSI","file":"libvirt-storage","value":"3","type":"virStorageVolWipeAlgorithm","info":"9-pass method recommended by the\nGerman Center of Security in\nInformation Technologies"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_DOD","file":"libvirt-storage","value":"2","type":"virStorageVolWipeAlgorithm","info":"4-pass DoD 5220.22-M section\n8-306 procedure"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_GUTMANN","file":"libvirt-storage","value":"4","type":"virStorageVolWipeAlgorithm","info":"The canonical 35-pass sequence"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_LAST","file":"libvirt-storage","value":"10","type":"virStorageVolWipeAlgorithm","info":"NB: this enum value will increase over time as new algorithms are\n added to the libvirt API. It reflects the last algorithm supported\n by this version of the libvirt API."}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_NNSA","file":"libvirt-storage","value":"1","type":"virStorageVolWipeAlgorithm","info":"4-pass  NNSA Policy Letter\nNAP-14.1-C (XVI-8)"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33","file":"libvirt-storage","value":"7","type":"virStorageVolWipeAlgorithm","info":"33-pass random"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7","file":"libvirt-storage","value":"6","type":"virStorageVolWipeAlgorithm","info":"7-pass random"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_RANDOM","file":"libvirt-storage","value":"8","type":"virStorageVolWipeAlgorithm","info":"1-pass random"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER","file":"libvirt-storage","value":"5","type":"virStorageVolWipeAlgorithm","info":"7-pass method described by\nBruce Schneier in \"Applied\nCryptography\" (1996)"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_TRIM","file":"libvirt-storage","value":"9","type":"virStorageVolWipeAlgorithm","info":"1-pass, trim all data on the\nvolume by using TRIM or DISCARD"}},{"$":{"name":"VIR_STORAGE_VOL_WIPE_ALG_ZERO","file":"libvirt-storage","value":"0","type":"virStorageVolWipeAlgorithm","info":"1-pass, all zeroes"}},{"$":{"name":"VIR_STORAGE_XML_INACTIVE","file":"libvirt-storage","value":"1","type":"virStorageXMLFlags","info":"dump inactive pool/volume information"}},{"$":{"name":"VIR_STREAM_EVENT_ERROR","file":"libvirt-stream","value":"4","type":"virStreamEventType"}},{"$":{"name":"VIR_STREAM_EVENT_HANGUP","file":"libvirt-stream","value":"8","type":"virStreamEventType"}},{"$":{"name":"VIR_STREAM_EVENT_READABLE","file":"libvirt-stream","value":"1","type":"virStreamEventType"}},{"$":{"name":"VIR_STREAM_EVENT_WRITABLE","file":"libvirt-stream","value":"2","type":"virStreamEventType"}},{"$":{"name":"VIR_STREAM_NONBLOCK","file":"libvirt-stream","value":"1","type":"virStreamFlags"}},{"$":{"name":"VIR_STREAM_RECV_STOP_AT_HOLE","file":"libvirt-stream","value":"1","type":"virStreamRecvFlagsValues"}},{"$":{"name":"VIR_TYPED_PARAM_BOOLEAN","file":"libvirt-common","value":"6","type":"virTypedParameterType","info":"boolean(character) case"}},{"$":{"name":"VIR_TYPED_PARAM_DOUBLE","file":"libvirt-common","value":"5","type":"virTypedParameterType","info":"double case"}},{"$":{"name":"VIR_TYPED_PARAM_INT","file":"libvirt-common","value":"1","type":"virTypedParameterType","info":"integer case"}},{"$":{"name":"VIR_TYPED_PARAM_LAST","file":"libvirt-common","value":"8","type":"virTypedParameterType"}},{"$":{"name":"VIR_TYPED_PARAM_LLONG","file":"libvirt-common","value":"3","type":"virTypedParameterType","info":"long long case"}},{"$":{"name":"VIR_TYPED_PARAM_STRING","file":"libvirt-common","value":"7","type":"virTypedParameterType","info":"string case"}},{"$":{"name":"VIR_TYPED_PARAM_STRING_OKAY","file":"libvirt-common","value":"4","type":"virTypedParameterFlags","info":"1 << 0 is reserved for virDomainModificationImpact 1 << 1 is reserved for virDomainModificationImpact Older servers lacked the ability to handle string typed\n parameters.  Attempts to set a string parameter with an older\n server will fail at the client, but attempts to retrieve\n parameters must not return strings from a new server to an\n older client, so this flag exists to identify newer clients to\n newer servers.  This flag is automatically set when needed, so\n the user does not have to worry about it; however, manually\n setting the flag can be used to reject servers that cannot\n return typed strings, even if no strings would be returned."}},{"$":{"name":"VIR_TYPED_PARAM_UINT","file":"libvirt-common","value":"2","type":"virTypedParameterType","info":"unsigned integer case"}},{"$":{"name":"VIR_TYPED_PARAM_ULLONG","file":"libvirt-common","value":"4","type":"virTypedParameterType","info":"unsigned long long case"}},{"$":{"name":"VIR_VCPU_BLOCKED","file":"libvirt-domain","value":"2","type":"virVcpuState","info":"the virtual CPU is blocked on resource"}},{"$":{"name":"VIR_VCPU_LAST","file":"libvirt-domain","value":"3","type":"virVcpuState"}},{"$":{"name":"VIR_VCPU_OFFLINE","file":"libvirt-domain","value":"0","type":"virVcpuState","info":"the virtual CPU is offline"}},{"$":{"name":"VIR_VCPU_RUNNING","file":"libvirt-domain","value":"1","type":"virVcpuState","info":"the virtual CPU is running"}},{"$":{"name":"VIR_WAR_NO_INTERFACE","file":"virterror","value":"56","type":"virErrorNumber","info":"failed to start interface driver"}},{"$":{"name":"VIR_WAR_NO_NETWORK","file":"virterror","value":"41","type":"virErrorNumber","info":"failed to start network"}},{"$":{"name":"VIR_WAR_NO_NODE","file":"virterror","value":"51","type":"virErrorNumber","info":"failed to start node driver"}},{"$":{"name":"VIR_WAR_NO_NWFILTER","file":"virterror","value":"60","type":"virErrorNumber","info":"failed to start nwfilter driver"}},{"$":{"name":"VIR_WAR_NO_SECRET","file":"virterror","value":"64","type":"virErrorNumber","info":"failed to start secret storage"}},{"$":{"name":"VIR_WAR_NO_STORAGE","file":"virterror","value":"48","type":"virErrorNumber","info":"failed to start storage"}}],"struct":[{"$":{"name":"virBlkioParameter","file":"libvirt-domain","type":"struct _virTypedParameter"},"field":[{"$":{"name":"field","type":"char field[VIR_TYPED_PARAM_FIELD_LENGTH]","info":"parameter name"}},{"$":{"name":"type","type":"int","info":"parameter type, virTypedParameterType"}},{"$":{"name":"value","type":"union","info":"parameter value"},"union":[{"field":[{"$":{"name":"i","type":"int","info":"type is INT"}},{"$":{"name":"ui","type":"unsigned int","info":"type is UINT"}},{"$":{"name":"l","type":"long long int","info":"type is LLONG"}},{"$":{"name":"ul","type":"unsigned long long int","info":"type is ULLONG"}},{"$":{"name":"d","type":"double","info":"type is DOUBLE"}},{"$":{"name":"b","type":"char","info":"type is BOOLEAN"}},{"$":{"name":"s","type":"char *","info":"type is STRING, may not be NULL"}}]}]}]},{"$":{"name":"virConnect","file":"libvirt-host","type":"struct _virConnect"}},{"$":{"name":"virConnectAuth","file":"libvirt-host","type":"struct _virConnectAuth"},"field":[{"$":{"name":"credtype","type":"int *","info":"List of supported virConnectCredentialType values"}},{"$":{"name":"ncredtype","type":"unsigned int","info":""}},{"$":{"name":"cb","type":"virConnectAuthCallbackPtr","info":"Callback used to collect credentials"}},{"$":{"name":"cbdata","type":"void *","info":""}}]},{"$":{"name":"virConnectCredential","file":"libvirt-host","type":"struct _virConnectCredential"},"field":[{"$":{"name":"type","type":"int","info":"One of virConnectCredentialType constants"}},{"$":{"name":"prompt","type":"const char *","info":"Prompt to show to user"}},{"$":{"name":"challenge","type":"const char *","info":"Additional challenge to show"}},{"$":{"name":"defresult","type":"const char *","info":"Optional default result"}},{"$":{"name":"result","type":"char *","info":"Result to be filled with user response (or defresult)"}},{"$":{"name":"resultlen","type":"unsigned int","info":"Length of the result"}}]},{"$":{"name":"virDomain","file":"libvirt-domain","type":"struct _virDomain"}},{"$":{"name":"virDomainBlockInfo","file":"libvirt-domain","type":"struct _virDomainBlockInfo"},"field":[{"$":{"name":"capacity","type":"unsigned long long","info":"logical size in bytes of the\n image (how much storage the\n guest will see)"}},{"$":{"name":"allocation","type":"unsigned long long","info":"host storage in bytes occupied\n by the image (such as highest\n allocated extent if there are no\n holes, similar to 'du')"}},{"$":{"name":"physical","type":"unsigned long long","info":"host physical size in bytes of\n the image container (last\n offset, similar to 'ls'"}}]},{"$":{"name":"virDomainBlockJobInfo","file":"libvirt-domain","type":"struct _virDomainBlockJobInfo"},"field":[{"$":{"name":"type","type":"int","info":"virDomainBlockJobType"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"The following fields provide an indication of block job progress.  @cur\n indicates the current position and will be between 0 and @end.  @end is\n the final cursor position for this operation and represents completion.\n To approximate progress, divide @cur by @end."}},{"$":{"name":"cur","type":"virDomainBlockJobCursor","info":""}},{"$":{"name":"end","type":"virDomainBlockJobCursor","info":""}}]},{"$":{"name":"virDomainBlockStatsStruct","file":"libvirt-domain","type":"struct _virDomainBlockStats"},"field":[{"$":{"name":"rd_req","type":"long long","info":"number of read requests"}},{"$":{"name":"rd_bytes","type":"long long","info":"number of read bytes"}},{"$":{"name":"wr_req","type":"long long","info":"number of write requests"}},{"$":{"name":"wr_bytes","type":"long long","info":"number of written bytes"}},{"$":{"name":"errs","type":"long long","info":"In Xen this returns the mysterious 'oo_req'."}}]},{"$":{"name":"virDomainControlInfo","file":"libvirt-domain","type":"struct _virDomainControlInfo"},"field":[{"$":{"name":"state","type":"unsigned int","info":"control state, one of virDomainControlState"}},{"$":{"name":"details","type":"unsigned int","info":"state details, currently 0 except for ERROR\nstate (one of virDomainControlErrorReason)"}},{"$":{"name":"stateTime","type":"unsigned long long","info":"for how long (in msec) control interface\nhas been in current state (except for OK\nand ERROR states)"}}]},{"$":{"name":"virDomainDiskError","file":"libvirt-domain","type":"struct _virDomainDiskError"},"field":[{"$":{"name":"disk","type":"char *","info":"disk target"}},{"$":{"name":"error","type":"int","info":"virDomainDiskErrorCode"}}]},{"$":{"name":"virDomainEventGraphicsAddress","file":"libvirt-domain","type":"struct _virDomainEventGraphicsAddress"},"field":[{"$":{"name":"family","type":"int","info":"Address family, virDomainEventGraphicsAddressType"}},{"$":{"name":"node","type":"char *","info":"Address of node (eg IP address, or UNIX path)"}},{"$":{"name":"service","type":"char *","info":"Service name/number (eg TCP port, or NULL)"}}]},{"$":{"name":"virDomainEventGraphicsSubject","file":"libvirt-domain","type":"struct _virDomainEventGraphicsSubject"},"field":[{"$":{"name":"nidentity","type":"int","info":"Number of identities in arra"}},{"$":{"name":"identities","type":"virDomainEventGraphicsSubjectIdentityPtr","info":"Array of identities for subject"}}]},{"$":{"name":"virDomainEventGraphicsSubjectIdentity","file":"libvirt-domain","type":"struct _virDomainEventGraphicsSubjectIdentity"},"field":[{"$":{"name":"type","type":"char *","info":"Type of identity"}},{"$":{"name":"name","type":"char *","info":"Identity value"}}]},{"$":{"name":"virDomainFSInfo","file":"libvirt-domain","type":"struct _virDomainFSInfo"},"field":[{"$":{"name":"mountpoint","type":"char *","info":"path to mount point"}},{"$":{"name":"name","type":"char *","info":"device name in the guest (e.g. \"sda1\")"}},{"$":{"name":"fstype","type":"char *","info":"filesystem type"}},{"$":{"name":"ndevAlias","type":"size_t","info":"number of elements in devAlias"}},{"$":{"name":"devAlias","type":"char **","info":"array of disk device aliases"}}]},{"$":{"name":"virDomainIOThreadInfo","file":"libvirt-domain","type":"struct _virDomainIOThreadInfo"},"field":[{"$":{"name":"iothread_id","type":"unsigned int","info":"IOThread ID"}},{"$":{"name":"cpumap","type":"unsigned char *","info":"CPU map for thread. A pointer to an array of real CPUs (in 8-bit bytes)"}},{"$":{"name":"cpumaplen","type":"int","info":"cpumap size"}}]},{"$":{"name":"virDomainIPAddress","file":"libvirt-domain","type":"struct _virDomainInterfaceIPAddress"},"field":[{"$":{"name":"type","type":"int","info":"virIPAddrType"}},{"$":{"name":"addr","type":"char *","info":"IP address"}},{"$":{"name":"prefix","type":"unsigned int","info":"IP address prefix"}}]},{"$":{"name":"virDomainInfo","file":"libvirt-domain","type":"struct _virDomainInfo"},"field":[{"$":{"name":"state","type":"unsigned char","info":"the running state, one of virDomainState"}},{"$":{"name":"maxMem","type":"unsigned long","info":"the maximum memory in KBytes allowed"}},{"$":{"name":"memory","type":"unsigned long","info":"the memory in KBytes used by the domain"}},{"$":{"name":"nrVirtCpu","type":"unsigned short","info":"the number of virtual CPUs for the domain"}},{"$":{"name":"cpuTime","type":"unsigned long long","info":"the CPU time used in nanoseconds"}}]},{"$":{"name":"virDomainInterface","file":"libvirt-domain","type":"struct _virDomainInterface"},"field":[{"$":{"name":"name","type":"char *","info":"interface name"}},{"$":{"name":"hwaddr","type":"char *","info":"hardware address, may be NULL"}},{"$":{"name":"naddrs","type":"unsigned int","info":"number of items in @addrs"}},{"$":{"name":"addrs","type":"virDomainIPAddressPtr","info":"array of IP addresses"}}]},{"$":{"name":"virDomainInterfaceStatsStruct","file":"libvirt-domain","type":"struct _virDomainInterfaceStats"},"field":[{"$":{"name":"rx_bytes","type":"long long","info":""}},{"$":{"name":"rx_packets","type":"long long","info":""}},{"$":{"name":"rx_errs","type":"long long","info":""}},{"$":{"name":"rx_drop","type":"long long","info":""}},{"$":{"name":"tx_bytes","type":"long long","info":""}},{"$":{"name":"tx_packets","type":"long long","info":""}},{"$":{"name":"tx_errs","type":"long long","info":""}},{"$":{"name":"tx_drop","type":"long long","info":""}}]},{"$":{"name":"virDomainJobInfo","file":"libvirt-domain","type":"struct _virDomainJobInfo"},"field":[{"$":{"name":"type","type":"int","info":"Time is measured in milliseconds"}},{"$":{"name":"timeElapsed","type":"unsigned long long","info":"Always set"}},{"$":{"name":"timeRemaining","type":"unsigned long long","info":"Only for VIR_DOMAIN_JOB_BOUNDED Data is measured in bytes unless otherwise specified\n and is measuring the job as a whole.\n\n For VIR_DOMAIN_JOB_UNBOUNDED, dataTotal may be less\n than the final sum of dataProcessed + dataRemaining\n in the event that the hypervisor has to repeat some\n data, such as due to dirtied pages during migration.\n\n For VIR_DOMAIN_JOB_BOUNDED, dataTotal shall always\n equal the sum of dataProcessed + dataRemaining."}},{"$":{"name":"dataTotal","type":"unsigned long long","info":""}},{"$":{"name":"dataProcessed","type":"unsigned long long","info":""}},{"$":{"name":"dataRemaining","type":"unsigned long long","info":"As above, but only tracking guest memory progress"}},{"$":{"name":"memTotal","type":"unsigned long long","info":""}},{"$":{"name":"memProcessed","type":"unsigned long long","info":""}},{"$":{"name":"memRemaining","type":"unsigned long long","info":"As above, but only tracking guest disk file progress"}},{"$":{"name":"fileTotal","type":"unsigned long long","info":""}},{"$":{"name":"fileProcessed","type":"unsigned long long","info":""}},{"$":{"name":"fileRemaining","type":"unsigned long long","info":""}}]},{"$":{"name":"virDomainMemoryStatStruct","file":"libvirt-domain","type":"struct _virDomainMemoryStat"},"field":[{"$":{"name":"tag","type":"int","info":""}},{"$":{"name":"val","type":"unsigned long long","info":""}}]},{"$":{"name":"virDomainSnapshot","file":"libvirt-domain-snapshot","type":"struct _virDomainSnapshot"}},{"$":{"name":"virDomainStatsRecord","file":"libvirt-domain","type":"struct _virDomainStatsRecord"},"field":[{"$":{"name":"dom","type":"virDomainPtr","info":""}},{"$":{"name":"params","type":"virTypedParameterPtr","info":""}},{"$":{"name":"nparams","type":"int","info":""}}]},{"$":{"name":"virError","file":"virterror","type":"struct _virError"},"field":[{"$":{"name":"code","type":"int","info":"The error code, a virErrorNumber"}},{"$":{"name":"domain","type":"int","info":"What part of the library raised this error"}},{"$":{"name":"message","type":"char *","info":"human-readable informative error message"}},{"$":{"name":"level","type":"virErrorLevel","info":"how consequent is the error"}},{"$":{"name":"conn","type":"virConnectPtr","info":"connection if available, deprecated\nsee note above"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain if available, deprecated\nsee note above"}},{"$":{"name":"str1","type":"char *","info":"extra string information"}},{"$":{"name":"str2","type":"char *","info":"extra string information"}},{"$":{"name":"str3","type":"char *","info":"extra string information"}},{"$":{"name":"int1","type":"int","info":"extra number information"}},{"$":{"name":"int2","type":"int","info":"extra number information"}},{"$":{"name":"net","type":"virNetworkPtr","info":"network if available, deprecated\nsee note above"}}]},{"$":{"name":"virInterface","file":"libvirt-interface","type":"struct _virInterface"}},{"$":{"name":"virMemoryParameter","file":"libvirt-domain","type":"struct _virTypedParameter"},"field":[{"$":{"name":"field","type":"char field[VIR_TYPED_PARAM_FIELD_LENGTH]","info":"parameter name"}},{"$":{"name":"type","type":"int","info":"parameter type, virTypedParameterType"}},{"$":{"name":"value","type":"union","info":"parameter value"},"union":[{"field":[{"$":{"name":"i","type":"int","info":"type is INT"}},{"$":{"name":"ui","type":"unsigned int","info":"type is UINT"}},{"$":{"name":"l","type":"long long int","info":"type is LLONG"}},{"$":{"name":"ul","type":"unsigned long long int","info":"type is ULLONG"}},{"$":{"name":"d","type":"double","info":"type is DOUBLE"}},{"$":{"name":"b","type":"char","info":"type is BOOLEAN"}},{"$":{"name":"s","type":"char *","info":"type is STRING, may not be NULL"}}]}]}]},{"$":{"name":"virNWFilter","file":"libvirt-nwfilter","type":"struct _virNWFilter"}},{"$":{"name":"virNetwork","file":"libvirt-network","type":"struct _virNetwork"}},{"$":{"name":"virNetworkDHCPLease","file":"libvirt-network","type":"struct _virNetworkDHCPLease"},"field":[{"$":{"name":"iface","type":"char *","info":"Network interface name"}},{"$":{"name":"expirytime","type":"long long","info":"Seconds since epoch"}},{"$":{"name":"type","type":"int","info":"virIPAddrType"}},{"$":{"name":"mac","type":"char *","info":"MAC address"}},{"$":{"name":"iaid","type":"char *","info":"IAID"}},{"$":{"name":"ipaddr","type":"char *","info":"IP address"}},{"$":{"name":"prefix","type":"unsigned int","info":"IP address prefix"}},{"$":{"name":"hostname","type":"char *","info":"Hostname"}},{"$":{"name":"clientid","type":"char *","info":"Client ID or DUID"}}]},{"$":{"name":"virNodeCPUStats","file":"libvirt-host","type":"struct _virNodeCPUStats"},"field":[{"$":{"name":"field","type":"char field[VIR_NODE_CPU_STATS_FIELD_LENGTH]","info":""}},{"$":{"name":"value","type":"unsigned long long","info":""}}]},{"$":{"name":"virNodeDevice","file":"libvirt-nodedev","type":"struct _virNodeDevice"}},{"$":{"name":"virNodeInfo","file":"libvirt-host","type":"struct _virNodeInfo"},"field":[{"$":{"name":"model","type":"char model[32]","info":"string indicating the CPU model"}},{"$":{"name":"memory","type":"unsigned long","info":"memory size in kilobytes"}},{"$":{"name":"cpus","type":"unsigned int","info":"the number of active CPUs"}},{"$":{"name":"mhz","type":"unsigned int","info":"expected CPU frequency, 0 if not known or\non unusual architectures"}},{"$":{"name":"nodes","type":"unsigned int","info":"the number of NUMA cell, 1 for unusual NUMA\ntopologies or uniform memory access; check\ncapabilities XML for the actual NUMA topology"}},{"$":{"name":"sockets","type":"unsigned int","info":"number of CPU sockets per node if nodes > 1,\n1 in case of unusual NUMA topology"}},{"$":{"name":"cores","type":"unsigned int","info":"number of cores per socket, total number of\nprocessors in case of unusual NUMA topolog"}},{"$":{"name":"threads","type":"unsigned int","info":"number of threads per core, 1 in case of\nunusual numa topology"}}]},{"$":{"name":"virNodeMemoryStats","file":"libvirt-host","type":"struct _virNodeMemoryStats"},"field":[{"$":{"name":"field","type":"char field[VIR_NODE_MEMORY_STATS_FIELD_LENGTH]","info":""}},{"$":{"name":"value","type":"unsigned long long","info":""}}]},{"$":{"name":"virSchedParameter","file":"libvirt-domain","type":"struct _virTypedParameter"},"field":[{"$":{"name":"field","type":"char field[VIR_TYPED_PARAM_FIELD_LENGTH]","info":"parameter name"}},{"$":{"name":"type","type":"int","info":"parameter type, virTypedParameterType"}},{"$":{"name":"value","type":"union","info":"parameter value"},"union":[{"field":[{"$":{"name":"i","type":"int","info":"type is INT"}},{"$":{"name":"ui","type":"unsigned int","info":"type is UINT"}},{"$":{"name":"l","type":"long long int","info":"type is LLONG"}},{"$":{"name":"ul","type":"unsigned long long int","info":"type is ULLONG"}},{"$":{"name":"d","type":"double","info":"type is DOUBLE"}},{"$":{"name":"b","type":"char","info":"type is BOOLEAN"}},{"$":{"name":"s","type":"char *","info":"type is STRING, may not be NULL"}}]}]}]},{"$":{"name":"virSecret","file":"libvirt-secret","type":"struct _virSecret"}},{"$":{"name":"virSecurityLabel","file":"libvirt-host","type":"struct _virSecurityLabel"},"field":[{"$":{"name":"label","type":"char label[VIR_SECURITY_LABEL_BUFLEN]","info":"security label string"}},{"$":{"name":"enforcing","type":"int","info":"1 if security policy is being enforced for domain"}}]},{"$":{"name":"virSecurityModel","file":"libvirt-host","type":"struct _virSecurityModel"},"field":[{"$":{"name":"model","type":"char model[VIR_SECURITY_MODEL_BUFLEN]","info":"security model string"}},{"$":{"name":"doi","type":"char doi[VIR_SECURITY_DOI_BUFLEN]","info":"domain of interpretation"}}]},{"$":{"name":"virStoragePool","file":"libvirt-storage","type":"struct _virStoragePool"}},{"$":{"name":"virStoragePoolInfo","file":"libvirt-storage","type":"struct _virStoragePoolInfo"},"field":[{"$":{"name":"state","type":"int","info":"virStoragePoolState flags"}},{"$":{"name":"capacity","type":"unsigned long long","info":"Logical size bytes"}},{"$":{"name":"allocation","type":"unsigned long long","info":"Current allocation bytes"}},{"$":{"name":"available","type":"unsigned long long","info":"Remaining free space bytes"}}]},{"$":{"name":"virStorageVol","file":"libvirt-storage","type":"struct _virStorageVol"}},{"$":{"name":"virStorageVolInfo","file":"libvirt-storage","type":"struct _virStorageVolInfo"},"field":[{"$":{"name":"type","type":"int","info":"virStorageVolType flags"}},{"$":{"name":"capacity","type":"unsigned long long","info":"Logical size bytes"}},{"$":{"name":"allocation","type":"unsigned long long","info":"Current allocation bytes"}}]},{"$":{"name":"virStream","file":"libvirt-host","type":"struct _virStream"}},{"$":{"name":"virTypedParameter","file":"libvirt-common","type":"struct _virTypedParameter"},"field":[{"$":{"name":"field","type":"char field[VIR_TYPED_PARAM_FIELD_LENGTH]","info":"parameter name"}},{"$":{"name":"type","type":"int","info":"parameter type, virTypedParameterType"}},{"$":{"name":"value","type":"union","info":"parameter value"},"union":[{"field":[{"$":{"name":"i","type":"int","info":"type is INT"}},{"$":{"name":"ui","type":"unsigned int","info":"type is UINT"}},{"$":{"name":"l","type":"long long int","info":"type is LLONG"}},{"$":{"name":"ul","type":"unsigned long long int","info":"type is ULLONG"}},{"$":{"name":"d","type":"double","info":"type is DOUBLE"}},{"$":{"name":"b","type":"char","info":"type is BOOLEAN"}},{"$":{"name":"s","type":"char *","info":"type is STRING, may not be NULL"}}]}]}]},{"$":{"name":"virVcpuInfo","file":"libvirt-domain","type":"struct _virVcpuInfo"},"field":[{"$":{"name":"number","type":"unsigned int","info":"virtual CPU number"}},{"$":{"name":"state","type":"int","info":"value from virVcpuState"}},{"$":{"name":"cpuTime","type":"unsigned long long","info":"CPU time used, in nanoseconds"}},{"$":{"name":"cpu","type":"int","info":"real CPU number, or -1 if offline"}}]}],"typedef":[{"$":{"name":"virBlkioParameterPtr","file":"libvirt-domain","type":"virBlkioParameter *"},"info":["a virBlkioParameterPtr is a pointer to a virBlkioParameter structure. Provided for backwards compatibility; virTypedParameterPtr is the preferred alias since 0.9.2."]},{"$":{"name":"virBlkioParameterType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virCPUCompareResult","file":"libvirt-host","type":"enum"}},{"$":{"name":"virConnectAuthPtr","file":"libvirt-host","type":"virConnectAuth *"}},{"$":{"name":"virConnectBaselineCPUFlags","file":"libvirt-host","type":"enum"}},{"$":{"name":"virConnectCloseReason","file":"libvirt-common","type":"enum"}},{"$":{"name":"virConnectCompareCPUFlags","file":"libvirt-host","type":"enum"}},{"$":{"name":"virConnectCredentialPtr","file":"libvirt-host","type":"virConnectCredential *"}},{"$":{"name":"virConnectCredentialType","file":"libvirt-host","type":"enum"}},{"$":{"name":"virConnectDomainEventAgentLifecycleReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virConnectDomainEventAgentLifecycleState","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virConnectDomainEventBlockJobStatus","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virConnectDomainEventDiskChangeReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virConnectFlags","file":"libvirt-host","type":"enum"}},{"$":{"name":"virConnectGetAllDomainStatsFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virConnectListAllDomainsFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virConnectListAllInterfacesFlags","file":"libvirt-interface","type":"enum"}},{"$":{"name":"virConnectListAllNetworksFlags","file":"libvirt-network","type":"enum"}},{"$":{"name":"virConnectListAllNodeDeviceFlags","file":"libvirt-nodedev","type":"enum"}},{"$":{"name":"virConnectListAllSecretsFlags","file":"libvirt-secret","type":"enum"}},{"$":{"name":"virConnectListAllStoragePoolsFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virConnectPtr","file":"libvirt-host","type":"virConnect *"},"info":["a virConnectPtr is pointer to a virConnect private structure, this is the type used to reference a connection to the Hypervisor in the API."]},{"$":{"name":"virDomainBlockCommitFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockCopyFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockInfoPtr","file":"libvirt-domain","type":"virDomainBlockInfo *"}},{"$":{"name":"virDomainBlockJobAbortFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockJobCursor","file":"libvirt-domain","type":"unsigned long long"}},{"$":{"name":"virDomainBlockJobInfoFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockJobInfoPtr","file":"libvirt-domain","type":"virDomainBlockJobInfo *"}},{"$":{"name":"virDomainBlockJobSetSpeedFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockJobType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockPullFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockRebaseFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockResizeFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainBlockStatsPtr","file":"libvirt-domain","type":"virDomainBlockStatsStruct *"},"info":["A pointer to a virDomainBlockStats structure"]},{"$":{"name":"virDomainBlockedReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainChannelFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainConsoleFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainControlErrorReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainControlInfoPtr","file":"libvirt-domain","type":"virDomainControlInfo *"},"info":["Pointer to virDomainControlInfo structure."]},{"$":{"name":"virDomainControlState","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainCoreDumpFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainCoreDumpFormat","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainCrashedReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainCreateFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainDefineFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainDestroyFlagsValues","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainDeviceModifyFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainDiskErrorCode","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainDiskErrorPtr","file":"libvirt-domain","type":"virDomainDiskError *"}},{"$":{"name":"virDomainEventCrashedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventDefinedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventGraphicsAddressPtr","file":"libvirt-domain","type":"virDomainEventGraphicsAddress *"}},{"$":{"name":"virDomainEventGraphicsAddressType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventGraphicsPhase","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventGraphicsSubjectIdentityPtr","file":"libvirt-domain","type":"virDomainEventGraphicsSubjectIdentity *"}},{"$":{"name":"virDomainEventGraphicsSubjectPtr","file":"libvirt-domain","type":"virDomainEventGraphicsSubject *"}},{"$":{"name":"virDomainEventID","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventIOErrorAction","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventPMSuspendedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventResumedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventShutdownDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventStartedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventStoppedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventSuspendedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventTrayChangeReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventUndefinedDetailType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainEventWatchdogAction","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainFSInfoPtr","file":"libvirt-domain","type":"virDomainFSInfo *"}},{"$":{"name":"virDomainGetJobStatsFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainIOThreadInfoPtr","file":"libvirt-domain","type":"virDomainIOThreadInfo *"}},{"$":{"name":"virDomainIPAddressPtr","file":"libvirt-domain","type":"virDomainIPAddress *"}},{"$":{"name":"virDomainInfoPtr","file":"libvirt-domain","type":"virDomainInfo *"},"info":["a virDomainInfoPtr is a pointer to a virDomainInfo structure."]},{"$":{"name":"virDomainInterfaceAddressesSource","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainInterfacePtr","file":"libvirt-domain","type":"virDomainInterface *"}},{"$":{"name":"virDomainInterfaceStatsPtr","file":"libvirt-domain","type":"virDomainInterfaceStatsStruct *"},"info":["A pointer to a virDomainInterfaceStats structure"]},{"$":{"name":"virDomainJobInfoPtr","file":"libvirt-domain","type":"virDomainJobInfo *"}},{"$":{"name":"virDomainJobOperation","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainJobType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainLifecycle","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainLifecycleAction","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainMemoryFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainMemoryModFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainMemoryStatPtr","file":"libvirt-domain","type":"virDomainMemoryStatStruct *"}},{"$":{"name":"virDomainMemoryStatTags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainMetadataType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainMigrateFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainModificationImpact","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainNostateReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainNumatuneMemMode","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainOpenGraphicsFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainPMSuspendedDiskReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainPMSuspendedReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainPausedReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainProcessSignal","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainPtr","file":"libvirt-domain","type":"virDomain *"},"info":["a virDomainPtr is pointer to a virDomain private structure, this is the type used to reference a domain in the API."]},{"$":{"name":"virDomainRebootFlagValues","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainRunningReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainSaveRestoreFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainSetTimeFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainSetUserPasswordFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainShutdownFlagValues","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainShutdownReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainShutoffReason","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainSnapshotCreateFlags","file":"libvirt-domain-snapshot","type":"enum"}},{"$":{"name":"virDomainSnapshotDeleteFlags","file":"libvirt-domain-snapshot","type":"enum"}},{"$":{"name":"virDomainSnapshotListFlags","file":"libvirt-domain-snapshot","type":"enum"}},{"$":{"name":"virDomainSnapshotPtr","file":"libvirt-domain-snapshot","type":"virDomainSnapshot *"},"info":["a virDomainSnapshotPtr is pointer to a virDomainSnapshot private structure, and is the type used to reference a domain snapshot in the API."]},{"$":{"name":"virDomainSnapshotRevertFlags","file":"libvirt-domain-snapshot","type":"enum"}},{"$":{"name":"virDomainState","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainStatsRecordPtr","file":"libvirt-domain","type":"virDomainStatsRecord *"}},{"$":{"name":"virDomainStatsTypes","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainUndefineFlagsValues","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainVcpuFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virDomainXMLFlags","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virErrorDomain","file":"virterror","type":"enum"}},{"$":{"name":"virErrorLevel","file":"virterror","type":"enum"}},{"$":{"name":"virErrorNumber","file":"virterror","type":"enum"}},{"$":{"name":"virErrorPtr","file":"virterror","type":"virError *"}},{"$":{"name":"virEventHandleType","file":"libvirt-event","type":"enum"}},{"$":{"name":"virIPAddrType","file":"libvirt-network","type":"enum"}},{"$":{"name":"virInterfacePtr","file":"libvirt-interface","type":"virInterface *"},"info":["a virInterfacePtr is pointer to a virInterface private structure, this is the type used to reference a virtual interface in the API."]},{"$":{"name":"virInterfaceXMLFlags","file":"libvirt-interface","type":"enum"}},{"$":{"name":"virKeycodeSet","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virMemoryParameterPtr","file":"libvirt-domain","type":"virMemoryParameter *"},"info":["a virMemoryParameterPtr is a pointer to a virMemoryParameter structure. Provided for backwards compatibility; virTypedParameterPtr is the preferred alias since 0.9.2."]},{"$":{"name":"virMemoryParameterType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virNWFilterPtr","file":"libvirt-nwfilter","type":"virNWFilter *"},"info":["a virNWFilterPtr is pointer to a virNWFilter private structure, this is the type used to reference a network filter in the API."]},{"$":{"name":"virNetworkDHCPLeasePtr","file":"libvirt-network","type":"virNetworkDHCPLease *"}},{"$":{"name":"virNetworkEventID","file":"libvirt-network","type":"enum"}},{"$":{"name":"virNetworkEventLifecycleType","file":"libvirt-network","type":"enum"}},{"$":{"name":"virNetworkPtr","file":"libvirt-network","type":"virNetwork *"},"info":["a virNetworkPtr is pointer to a virNetwork private structure, this is the type used to reference a virtual network in the API."]},{"$":{"name":"virNetworkUpdateCommand","file":"libvirt-network","type":"enum"}},{"$":{"name":"virNetworkUpdateFlags","file":"libvirt-network","type":"enum"}},{"$":{"name":"virNetworkUpdateSection","file":"libvirt-network","type":"enum"}},{"$":{"name":"virNetworkXMLFlags","file":"libvirt-network","type":"enum"}},{"$":{"name":"virNodeAllocPagesFlags","file":"libvirt-host","type":"enum"}},{"$":{"name":"virNodeCPUStatsPtr","file":"libvirt-host","type":"virNodeCPUStats *"},"info":["a virNodeCPUStatsPtr is a pointer to a virNodeCPUStats structure."]},{"$":{"name":"virNodeDeviceEventID","file":"libvirt-nodedev","type":"enum"}},{"$":{"name":"virNodeDeviceEventLifecycleType","file":"libvirt-nodedev","type":"enum"}},{"$":{"name":"virNodeDevicePtr","file":"libvirt-nodedev","type":"virNodeDevice *"},"info":["A virNodeDevicePtr is a pointer to a virNodeDevice structure.  Get one via virNodeDeviceLookupByName, or virNodeDeviceCreate.  Be sure to call virNodeDeviceFree when done using a virNodeDevicePtr obtained from any of the above functions to avoid leaking memory."]},{"$":{"name":"virNodeGetCPUStatsAllCPUs","file":"libvirt-host","type":"enum"}},{"$":{"name":"virNodeGetMemoryStatsAllCells","file":"libvirt-host","type":"enum"}},{"$":{"name":"virNodeInfoPtr","file":"libvirt-host","type":"virNodeInfo *"},"info":["a virNodeInfoPtr is a pointer to a virNodeInfo structure."]},{"$":{"name":"virNodeMemoryStatsPtr","file":"libvirt-host","type":"virNodeMemoryStats *"},"info":["a virNodeMemoryStatsPtr is a pointer to a virNodeMemoryStats structure."]},{"$":{"name":"virNodeSuspendTarget","file":"libvirt-host","type":"enum"}},{"$":{"name":"virSchedParameterPtr","file":"libvirt-domain","type":"virSchedParameter *"},"info":["a virSchedParameterPtr is a pointer to a virSchedParameter structure. Provided for backwards compatibility; virTypedParameterPtr is the preferred alias since 0.9.2."]},{"$":{"name":"virSchedParameterType","file":"libvirt-domain","type":"enum"}},{"$":{"name":"virSecretEventID","file":"libvirt-secret","type":"enum"}},{"$":{"name":"virSecretEventLifecycleType","file":"libvirt-secret","type":"enum"}},{"$":{"name":"virSecretPtr","file":"libvirt-secret","type":"virSecret *"}},{"$":{"name":"virSecretUsageType","file":"libvirt-secret","type":"enum"}},{"$":{"name":"virSecurityLabelPtr","file":"libvirt-host","type":"virSecurityLabel *"},"info":["a virSecurityLabelPtr is a pointer to a virSecurityLabel."]},{"$":{"name":"virSecurityModelPtr","file":"libvirt-host","type":"virSecurityModel *"},"info":["a virSecurityModelPtr is a pointer to a virSecurityModel."]},{"$":{"name":"virStoragePoolBuildFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStoragePoolCreateFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStoragePoolDeleteFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStoragePoolEventID","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStoragePoolEventLifecycleType","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStoragePoolInfoPtr","file":"libvirt-storage","type":"virStoragePoolInfo *"}},{"$":{"name":"virStoragePoolPtr","file":"libvirt-storage","type":"virStoragePool *"},"info":["a virStoragePoolPtr is pointer to a virStoragePool private structure, this is the type used to reference a storage pool in the API."]},{"$":{"name":"virStoragePoolState","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolCreateFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolDeleteFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolDownloadFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolInfoFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolInfoPtr","file":"libvirt-storage","type":"virStorageVolInfo *"}},{"$":{"name":"virStorageVolPtr","file":"libvirt-storage","type":"virStorageVol *"},"info":["a virStorageVolPtr is pointer to a virStorageVol private structure, this is the type used to reference a storage volume in the API."]},{"$":{"name":"virStorageVolResizeFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolType","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolUploadFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageVolWipeAlgorithm","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStorageXMLFlags","file":"libvirt-storage","type":"enum"}},{"$":{"name":"virStreamEventType","file":"libvirt-stream","type":"enum"}},{"$":{"name":"virStreamFlags","file":"libvirt-stream","type":"enum"}},{"$":{"name":"virStreamPtr","file":"libvirt-host","type":"virStream *"},"info":["a virStreamPtr is pointer to a virStream private structure, this is the type used to reference a data stream in the API."]},{"$":{"name":"virStreamRecvFlagsValues","file":"libvirt-stream","type":"enum"}},{"$":{"name":"virTypedParameterFlags","file":"libvirt-common","type":"enum"}},{"$":{"name":"virTypedParameterPtr","file":"libvirt-common","type":"virTypedParameter *"},"info":["a pointer to a virTypedParameter structure."]},{"$":{"name":"virTypedParameterType","file":"libvirt-common","type":"enum"}},{"$":{"name":"virVcpuInfoPtr","file":"libvirt-domain","type":"virVcpuInfo *"}},{"$":{"name":"virVcpuState","file":"libvirt-domain","type":"enum"}}],"variable":[{"$":{"name":"virConnectAuthPtrDefault","file":"libvirt-host","type":"virConnectAuthPtr"}}],"function":[{"$":{"name":"virConnCopyLastError","file":"virterror","module":"virerror"},"info":["Copy the content of the last error caught on that connection\n\nThis method is not protected against access from multiple\nthreads. In a multi-threaded application, always use the\nglobal virGetLastError() API which is backed by thread\nlocal storage.\n\nIf the connection object was discovered to be invalid by\nan API call, then the error will be reported against the\nglobal error object.\n\nSince 0.6.0, all errors reported in the per-connection object\nare also duplicated in the global error object. As such an\napplication can always use virGetLastError(). This method\nremains for backwards compatibility.\n\nOne will need to free the result with virResetError()"],"return":[{"$":{"type":"int","info":"0 if no error was found and the error code otherwise and -1 in case of parameter error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"to","type":"virErrorPtr","info":"target to receive the copy"}}]},{"$":{"name":"virConnGetLastError","file":"virterror","module":"virerror"},"info":["Provide a pointer to the last error caught on that connection\n\nThis method is not protected against access from multiple\nthreads. In a multi-threaded application, always use the\nglobal virGetLastError() API which is backed by thread\nlocal storage.\n\nIf the connection object was discovered to be invalid by\nan API call, then the error will be reported against the\nglobal error object.\n\nSince 0.6.0, all errors reported in the per-connection object\nare also duplicated in the global error object. As such an\napplication can always use virGetLastError(). This method\nremains for backwards compatibility."],"return":[{"$":{"type":"virErrorPtr","info":"a pointer to the last error or NULL if none occurred."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnResetLastError","file":"virterror","module":"virerror"},"info":["The error object is kept in thread local storage, so separate\nthreads can safely access this concurrently.\n\nReset the last error caught on that connection"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnSetErrorFunc","file":"virterror","module":"virerror"},"info":["Set a connection error handling function, if @handler is NULL\nit will reset to default which is to pass error back to the global\nlibrary handler."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"userData","type":"void *","info":"pointer to the user data provided in the handler callback"}},{"$":{"name":"handler","type":"virErrorFunc","info":"the function to get called in case of error or NULL"}}]},{"$":{"name":"virConnectBaselineCPU","file":"libvirt-host","module":"libvirt-host"},"info":["Computes the most feature-rich CPU which is compatible with all given\nhost CPUs.\n\nIf @flags includes VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES then libvirt\nwill explicitly list all CPU features that are part of the host CPU,\nwithout this flag features that are part of the CPU model will not be\nlisted.\n\nIf @flags includes VIR_CONNECT_BASELINE_CPU_MIGRATABLE, the resulting\nCPU will not include features that block migration."],"return":[{"$":{"type":"char *","info":"XML description of the computed CPU (caller frees) or NULL on error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}},{"$":{"name":"xmlCPUs","type":"const char **","info":"array of XML descriptions of host CPUs"}},{"$":{"name":"ncpus","type":"unsigned int","info":"number of CPUs in xmlCPUs"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectBaselineCPUFlags"}}]},{"$":{"name":"virConnectClose","file":"libvirt-host","module":"libvirt"},"info":["This function closes the connection to the Hypervisor. This should\nnot be called if further interaction with the Hypervisor are needed\nespecially if there is running domain which need further monitoring by\nthe application.\n\nConnections are reference counted; the count is explicitly\nincreased by the initial open (virConnectOpen, virConnectOpenAuth,\nand the like) as well as virConnectRef; it is also temporarily\nincreased by other API that depend on the connection remaining\nalive.  The open and every virConnectRef call should have a\nmatching virConnectClose, and all other references will be released\nafter the corresponding operation completes."],"return":[{"$":{"type":"int","info":"a positive number if at least 1 reference remains on success. The returned value should not be assumed to be the total reference count. A return of 0 implies no references remain and the connection is closed and memory has been freed. A return of -1 implies a failure.  It is possible for the last virConnectClose to return a positive value if some other object still has a temporary reference to the connection, but the application should not try to further use a connection after the virConnectClose that matches the initial open."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectCompareCPU","file":"libvirt-host","module":"libvirt-host"},"info":["Compares the given CPU description with the host CPU"],"return":[{"$":{"type":"int","info":"comparison result according to enum virCPUCompareResult. If VIR_CONNECT_COMPARE_CPU_FAIL_INCOMPATIBLE is used and @xmlDesc CPU is incompatible with host CPU, this function will return VIR_CPU_COMPARE_ERROR (instead of VIR_CPU_COMPARE_INCOMPATIBLE) and the error will use the VIR_ERR_CPU_INCOMPATIBLE code with a message providing more details about the incompatibility."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"XML describing the CPU to compare with host CPU"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectCompareCPUFlags"}}]},{"$":{"name":"virConnectDomainEventDeregister","file":"libvirt-domain","module":"libvirt-domain"},"info":["Removes a callback previously registered with the\nvirConnectDomainEventRegister() function.\n\nUse of this method is no longer recommended. Instead applications\nshould try virConnectDomainEventDeregisterAny() which has a more flexible\nAPI contract"],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure.  Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"cb","type":"virConnectDomainEventCallback","info":"callback to the function handling domain events"}}]},{"$":{"name":"virConnectDomainEventDeregisterAny","file":"libvirt-domain","module":"libvirt-domain"},"info":["Removes an event callback. The callbackID parameter should be the\nvalue obtained from a previous virConnectDomainEventRegisterAny() method."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure.  Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"callbackID","type":"int","info":"the callback identifier"}}]},{"$":{"name":"virConnectDomainEventRegister","file":"libvirt-domain","module":"libvirt-domain"},"info":["Adds a callback to receive notifications of domain lifecycle events\noccurring on a connection.  This function requires that an event loop\nhas been previously registered with virEventRegisterImpl() or\nvirEventRegisterDefaultImpl().\n\nUse of this method is no longer recommended. Instead applications\nshould try virConnectDomainEventRegisterAny() which has a more flexible\nAPI contract.\n\nThe virDomainPtr object handle passed into the callback upon delivery\nof an event is only valid for the duration of execution of the callback.\nIf the callback wishes to keep the domain object after the callback returns,\nit shall take a reference to it, by calling virDomainRef.\nThe reference can be released once the object is no longer required\nby calling virDomainFree."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure.  Older versions of some hypervisors sometimes returned a positive number on success, but without any reliable semantics on what that number represents."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"cb","type":"virConnectDomainEventCallback","info":"callback to the function handling domain events"}},{"$":{"name":"opaque","type":"void *","info":"opaque data to pass on to the callback"}},{"$":{"name":"freecb","type":"virFreeCallback","info":"optional function to deallocate opaque when not used anymore"}}]},{"$":{"name":"virConnectDomainEventRegisterAny","file":"libvirt-domain","module":"libvirt-domain"},"info":["Adds a callback to receive notifications of arbitrary domain events\noccurring on a domain.  This function requires that an event loop\nhas been previously registered with virEventRegisterImpl() or\nvirEventRegisterDefaultImpl().\n\nIf @dom is NULL, then events will be monitored for any domain. If @dom\nis non-NULL, then only the specific domain will be monitored.\n\nMost types of event have a callback providing a custom set of parameters\nfor the event. When registering an event, it is thus necessary to use\nthe VIR_DOMAIN_EVENT_CALLBACK() macro to cast the supplied function pointer\nto match the signature of this method.\n\nThe virDomainPtr object handle passed into the callback upon delivery\nof an event is only valid for the duration of execution of the callback.\nIf the callback wishes to keep the domain object after the callback returns,\nit shall take a reference to it, by calling virDomainRef().\nThe reference can be released once the object is no longer required\nby calling virDomainFree().\n\nThe return value from this method is a positive integer identifier\nfor the callback. To unregister a callback, this callback ID should\nbe passed to the virConnectDomainEventDeregisterAny() method."],"return":[{"$":{"type":"int","info":"a callback identifier on success, -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain"}},{"$":{"name":"eventID","type":"int","info":"the event type to receive"}},{"$":{"name":"cb","type":"virConnectDomainEventGenericCallback","info":"callback to the function handling domain events"}},{"$":{"name":"opaque","type":"void *","info":"opaque data to pass on to the callback"}},{"$":{"name":"freecb","type":"virFreeCallback","info":"optional function to deallocate opaque when not used anymore"}}]},{"$":{"name":"virConnectDomainXMLFromNative","file":"libvirt-domain","module":"libvirt-domain"},"info":["Reads native configuration data  describing a domain, and\ngenerates libvirt domain XML. The format of the native\ndata is hypervisor dependent."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"a connection object"}},{"$":{"name":"nativeFormat","type":"const char *","info":"configuration format importing from"}},{"$":{"name":"nativeConfig","type":"const char *","info":"the configuration data to import"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virConnectDomainXMLToNative","file":"libvirt-domain","module":"libvirt-domain"},"info":["Reads a domain XML configuration document, and generates\na native configuration file describing the domain.\nThe format of the native data is hypervisor dependent."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded native config datafile, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"a connection object"}},{"$":{"name":"nativeFormat","type":"const char *","info":"configuration format exporting to"}},{"$":{"name":"domainXml","type":"const char *","info":"the domain configuration to export"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virConnectFindStoragePoolSources","file":"libvirt-storage","module":"libvirt-storage"},"info":["Talks to a storage backend and attempts to auto-discover the set of\navailable storage pool sources. e.g. For iSCSI this would be a set of\niSCSI targets. For NFS this would be a list of exported paths.  The\nsrcSpec (optional for some storage pool types, e.g. local ones) is\nan instance of the storage pool's source element specifying where\nto look for the pools.\n\nsrcSpec is not required for some types (e.g., those querying\nlocal storage resources only)"],"return":[{"$":{"type":"char *","info":"an xml document consisting of a SourceList element containing a source document appropriate to the given pool type for each discovered source."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"type","type":"const char *","info":"type of storage pool sources to discover"}},{"$":{"name":"srcSpec","type":"const char *","info":"XML document specifying discovery source"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virConnectGetAllDomainStats","file":"libvirt-domain","module":"libvirt-domain"},"info":["Query statistics for all domains on a given connection.\n\nReport statistics of various parameters for a running VM according to @stats\nfield. The statistics are returned as an array of structures for each queried\ndomain. The structure contains an array of typed parameters containing the\nindividual statistics. The typed parameter name for each statistic field\nconsists of a dot-separated string containing name of the requested group\nfollowed by a group specific description of the statistic value.\n\nThe statistic groups are enabled using the @stats parameter which is a\nbinary-OR of enum virDomainStatsTypes. The following groups are available\n(although not necessarily implemented for each hypervisor):\n\nVIR_DOMAIN_STATS_STATE:\n    Return domain state and reason for entering that state. The typed\n    parameter keys are in this format:\n\n    \"state.state\" - state of the VM, returned as int from virDomainState enum\n    \"state.reason\" - reason for entering given state, returned as int from\n                     virDomain*Reason enum corresponding to given state.\n\nVIR_DOMAIN_STATS_CPU_TOTAL:\n    Return CPU statistics and usage information. The typed parameter keys\n    are in this format:\n\n    \"cpu.time\" - total cpu time spent for this domain in nanoseconds\n                 as unsigned long long.\n    \"cpu.user\" - user cpu time spent in nanoseconds as unsigned long long.\n    \"cpu.system\" - system cpu time spent in nanoseconds as unsigned long\n                   long.\n\nVIR_DOMAIN_STATS_BALLOON:\n    Return memory balloon device information.\n    The typed parameter keys are in this format:\n\n    \"balloon.current\" - the memory in kiB currently used\n                        as unsigned long long.\n    \"balloon.maximum\" - the maximum memory in kiB allowed\n                        as unsigned long long.\n\nVIR_DOMAIN_STATS_VCPU:\n    Return virtual CPU statistics.\n    Due to VCPU hotplug, the vcpu.<num>.* array could be sparse.\n    The actual size of the array corresponds to \"vcpu.current\".\n    The array size will never exceed \"vcpu.maximum\".\n    The typed parameter keys are in this format:\n\n    \"vcpu.current\" - current number of online virtual CPUs as unsigned int.\n    \"vcpu.maximum\" - maximum number of online virtual CPUs as unsigned int.\n    \"vcpu.<num>.state\" - state of the virtual CPU <num>, as int\n                         from virVcpuState enum.\n    \"vcpu.<num>.time\" - virtual cpu time spent by virtual CPU <num>\n                        as unsigned long long.\n\nVIR_DOMAIN_STATS_INTERFACE:\n    Return network interface statistics (from domain point of view).\n    The typed parameter keys are in this format:\n\n    \"net.count\" - number of network interfaces on this domain\n                  as unsigned int.\n    \"net.<num>.name\" - name of the interface <num> as string.\n    \"net.<num>.rx.bytes\" - bytes received as unsigned long long.\n    \"net.<num>.rx.pkts\" - packets received as unsigned long long.\n    \"net.<num>.rx.errs\" - receive errors as unsigned long long.\n    \"net.<num>.rx.drop\" - receive packets dropped as unsigned long long.\n    \"net.<num>.tx.bytes\" - bytes transmitted as unsigned long long.\n    \"net.<num>.tx.pkts\" - packets transmitted as unsigned long long.\n    \"net.<num>.tx.errs\" - transmission errors as unsigned long long.\n    \"net.<num>.tx.drop\" - transmit packets dropped as unsigned long long.\n\nVIR_DOMAIN_STATS_BLOCK:\n    Return block devices statistics.  By default,\n    this information is limited to the active layer of each <disk> of the\n    domain (where block.count is equal to the number of disks), but adding\n    VIR_CONNECT_GET_ALL_DOMAINS_STATS_BACKING to @flags will expand the\n    array to cover backing chains (block.count corresponds to the number\n    of host resources used together to provide the guest disks).\n    The typed parameter keys are in this format:\n\n    \"block.count\" - number of block devices in the subsequent list,\n                    as unsigned int.\n    \"block.<num>.name\" - name of the block device <num> as string.\n                         matches the target name (vda/sda/hda) of the\n                         block device.  If the backing chain is listed,\n                         this name is the same for all host resources tied\n                         to the same guest device.\n    \"block.<num>.backingIndex\" - unsigned int giving the <backingStore>\n                                  index, only used when backing images\n                                  are listed.\n    \"block.<num>.path\" - string describing the source of block device <num>,\n                         if it is a file or block device (omitted for network\n                         sources and drives with no media inserted).\n    \"block.<num>.rd.reqs\" - number of read requests as unsigned long long.\n    \"block.<num>.rd.bytes\" - number of read bytes as unsigned long long.\n    \"block.<num>.rd.times\" - total time (ns) spent on reads as\n                             unsigned long long.\n    \"block.<num>.wr.reqs\" - number of write requests as unsigned long long.\n    \"block.<num>.wr.bytes\" - number of written bytes as unsigned long long.\n    \"block.<num>.wr.times\" - total time (ns) spent on writes as\n                             unsigned long long.\n    \"block.<num>.fl.reqs\" - total flush requests as unsigned long long.\n    \"block.<num>.fl.times\" - total time (ns) spent on cache flushing as\n                             unsigned long long.\n    \"block.<num>.errors\" - Xen only: the 'oo_req' value as\n                           unsigned long long.\n    \"block.<num>.allocation\" - offset of the highest written sector\n                               as unsigned long long.\n    \"block.<num>.capacity\" - logical size in bytes of the block device\n                             backing image as unsigned long long.\n    \"block.<num>.physical\" - physical size in bytes of the container of the\n                             backing image as unsigned long long.\n    \"block.<num>.threshold\" - current threshold for delivering the\n                              VIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD\n                              event in bytes. See virDomainSetBlockThreshold.\n\nVIR_DOMAIN_STATS_PERF:\n    Return perf event statistics.\n    The typed parameter keys are in this format:\n\n    \"perf.cmt\" - the usage of l3 cache (bytes) by applications running on\n                 the platform as unsigned long long. It is produced by cmt\n                 perf event.\n    \"perf.mbmt\" - the total system bandwidth (bytes/s) from one level of\n                  cache to another as unsigned long long. It is produced\n                  by mbmt perf event.\n    \"perf.mbml\" - the amount of data (bytes/s) sent through the memory\n                  controller on the socket as unsigned long long. It is\n                  produced by mbml perf event.\n    \"perf.cache_misses\" - the count of cache misses as unsigned long long.\n                          It is produced by cache_misses perf event.\n    \"perf.cache_references\" - the count of cache hits as unsigned long long.\n                              It is produced by cache_references perf event.\n    \"perf.instructions\" - The count of instructions as unsigned long long.\n                          It is produced by instructions perf event.\n    \"perf.cpu_cycles\" - The count of cpu cycles (total/elapsed) as an\n                        unsigned long long. It is produced by cpu_cycles\n                        perf event.\n    \"perf.branch_instructions\" - The count of branch instructions as\n                                 unsigned long long. It is produced by\n                                 branch_instructions perf event.\n    \"perf.branch_misses\" - The count of branch misses as unsigned long\n                           long. It is produced by branch_misses perf event.\n    \"perf.bus_cycles\" - The count of bus cycles as unsigned long\n                        long. It is produced by bus_cycles perf event.\n    \"perf.stalled_cycles_frontend\" - The count of stalled cpu cycles in the\n                                     frontend of the instruction processor\n                                     pipeline as unsigned long long. It is\n                                     produced by stalled_cycles_frontend\n                                     perf event.\n    \"perf.stalled_cycles_backend\"  - The count of stalled cpu cycles in the\n                                     backend of the instruction processor\n                                     pipeline as unsigned long long. It is\n                                     produced by stalled_cycles_backend\n                                     perf event.\n    \"perf.ref_cpu_cycles\" - The count of total cpu cycles not affected by\n                            CPU frequency scaling by applications running\n                            as unsigned long long. It is produced by the\n                            ref_cpu_cycles perf event.\n    \"perf.cpu_clock\" - The count of cpu clock time as unsigned long long.\n                       It is produced by the cpu_clock perf event.\n    \"perf.task_clock\" - The count of task clock time as unsigned long long.\n                        It is produced by the task_clock perf event.\n    \"perf.page_faults\" - The count of page faults as unsigned long long.\n                         It is produced by the page_faults perf event\n    \"perf.context_switches\" - The count of context switches as unsigned long\n                              long. It is produced by the context_switches\n                              perf event.\n    \"perf.cpu_migrations\" - The count of cpu migrations, from one logical\n                            processor to another, as unsigned long\n                            long. It is produced by the cpu_migrations\n                            perf event.\n    \"perf.page_faults_min\" - The count of minor page faults as unsigned\n                             long long. It is produced by the\n                             page_faults_min perf event.\n    \"perf.page_faults_maj\" - The count of major page faults as unsigned\n                             long long. It is produced by the\n                             page_faults_maj perf event.\n    \"perf.alignment_faults\" - The count of alignment faults as unsigned\n                              long long. It is produced by the\n                              alignment_faults perf event\n    \"perf.emulation_faults\" - The count of emulation faults as unsigned\n                              long long. It is produced by the\n                              emulation_faults perf event\n\nNote that entire stats groups or individual stat fields may be missing from\nthe output in case they are not supported by the given hypervisor, are not\napplicable for the current state of the guest domain, or their retrieval\nwas not successful.\n\nUsing 0 for @stats returns all stats groups supported by the given\nhypervisor.\n\nSpecifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes\nthe function return error in case some of the stat types in @stats were\nnot recognized by the daemon.  However, even with this flag, a hypervisor\nmay omit individual fields within a known group if the information is not\navailable; as an extreme example, a supported group may produce zero\nfields for offline domains if the statistics are meaningful only for a\nrunning domain.\n\nSimilarly to virConnectListAllDomains, @flags can contain various flags to\nfilter the list of domains to provide stats for.\n\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_ACTIVE selects online domains while\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_INACTIVE selects offline ones.\n\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_PERSISTENT and\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_TRANSIENT allow to filter the list\naccording to their persistence.\n\nTo filter the list of VMs by domain state @flags can contain\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_RUNNING,\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_PAUSED,\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_SHUTOFF and/or\nVIR_CONNECT_GET_ALL_DOMAINS_STATS_OTHER for all other states."],"return":[{"$":{"type":"int","info":"the count of returned statistics structures on success, -1 on error. The requested data are returned in the @retStats parameter. The returned array should be freed by the caller. See virDomainStatsRecordListFree."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"stats","type":"unsigned int","info":"stats to return, binary-OR of virDomainStatsTypes"}},{"$":{"name":"retStats","type":"virDomainStatsRecordPtr **","info":"Pointer that will be filled with the array of returned stats"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; binary-OR of virConnectGetAllDomainStatsFlags"}}]},{"$":{"name":"virConnectGetCPUModelNames","file":"libvirt-host","module":"libvirt-host"},"info":["Get the list of supported CPU models for a specific architecture."],"return":[{"$":{"type":"int","info":"-1 on error, number of elements in @models on success (0 means libvirt accepts any CPU model)."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}},{"$":{"name":"arch","type":"const char *","info":"Architecture"}},{"$":{"name":"models","type":"char ** *","info":"Pointer to a variable to store the NULL-terminated array of the CPU models supported for the specified architecture.  Each element and the array itself must be freed by the caller with free.  Pass NULL if only the list length is needed."}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0."}}]},{"$":{"name":"virConnectGetCapabilities","file":"libvirt-host","module":"libvirt-host"},"info":["Provides capabilities of the hypervisor / driver."],"return":[{"$":{"type":"char *","info":"NULL in case of error, or an XML string defining the capabilities. The client must free the returned string after use."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectGetDomainCapabilities","file":"libvirt-domain","module":"libvirt-domain"},"info":["Prior creating a domain (for instance via virDomainCreateXML\nor virDomainDefineXML) it may be suitable to know what the\nunderlying emulator and/or libvirt is capable of. For\ninstance, if host, libvirt and qemu is capable of VFIO\npassthrough and so on."],"return":[{"$":{"type":"char *","info":"NULL in case of error or an XML string defining the capabilities."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"emulatorbin","type":"const char *","info":"path to emulator"}},{"$":{"name":"arch","type":"const char *","info":"domain architecture"}},{"$":{"name":"machine","type":"const char *","info":"machine type"}},{"$":{"name":"virttype","type":"const char *","info":"virtualization type"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virConnectGetHostname","file":"libvirt-host","module":"libvirt-host"},"info":["This returns a system hostname on which the hypervisor is\nrunning (based on the result of the gethostname system call, but\npossibly expanded to a fully-qualified domain name via getaddrinfo).\nIf we are connected to a remote system, then this returns the\nhostname of the remote system."],"return":[{"$":{"type":"char *","info":"the hostname which must be freed by the caller, or NULL if there was an error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to a hypervisor connection"}}]},{"$":{"name":"virConnectGetLibVersion","file":"libvirt-host","module":"libvirt-host"},"info":["Provides @libVer, which is the version of libvirt used by the\n  daemon running on the @conn host"],"return":[{"$":{"type":"int","info":"-1 in case of failure, 0 otherwise, and values for @libVer have the format major * 1,000,000 + minor * 1,000 + release."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"libVer","type":"unsigned long *","info":"returns the libvirt library version used on the connection (OUT)"}}]},{"$":{"name":"virConnectGetMaxVcpus","file":"libvirt-host","module":"libvirt-host"},"info":["Provides the maximum number of virtual CPUs supported for a guest VM of a\nspecific type. The 'type' parameter here corresponds to the 'type'\nattribute in the <domain> element of the XML. This API doesn't take emulator\nlimits into consideration, hence the returned value is not guaranteed to be\nusable. It is recommended to use virConnectGetDomainCapabilities() and look\nfor \"<vcpu max='...'>\" in its output instead."],"return":[{"$":{"type":"int","info":"the maximum of virtual CPU or -1 in case of error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"type","type":"const char *","info":"value of the 'type' attribute in the <domain> element"}}]},{"$":{"name":"virConnectGetSysinfo","file":"libvirt-host","module":"libvirt-host"},"info":["This returns the XML description of the sysinfo details for the\nhost on which the hypervisor is running, in the same format as the\n<sysinfo> element of a domain XML.  This information is generally\navailable only for hypervisors running with root privileges."],"return":[{"$":{"type":"char *","info":"the XML string which must be freed by the caller, or NULL if there was an error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to a hypervisor connection"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virConnectGetType","file":"libvirt-host","module":"libvirt-host"},"info":["Get the name of the Hypervisor driver used. This is merely the driver\nname; for example, both KVM and QEMU guests are serviced by the\ndriver for the qemu:// URI, so a return of \"QEMU\" does not indicate\nwhether KVM acceleration is present.  For more details about the\nhypervisor, use virConnectGetCapabilities()."],"return":[{"$":{"type":"const char *","info":"NULL in case of error, a static zero terminated string otherwise.  See also: http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectGetURI","file":"libvirt-host","module":"libvirt-host"},"info":["This returns the URI (name) of the hypervisor connection.\nNormally this is the same as or similar to the string passed\nto the virConnectOpen/virConnectOpenReadOnly call, but\nthe driver may make the URI canonical.  If name == NULL\nwas passed to virConnectOpen, then the driver will return\na non-NULL URI which can be used to connect to the same\nhypervisor later."],"return":[{"$":{"type":"char *","info":"the URI string which must be freed by the caller, or NULL if there was an error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to a hypervisor connection"}}]},{"$":{"name":"virConnectGetVersion","file":"libvirt-host","module":"libvirt-host"},"info":["Get the version level of the Hypervisor running. This may work only with\nhypervisor call, i.e. with privileged access to the hypervisor, not\nwith a Read-Only connection."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 otherwise. if the version can't be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"hvVer","type":"unsigned long *","info":"return value for the version of the running hypervisor (OUT)"}}]},{"$":{"name":"virConnectIsAlive","file":"libvirt-host","module":"libvirt-host"},"info":["Determine if the connection to the hypervisor is still alive\n\nA connection will be classed as alive if it is either local, or running\nover a channel (TCP or UNIX socket) which is not closed."],"return":[{"$":{"type":"int","info":"1 if alive, 0 if dead, -1 on error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection object"}}]},{"$":{"name":"virConnectIsEncrypted","file":"libvirt-host","module":"libvirt-host"},"info":["Determine if the connection to the hypervisor is encrypted"],"return":[{"$":{"type":"int","info":"1 if encrypted, 0 if not encrypted, -1 on error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection object"}}]},{"$":{"name":"virConnectIsSecure","file":"libvirt-host","module":"libvirt-host"},"info":["Determine if the connection to the hypervisor is secure\n\nA connection will be classed as secure if it is either\nencrypted, or running over a channel which is not exposed\nto eavesdropping (eg a UNIX domain socket, or pipe)"],"return":[{"$":{"type":"int","info":"1 if secure, 0 if not secure, -1 on error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection object"}}]},{"$":{"name":"virConnectListAllDomains","file":"libvirt-domain","module":"libvirt-domain"},"info":["Collect a possibly-filtered list of all domains, and return an allocated\narray of information for each.  This API solves the race inherent in\nvirConnectListDomains() and virConnectListDefinedDomains().\n\nNormally, all domains are returned; however, @flags can be used to\nfilter the results for a smaller list of targeted domains.  The valid\nflags are divided into groups, where each group contains bits that\ndescribe mutually exclusive attributes of a domain, and where all bits\nwithin a group describe all possible domains.  Some hypervisors might\nreject explicit bits from a group where the hypervisor cannot make a\ndistinction (for example, not all hypervisors can tell whether domains\nhave snapshots).  For a group supported by a given hypervisor, the\nbehavior when no bits of a group are set is identical to the behavior\nwhen all bits in that group are set.  When setting bits from more than\none group, it is possible to select an impossible combination (such\nas an inactive transient domain), in that case a hypervisor may return\neither 0 or an error.\n\nThe first group of @flags is VIR_CONNECT_LIST_DOMAINS_ACTIVE (online\ndomains) and VIR_CONNECT_LIST_DOMAINS_INACTIVE (offline domains).\n\nThe next group of @flags is VIR_CONNECT_LIST_DOMAINS_PERSISTENT (defined\ndomains) and VIR_CONNECT_LIST_DOMAINS_TRANSIENT (running but not defined).\n\nThe next group of @flags covers various domain states:\nVIR_CONNECT_LIST_DOMAINS_RUNNING, VIR_CONNECT_LIST_DOMAINS_PAUSED,\nVIR_CONNECT_LIST_DOMAINS_SHUTOFF, and a catch-all for all other states\n(such as crashed, this catch-all covers the possibility of adding new\nstates).\n\nThe remaining groups cover boolean attributes commonly asked about\ndomains; they include VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE and\nVIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE, for filtering based on whether\na managed save image exists; VIR_CONNECT_LIST_DOMAINS_AUTOSTART and\nVIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART, for filtering based on autostart;\nVIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT and\nVIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT, for filtering based on whether\na domain has snapshots.\n\nExample of usage:\n\n  virDomainPtr *domains;\n  size_t i;\n  int ret;\n  unsigned int flags = VIR_CONNECT_LIST_DOMAINS_RUNNING |\n                       VIR_CONNECT_LIST_DOMAINS_PERSISTENT;\n  ret = virConnectListAllDomains(conn, &domains, flags);\n  if (ret < 0)\n      error();\n  for (i = 0; i < ret; i++) {\n       do_something_with_domain(domains[i]);\n       //here or in a separate loop if needed\n       virDomainFree(domains[i]);\n  }\n  free(domains);"],"return":[{"$":{"type":"int","info":"the number of domains found or -1 and sets domains to NULL in case of error.  On success, the array stored into @domains is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virDomainFree() on each array element, then calling free() on @domains."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"Pointer to the hypervisor connection."}},{"$":{"name":"domains","type":"virDomainPtr **","info":"Pointer to a variable to store the array containing domain objects or NULL if the list is not required (just returns number of guests)."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectListAllDomainsFlags"}}]},{"$":{"name":"virConnectListAllInterfaces","file":"libvirt-interface","module":"libvirt-interface"},"info":["Collect the list of interfaces, and allocate an array to store those\nobjects. This API solves the race inherent between virConnectListInterfaces\nand virConnectListDefinedInterfaces.\n\nNormally, all interfaces are returned; however, @flags can be used to\nfilter the results for a smaller list of targeted interfaces.  The valid\nflags are divided into groups, where each group contains bits that\ndescribe mutually exclusive attributes of a interface, and where all bits\nwithin a group describe all possible interfaces.\n\nThe only group of @flags is VIR_CONNECT_LIST_INTERFACES_ACTIVE (up) and\nVIR_CONNECT_LIST_INTERFACES_INACTIVE (down) to filter the interfaces by state."],"return":[{"$":{"type":"int","info":"the number of interfaces found or -1 and sets @ifaces to  NULL in case of error.  On success, the array stored into @ifaces is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virStorageInterfaceFree() on each array element, then calling free() on @ifaces."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"Pointer to the hypervisor connection."}},{"$":{"name":"ifaces","type":"virInterfacePtr **","info":"Pointer to a variable to store the array containing the interface objects or NULL if the list is not required (just returns number of interfaces)."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectListAllInterfacesFlags."}}]},{"$":{"name":"virConnectListAllNWFilters","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Collect the list of network filters, and allocate an array to store those\nobjects."],"return":[{"$":{"type":"int","info":"the number of network filters found or -1 and sets @filters to  NULL in case of error.  On success, the array stored into @filters is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNWFilterFree() on each array element, then calling free() on @filters."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"Pointer to the hypervisor connection."}},{"$":{"name":"filters","type":"virNWFilterPtr **","info":"Pointer to a variable to store the array containing the network filter objects or NULL if the list is not required (just returns number of network filters)."}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virConnectListAllNetworks","file":"libvirt-network","module":"libvirt-network"},"info":["Collect the list of networks, and allocate an array to store those\nobjects. This API solves the race inherent between virConnectListNetworks\nand virConnectListDefinedNetworks.\n\nNormally, all networks are returned; however, @flags can be used to\nfilter the results for a smaller list of targeted networks.  The valid\nflags are divided into groups, where each group contains bits that\ndescribe mutually exclusive attributes of a network, and where all bits\nwithin a group describe all possible networks.\n\nThe first group of @flags is VIR_CONNECT_LIST_NETWORKS_ACTIVE (up) and\nVIR_CONNECT_LIST_NETWORKS_INACTIVE (down) to filter the networks by state.\n\nThe second group of @flags is VIR_CONNECT_LIST_NETWORKS_PERSISTENT (defined)\nand VIR_CONNECT_LIST_NETWORKS_TRANSIENT (running but not defined), to filter\nthe networks by whether they have persistent config or not.\n\nThe third group of @flags is VIR_CONNECT_LIST_NETWORKS_AUTOSTART\nand VIR_CONNECT_LIST_NETWORKS_NO_AUTOSTART, to filter the networks by\nwhether they are marked as autostart or not."],"return":[{"$":{"type":"int","info":"the number of networks found or -1 and sets @nets to  NULL in case of error.  On success, the array stored into @nets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNetworkFree() on each array element, then calling free() on @nets."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"Pointer to the hypervisor connection."}},{"$":{"name":"nets","type":"virNetworkPtr **","info":"Pointer to a variable to store the array containing the network objects or NULL if the list is not required (just returns number of networks)."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectListAllNetworksFlags."}}]},{"$":{"name":"virConnectListAllNodeDevices","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Collect the list of node devices, and allocate an array to store those\nobjects.\n\nNormally, all node devices are returned; however, @flags can be used to\nfilter the results for a smaller list of targeted node devices.  The valid\nflags are divided into groups, where each group contains bits that\ndescribe mutually exclusive attributes of a node device, and where all bits\nwithin a group describe all possible node devices.\n\nOnly one group of the @flags is provided to filter the node devices by\ncapability type, flags include:\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SYSTEM\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_PCI_DEV\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_DEV\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_USB_INTERFACE\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_NET\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_HOST\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_TARGET\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_STORAGE\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_FC_HOST\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_VPORTS\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_SCSI_GENERIC\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_DRM\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV_TYPES\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_MDEV\n  VIR_CONNECT_LIST_NODE_DEVICES_CAP_CCW_DEV"],"return":[{"$":{"type":"int","info":"the number of node devices found or -1 and sets @devices to NULL in case of error.  On success, the array stored into @devices is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virNodeDeviceFree() on each array element, then calling free() on @devices."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"Pointer to the hypervisor connection."}},{"$":{"name":"devices","type":"virNodeDevicePtr **","info":"Pointer to a variable to store the array containing the node device objects or NULL if the list is not required (just returns number of node devices)."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectListAllNodeDeviceFlags."}}]},{"$":{"name":"virConnectListAllSecrets","file":"libvirt-secret","module":"libvirt-secret"},"info":["Collect the list of secrets, and allocate an array to store those\nobjects.\n\nNormally, all secrets are returned; however, @flags can be used to\nfilter the results for a smaller list of targeted secrets. The valid\nflags are divided into groups, where each group contains bits that\ndescribe mutually exclusive attributes of a secret, and where all bits\nwithin a group describe all possible secrets.\n\nThe first group of @flags is used to filter secrets by its storage\nlocation. Flag VIR_CONNECT_LIST_SECRETS_EPHEMERAL selects secrets that\nare kept only in memory. Flag VIR_CONNECT_LIST_SECRETS_NO_EPHEMERAL\nselects secrets that are kept in persistent storage.\n\nThe second group of @flags is used to filter secrets by privacy. Flag\nVIR_CONNECT_LIST_SECRETS_PRIVATE selects secrets that are never revealed\nto any caller of libvirt nor to any other node. Flag\nVIR_CONNECT_LIST_SECRETS_NO_PRIVATE selects non-private secrets."],"return":[{"$":{"type":"int","info":"the number of secrets found or -1 and sets @secrets to NULL in case of error.  On success, the array stored into @secrets is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virSecretFree() on each array element, then calling free() on @secrets."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"Pointer to the hypervisor connection."}},{"$":{"name":"secrets","type":"virSecretPtr **","info":"Pointer to a variable to store the array containing the secret objects or NULL if the list is not required (just returns the number of secrets)."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectListAllSecretsFlags."}}]},{"$":{"name":"virConnectListAllStoragePools","file":"libvirt-storage","module":"libvirt-storage"},"info":["Collect the list of storage pools, and allocate an array to store those\nobjects. This API solves the race inherent between\nvirConnectListStoragePools and virConnectListDefinedStoragePools.\n\nNormally, all storage pools are returned; however, @flags can be used to\nfilter the results for a smaller list of targeted pools.  The valid\nflags are divided into groups, where each group contains bits that\ndescribe mutually exclusive attributes of a pool, and where all bits\nwithin a group describe all possible pools.\n\nThe first group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_ACTIVE (online)\nand VIR_CONNECT_LIST_STORAGE_POOLS_INACTIVE (offline) to filter the pools\nby state.\n\nThe second group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_PERSITENT\n(defined) and VIR_CONNECT_LIST_STORAGE_POOLS_TRANSIENT (running but not\ndefined), to filter the pools by whether they have persistent config or not.\n\nThe third group of @flags is VIR_CONNECT_LIST_STORAGE_POOLS_AUTOSTART\nand VIR_CONNECT_LIST_STORAGE_POOLS_NO_AUTOSTART, to filter the pools by\nwhether they are marked as autostart or not.\n\nThe last group of @flags is provided to filter the pools by the types,\nthe flags include:\nVIR_CONNECT_LIST_STORAGE_POOLS_DIR\nVIR_CONNECT_LIST_STORAGE_POOLS_FS\nVIR_CONNECT_LIST_STORAGE_POOLS_NETFS\nVIR_CONNECT_LIST_STORAGE_POOLS_LOGICAL\nVIR_CONNECT_LIST_STORAGE_POOLS_DISK\nVIR_CONNECT_LIST_STORAGE_POOLS_ISCSI\nVIR_CONNECT_LIST_STORAGE_POOLS_SCSI\nVIR_CONNECT_LIST_STORAGE_POOLS_MPATH\nVIR_CONNECT_LIST_STORAGE_POOLS_RBD\nVIR_CONNECT_LIST_STORAGE_POOLS_SHEEPDOG"],"return":[{"$":{"type":"int","info":"the number of storage pools found or -1 and sets @pools to NULL in case of error.  On success, the array stored into @pools is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virStoragePoolFree() on each array element, then calling free() on @pools."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"Pointer to the hypervisor connection."}},{"$":{"name":"pools","type":"virStoragePoolPtr **","info":"Pointer to a variable to store the array containing storage pool objects or NULL if the list is not required (just returns number of pools)."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectListAllStoragePoolsFlags."}}]},{"$":{"name":"virConnectListDefinedDomains","file":"libvirt-domain","module":"libvirt-domain"},"info":["list the defined but inactive domains, stores the pointers to the names\nin @names\n\nFor active domains, see virConnectListDomains().  For more control over\nthe results, see virConnectListAllDomains()."],"return":[{"$":{"type":"int","info":"the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a domain can be defined between a call to virConnectNumOfDefinedDomains() and this call; you are only guaranteed that all currently defined domains were listed if the return is less than @maxids.  The client must call free() on each returned name."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"pointer to an array to store the names"}},{"$":{"name":"maxnames","type":"int","info":"size of the array"}}]},{"$":{"name":"virConnectListDefinedInterfaces","file":"libvirt-interface","module":"libvirt-interface"},"info":["Collect the list of defined (inactive) physical host interfaces,\nand store their names in @names.\n\nFor more control over the results, see virConnectListAllInterfaces()."],"return":[{"$":{"type":"int","info":"the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a interface can be defined between a call to virConnectNumOfDefinedInterfaces() and this call; you are only guaranteed that all currently defined interfaces were listed if the return is less than @maxnames.  The client must call free() on each returned name."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"array to collect the list of names of interfaces"}},{"$":{"name":"maxnames","type":"int","info":"size of @names"}}]},{"$":{"name":"virConnectListDefinedNetworks","file":"libvirt-network","module":"libvirt-network"},"info":["list the inactive networks, stores the pointers to the names in @names\n\nFor more control over the results, see virConnectListAllNetworks()."],"return":[{"$":{"type":"int","info":"the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a network can be defined between a call to virConnectNumOfDefinedNetworks() and this call; you are only guaranteed that all currently defined networks were listed if the return is less than @maxnames.  The client must call free() on each returned name."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"pointer to an array to store the names"}},{"$":{"name":"maxnames","type":"int","info":"size of the array"}}]},{"$":{"name":"virConnectListDefinedStoragePools","file":"libvirt-storage","module":"libvirt-storage"},"info":["Provides the list of names of inactive storage pools up to maxnames.\nIf there are more than maxnames, the remaining names will be silently\nignored.\n\nFor more control over the results, see virConnectListAllStoragePools()."],"return":[{"$":{"type":"int","info":"the number of names provided in the array or -1 in case of error. Note that this command is inherently racy; a pool can be defined between a call to virConnectNumOfDefinedStoragePools() and this call; you are only guaranteed that all currently defined pools were listed if the return is less than @maxnames.  The client must call free() on each returned name."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"array of char * to fill with pool names (allocated by caller)"}},{"$":{"name":"maxnames","type":"int","info":"size of the names array"}}]},{"$":{"name":"virConnectListDomains","file":"libvirt-domain","module":"libvirt-domain"},"info":["Collect the list of active domains, and store their IDs in array @ids\n\nFor inactive domains, see virConnectListDefinedDomains().  For more\ncontrol over the results, see virConnectListAllDomains()."],"return":[{"$":{"type":"int","info":"the number of domains found or -1 in case of error.  Note that this command is inherently racy; a domain can be started between a call to virConnectNumOfDomains() and this call; you are only guaranteed that all currently active domains were listed if the return is less than @maxids."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"ids","type":"int *","info":"array to collect the list of IDs of active domains"}},{"$":{"name":"maxids","type":"int","info":"size of @ids"}}]},{"$":{"name":"virConnectListInterfaces","file":"libvirt-interface","module":"libvirt-interface"},"info":["Collect the list of active physical host interfaces,\nand store their names in @names\n\nFor more control over the results, see virConnectListAllInterfaces()."],"return":[{"$":{"type":"int","info":"the number of interfaces found or -1 in case of error.  Note that this command is inherently racy; a interface can be started between a call to virConnectNumOfInterfaces() and this call; you are only guaranteed that all currently active interfaces were listed if the return is less than @maxnames. The client must call free() on each returned name."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"array to collect the list of names of interfaces"}},{"$":{"name":"maxnames","type":"int","info":"size of @names"}}]},{"$":{"name":"virConnectListNWFilters","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Collect the list of network filters, and store their names in @names"],"return":[{"$":{"type":"int","info":"the number of network filters found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"array to collect the list of names of network filters"}},{"$":{"name":"maxnames","type":"int","info":"size of @names"}}]},{"$":{"name":"virConnectListNetworks","file":"libvirt-network","module":"libvirt-network"},"info":["Collect the list of active networks, and store their names in @names\n\nFor more control over the results, see virConnectListAllNetworks()."],"return":[{"$":{"type":"int","info":"the number of networks found or -1 in case of error.  Note that this command is inherently racy; a network can be started between a call to virConnectNumOfNetworks() and this call; you are only guaranteed that all currently active networks were listed if the return is less than @maxnames. The client must call free() on each returned name."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"array to collect the list of names of active networks"}},{"$":{"name":"maxnames","type":"int","info":"size of @names"}}]},{"$":{"name":"virConnectListSecrets","file":"libvirt-secret","module":"libvirt-secret"},"info":["List UUIDs of defined secrets, store pointers to names in uuids."],"return":[{"$":{"type":"int","info":"the number of UUIDs provided in the array, or -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}},{"$":{"name":"uuids","type":"char **","info":"Pointer to an array to store the UUIDs"}},{"$":{"name":"maxuuids","type":"int","info":"size of the array."}}]},{"$":{"name":"virConnectListStoragePools","file":"libvirt-storage","module":"libvirt-storage"},"info":["Provides the list of names of active storage pools up to maxnames.\nIf there are more than maxnames, the remaining names will be silently\nignored.\n\nFor more control over the results, see virConnectListAllStoragePools()."],"return":[{"$":{"type":"int","info":"the number of pools found or -1 in case of error.  Note that this command is inherently racy; a pool can be started between a call to virConnectNumOfStoragePools() and this call; you are only guaranteed that all currently active pools were listed if the return is less than @maxnames. The client must call free() on each returned name."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"names","type":"char ** const","info":"array of char * to fill with pool names (allocated by caller)"}},{"$":{"name":"maxnames","type":"int","info":"size of the names array"}}]},{"$":{"name":"virConnectNetworkEventDeregisterAny","file":"libvirt-network","module":"libvirt-network"},"info":["Removes an event callback. The callbackID parameter should be the\nvalue obtained from a previous virConnectNetworkEventRegisterAny() method."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"callbackID","type":"int","info":"the callback identifier"}}]},{"$":{"name":"virConnectNetworkEventRegisterAny","file":"libvirt-network","module":"libvirt-network"},"info":["Adds a callback to receive notifications of arbitrary network events\noccurring on a network.  This function requires that an event loop\nhas been previously registered with virEventRegisterImpl() or\nvirEventRegisterDefaultImpl().\n\nIf @net is NULL, then events will be monitored for any network. If @net\nis non-NULL, then only the specific network will be monitored.\n\nMost types of event have a callback providing a custom set of parameters\nfor the event. When registering an event, it is thus necessary to use\nthe VIR_NETWORK_EVENT_CALLBACK() macro to cast the supplied function pointer\nto match the signature of this method.\n\nThe virNetworkPtr object handle passed into the callback upon delivery\nof an event is only valid for the duration of execution of the callback.\nIf the callback wishes to keep the network object after the callback\nreturns, it shall take a reference to it, by calling virNetworkRef().\nThe reference can be released once the object is no longer required\nby calling virNetworkFree().\n\nThe return value from this method is a positive integer identifier\nfor the callback. To unregister a callback, this callback ID should\nbe passed to the virConnectNetworkEventDeregisterAny() method."],"return":[{"$":{"type":"int","info":"a callback identifier on success, -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"net","type":"virNetworkPtr","info":"pointer to the network"}},{"$":{"name":"eventID","type":"int","info":"the event type to receive"}},{"$":{"name":"cb","type":"virConnectNetworkEventGenericCallback","info":"callback to the function handling network events"}},{"$":{"name":"opaque","type":"void *","info":"opaque data to pass on to the callback"}},{"$":{"name":"freecb","type":"virFreeCallback","info":"optional function to deallocate opaque when not used anymore"}}]},{"$":{"name":"virConnectNodeDeviceEventDeregisterAny","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Removes an event callback. The callbackID parameter should be the\nvalue obtained from a previous virConnectNodeDeviceEventRegisterAny() method."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"callbackID","type":"int","info":"the callback identifier"}}]},{"$":{"name":"virConnectNodeDeviceEventRegisterAny","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Adds a callback to receive notifications of arbitrary node device events\noccurring on a node device. This function requires that an event loop\nhas been previously registered with virEventRegisterImpl() or\nvirEventRegisterDefaultImpl().\n\nIf @dev is NULL, then events will be monitored for any node device.\nIf @dev is non-NULL, then only the specific node device will be monitored.\n\nMost types of events have a callback providing a custom set of parameters\nfor the event. When registering an event, it is thus necessary to use\nthe VIR_NODE_DEVICE_EVENT_CALLBACK() macro to cast the\nsupplied function pointer to match the signature of this method.\n\nThe virNodeDevicePtr object handle passed into the callback upon delivery\nof an event is only valid for the duration of execution of the callback.\nIf the callback wishes to keep the node device object after the callback\nreturns, it shall take a reference to it, by calling virNodeDeviceRef().\nThe reference can be released once the object is no longer required\nby calling virNodeDeviceFree().\n\nThe return value from this method is a positive integer identifier\nfor the callback. To unregister a callback, this callback ID should\nbe passed to the virConnectNodeDeviceEventDeregisterAny() method."],"return":[{"$":{"type":"int","info":"a callback identifier on success, -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"dev","type":"virNodeDevicePtr","info":"pointer to the node device"}},{"$":{"name":"eventID","type":"int","info":"the event type to receive"}},{"$":{"name":"cb","type":"virConnectNodeDeviceEventGenericCallback","info":"callback to the function handling node device events"}},{"$":{"name":"opaque","type":"void *","info":"opaque data to pass on to the callback"}},{"$":{"name":"freecb","type":"virFreeCallback","info":"optional function to deallocate opaque when not used anymore"}}]},{"$":{"name":"virConnectNumOfDefinedDomains","file":"libvirt-domain","module":"libvirt-domain"},"info":["Provides the number of defined but inactive domains."],"return":[{"$":{"type":"int","info":"the number of domain found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectNumOfDefinedInterfaces","file":"libvirt-interface","module":"libvirt-interface"},"info":["Provides the number of defined (inactive) interfaces on the physical host."],"return":[{"$":{"type":"int","info":"the number of defined interface found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectNumOfDefinedNetworks","file":"libvirt-network","module":"libvirt-network"},"info":["Provides the number of inactive networks."],"return":[{"$":{"type":"int","info":"the number of networks found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectNumOfDefinedStoragePools","file":"libvirt-storage","module":"libvirt-storage"},"info":["Provides the number of inactive storage pools"],"return":[{"$":{"type":"int","info":"the number of pools found, or -1 on error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}}]},{"$":{"name":"virConnectNumOfDomains","file":"libvirt-domain","module":"libvirt-domain"},"info":["Provides the number of active domains."],"return":[{"$":{"type":"int","info":"the number of domain found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectNumOfInterfaces","file":"libvirt-interface","module":"libvirt-interface"},"info":["Provides the number of active interfaces on the physical host."],"return":[{"$":{"type":"int","info":"the number of active interfaces found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectNumOfNWFilters","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Provides the number of nwfilters."],"return":[{"$":{"type":"int","info":"the number of nwfilters found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectNumOfNetworks","file":"libvirt-network","module":"libvirt-network"},"info":["Provides the number of active networks."],"return":[{"$":{"type":"int","info":"the number of network found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virConnectNumOfSecrets","file":"libvirt-secret","module":"libvirt-secret"},"info":["Fetch number of currently defined secrets."],"return":[{"$":{"type":"int","info":"the number currently defined secrets."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}}]},{"$":{"name":"virConnectNumOfStoragePools","file":"libvirt-storage","module":"libvirt-storage"},"info":["Provides the number of active storage pools"],"return":[{"$":{"type":"int","info":"the number of pools found, or -1 on error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}}]},{"$":{"name":"virConnectOpen","file":"libvirt-host","module":"libvirt"},"info":["This function should be called first to get a connection to the\nHypervisor and xen store\n\nIf @name is NULL, if the LIBVIRT_DEFAULT_URI environment variable is set,\nthen it will be used. Otherwise if the client configuration file\nhas the \"uri_default\" parameter set, then it will be used. Finally\nprobing will be done to determine a suitable default driver to activate.\nThis involves trying each hypervisor in turn until one successfully opens.\n\nIf connecting to an unprivileged hypervisor driver which requires\nthe libvirtd daemon to be active, it will automatically be launched\nif not already running. This can be prevented by setting the\nenvironment variable LIBVIRT_AUTOSTART=0\n\nURIs are documented at httsp://libvirt.org/uri.html\n\nvirConnectClose should be used to release the resources after the connection\nis no longer needed."],"return":[{"$":{"type":"virConnectPtr","info":"a pointer to the hypervisor connection or NULL in case of error"}}],"arg":[{"$":{"name":"name","type":"const char *","info":"(optional) URI of the hypervisor"}}]},{"$":{"name":"virConnectOpenAuth","file":"libvirt-host","module":"libvirt"},"info":["This function should be called first to get a connection to the\nHypervisor. If necessary, authentication will be performed fetching\ncredentials via the callback\n\nSee virConnectOpen for notes about environment variables which can\nhave an effect on opening drivers and freeing the connection resources\n\nURIs are documented at https://libvirt.org/uri.html"],"return":[{"$":{"type":"virConnectPtr","info":"a pointer to the hypervisor connection or NULL in case of error"}}],"arg":[{"$":{"name":"name","type":"const char *","info":"(optional) URI of the hypervisor"}},{"$":{"name":"auth","type":"virConnectAuthPtr","info":"Authenticate callback parameters"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virConnectFlags"}}]},{"$":{"name":"virConnectOpenReadOnly","file":"libvirt-host","module":"libvirt"},"info":["This function should be called first to get a restricted connection to the\nlibrary functionalities. The set of APIs usable are then restricted\non the available methods to control the domains.\n\nSee virConnectOpen for notes about environment variables which can\nhave an effect on opening drivers and freeing the connection resources\n\nURIs are documented at https://libvirt.org/uri.html"],"return":[{"$":{"type":"virConnectPtr","info":"a pointer to the hypervisor connection or NULL in case of error"}}],"arg":[{"$":{"name":"name","type":"const char *","info":"(optional) URI of the hypervisor"}}]},{"$":{"name":"virConnectRef","file":"libvirt-host","module":"libvirt-host"},"info":["Increment the reference count on the connection. For each\nadditional call to this method, there shall be a corresponding\ncall to virConnectClose to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using a connection would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"the connection to hold a reference on"}}]},{"$":{"name":"virConnectRegisterCloseCallback","file":"libvirt-host","module":"libvirt-host"},"info":["Registers a callback to be invoked when the connection\nis closed. This callback is invoked when there is any\ncondition that causes the socket connection to the\nhypervisor to be closed.\n\nThis function is only applicable to hypervisor drivers\nwhich maintain a persistent open connection. Drivers\nwhich open a new connection for every operation will\nnot invoke this.\n\nThe @freecb must not invoke any other libvirt public\nAPIs, since it is not called from a re-entrant safe\ncontext."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to connection object"}},{"$":{"name":"cb","type":"virConnectCloseFunc","info":"callback to invoke upon close"}},{"$":{"name":"opaque","type":"void *","info":"user data to pass to @cb"}},{"$":{"name":"freecb","type":"virFreeCallback","info":"callback to free @opaque"}}]},{"$":{"name":"virConnectSecretEventDeregisterAny","file":"libvirt-secret","module":"libvirt-secret"},"info":["Removes an event callback. The callbackID parameter should be the\nvalue obtained from a previous virConnectSecretEventRegisterAny() method."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"callbackID","type":"int","info":"the callback identifier"}}]},{"$":{"name":"virConnectSecretEventRegisterAny","file":"libvirt-secret","module":"libvirt-secret"},"info":["Adds a callback to receive notifications of arbitrary secret events\noccurring on a secret. This function requires that an event loop\nhas been previously registered with virEventRegisterImpl() or\nvirEventRegisterDefaultImpl().\n\nIf @secret is NULL, then events will be monitored for any secret.\nIf @secret is non-NULL, then only the specific secret will be monitored.\n\nMost types of events have a callback providing a custom set of parameters\nfor the event. When registering an event, it is thus necessary to use\nthe VIR_SECRET_EVENT_CALLBACK() macro to cast the\nsupplied function pointer to match the signature of this method.\n\nThe virSecretPtr object handle passed into the callback upon delivery\nof an event is only valid for the duration of execution of the callback.\nIf the callback wishes to keep the secret object after the callback\nreturns, it shall take a reference to it, by calling virSecretRef().\nThe reference can be released once the object is no longer required\nby calling virSecretFree().\n\nThe return value from this method is a positive integer identifier\nfor the callback. To unregister a callback, this callback ID should\nbe passed to the virConnectSecretEventDeregisterAny() method."],"return":[{"$":{"type":"int","info":"a callback identifier on success, -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"secret","type":"virSecretPtr","info":"pointer to the secret"}},{"$":{"name":"eventID","type":"int","info":"the event type to receive"}},{"$":{"name":"cb","type":"virConnectSecretEventGenericCallback","info":"callback to the function handling secret events"}},{"$":{"name":"opaque","type":"void *","info":"opaque data to pass on to the callback"}},{"$":{"name":"freecb","type":"virFreeCallback","info":"optional function to deallocate opaque when not used anymore"}}]},{"$":{"name":"virConnectSetKeepAlive","file":"libvirt-host","module":"libvirt-host"},"info":["Start sending keepalive messages after @interval seconds of inactivity and\nconsider the connection to be broken when no response is received after\n@count keepalive messages sent in a row.  In other words, sending count + 1\nkeepalive message results in closing the connection.  When @interval is\n<= 0, no keepalive messages will be sent.  When @count is 0, the connection\nwill be automatically closed after @interval seconds of inactivity without\nsending any keepalive messages.\n\nNote: The client has to implement and run an event loop with\nvirEventRegisterImpl() or virEventRegisterDefaultImpl() to be able to\nuse keepalive messages.  Failure to do so may result in connections\nbeing closed unexpectedly.\n\nNote: This API function controls only keepalive messages sent by the client.\nIf the server is configured to use keepalive you still need to run the event\nloop to respond to them, even if you disable keepalives by this function."],"return":[{"$":{"type":"int","info":"-1 on error, 0 on success, 1 when remote party doesn't support keepalive messages."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to a hypervisor connection"}},{"$":{"name":"interval","type":"int","info":"number of seconds of inactivity before a keepalive message is sent"}},{"$":{"name":"count","type":"unsigned int","info":"number of messages that can be sent in a row"}}]},{"$":{"name":"virConnectStoragePoolEventDeregisterAny","file":"libvirt-storage","module":"libvirt-storage"},"info":["Removes an event callback. The callbackID parameter should be the\nvalue obtained from a previous virConnectStoragePoolEventRegisterAny() method."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"callbackID","type":"int","info":"the callback identifier"}}]},{"$":{"name":"virConnectStoragePoolEventRegisterAny","file":"libvirt-storage","module":"libvirt-storage"},"info":["Adds a callback to receive notifications of arbitrary storage pool events\noccurring on a storage pool. This function requires that an event loop\nhas been previously registered with virEventRegisterImpl() or\nvirEventRegisterDefaultImpl().\n\nIf @pool is NULL, then events will be monitored for any storage pool.\nIf @pool is non-NULL, then only the specific storage pool will be monitored.\n\nMost types of events have a callback providing a custom set of parameters\nfor the event. When registering an event, it is thus necessary to use\nthe VIR_STORAGE_POOL_EVENT_CALLBACK() macro to cast the\nsupplied function pointer to match the signature of this method.\n\nThe virStoragePoolPtr object handle passed into the callback upon delivery\nof an event is only valid for the duration of execution of the callback.\nIf the callback wishes to keep the storage pool object after the callback\nreturns, it shall take a reference to it, by calling virStoragePoolRef().\nThe reference can be released once the object is no longer required\nby calling virStoragePoolFree().\n\nThe return value from this method is a positive integer identifier\nfor the callback. To unregister a callback, this callback ID should\nbe passed to the virConnectStoragePoolEventDeregisterAny() method."],"return":[{"$":{"type":"int","info":"a callback identifier on success, -1 on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to the storage pool"}},{"$":{"name":"eventID","type":"int","info":"the event type to receive"}},{"$":{"name":"cb","type":"virConnectStoragePoolEventGenericCallback","info":"callback to the function handling network events"}},{"$":{"name":"opaque","type":"void *","info":"opaque data to pass on to the callback"}},{"$":{"name":"freecb","type":"virFreeCallback","info":"optional function to deallocate opaque when not used anymore"}}]},{"$":{"name":"virConnectUnregisterCloseCallback","file":"libvirt-host","module":"libvirt-host"},"info":["Unregisters the callback previously set with the\nvirConnectRegisterCloseCallback method. The callback\nwill no longer receive notifications when the connection\ncloses. If a virFreeCallback was provided at time of\nregistration, it will be invoked"],"return":[{"$":{"type":"int","info":"0 on success, -1 on error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to connection object"}},{"$":{"name":"cb","type":"virConnectCloseFunc","info":"pointer to the current registered callback"}}]},{"$":{"name":"virCopyLastError","file":"virterror","module":"virerror"},"info":["Copy the content of the last error caught at the library level\n\nThe error object is kept in thread local storage, so separate\nthreads can safely access this concurrently.\n\nOne will need to free the result with virResetError()"],"return":[{"$":{"type":"int","info":"0 if no error was found and the error code otherwise and -1 in case of parameter error."}}],"arg":[{"$":{"name":"to","type":"virErrorPtr","info":"target to receive the copy"}}]},{"$":{"name":"virDefaultErrorFunc","file":"virterror","module":"virerror"},"info":["Default routine reporting an error to stderr."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"err","type":"virErrorPtr","info":"pointer to the error."}}]},{"$":{"name":"virDomainAbortJob","file":"libvirt-domain","module":"libvirt-domain"},"info":["Requests that the current background job be aborted at the\nsoonest opportunity. In case the job is a migration in a post-copy mode,\nvirDomainAbortJob will report an error (see virDomainMigrateStartPostCopy\nfor more details)."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainAddIOThread","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically add an IOThread to the domain. It is left up to the\nunderlying virtual hypervisor to determine the valid range for an\n@iothread_id and determining whether the @iothread_id already exists.\n\nNote that this call can fail if the underlying virtualization hypervisor\ndoes not support it or if growing the number is arbitrarily limited.\nThis function requires privileged access to the hypervisor.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\nBoth flags may be set.\nIf VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\nand may fail if domain is not alive.\nIf VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\nand will fail for transient domains. If neither flag is specified (that is,\n@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\npersistent setup, while an active domain is hypervisor-dependent on whether\njust live or both live and persistent state is changed."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"iothread_id","type":"unsigned int","info":"the specific IOThread ID value to add"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainAttachDevice","file":"libvirt-domain","module":"libvirt-domain"},"info":["Create a virtual device attachment to backend.  This function,\nhaving hotplug semantics, is only allowed on an active domain.\n\nFor compatibility, this method can also be used to change the media\nin an existing CDROM/Floppy device, however, applications are\nrecommended to use the virDomainUpdateDeviceFlag method instead.\n\nBe aware that hotplug changes might not persist across a domain going\ninto S4 state (also known as hibernation) unless you also modify the\npersistent domain definition."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"xml","type":"const char *","info":"pointer to XML description of one device"}}]},{"$":{"name":"virDomainAttachDeviceFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Attach a virtual device to a domain, using the flags parameter\nto control how the device is attached.  VIR_DOMAIN_AFFECT_CURRENT\nspecifies that the device allocation is made based on current domain\nstate.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\nallocated to the active domain instance only and is not added to the\npersisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG\nspecifies that the device shall be allocated to the persisted domain\nconfiguration only.  Note that the target hypervisor must return an\nerror if unable to satisfy flags.  E.g. the hypervisor driver will\nreturn failure if LIVE is specified but it only supports modifying the\npersisted device allocation.\n\nFor compatibility, this method can also be used to change the media\nin an existing CDROM/Floppy device, however, applications are\nrecommended to use the virDomainUpdateDeviceFlag method instead.\n\nBe aware that hotplug changes might not persist across a domain going\ninto S4 state (also known as hibernation) unless you also modify the\npersistent domain definition."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"xml","type":"const char *","info":"pointer to XML description of one device"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainDeviceModifyFlags"}}]},{"$":{"name":"virDomainBlockCommit","file":"libvirt-domain","module":"libvirt-domain"},"info":["Commit changes that were made to temporary top-level files within a disk\nimage backing file chain into a lower-level base file.  In other words,\ntake all the difference between @base and @top, and update @base to contain\nthat difference; after the commit, any portion of the chain that previously\ndepended on @top will now depend on @base, and all files after @base up\nto and including @top will now be invalidated.  A typical use of this\ncommand is to reduce the length of a backing file chain after taking an\nexternal disk snapshot.  To move data in the opposite direction, see\nvirDomainBlockPull().\n\nThis command starts a long-running commit block job, whose status may\nbe tracked by virDomainBlockJobInfo() with a job type of\nVIR_DOMAIN_BLOCK_JOB_TYPE_COMMIT, and the operation can be aborted with\nvirDomainBlockJobAbort().  When finished, an asynchronous event is\nraised to indicate the final status, and the job no longer exists.  If\nthe job is aborted, it is up to the hypervisor whether starting a new\njob will resume from the same point, or start over.\n\nAs a special case, if @top is the active image (or NULL), and @flags\nincludes VIR_DOMAIN_BLOCK_COMMIT_ACTIVE, the block job will have a type\nof VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT, and operates in two phases.\nIn the first phase, the contents are being committed into @base, and the\njob can only be canceled.  The job transitions to the second phase when\nthe job info states cur == end, and remains alive to keep all further\nchanges to @top synchronized into @base; an event with status\nVIR_DOMAIN_BLOCK_JOB_READY is also issued to mark the job transition.\nOnce in the second phase, the user must choose whether to cancel the job\n(keeping @top as the active image, but now containing only the changes\nsince the time the job ended) or to pivot the job (adjusting to @base as\nthe active image, and invalidating @top).\n\nBe aware that this command may invalidate files even if it is aborted;\nthe user is cautioned against relying on the contents of invalidated\nintermediate files such as @top (when @top is not the active image)\nwithout manually rebasing those files to use a backing file of a\nread-only copy of @base prior to the point where the commit operation\nwas started (and such a rebase cannot be safely done until the commit\nhas successfully completed).  However, the domain itself will not have\nany issues; the active layer remains valid throughout the entire commit\noperation.\n\nSome hypervisors may support a shortcut where if @flags contains\nVIR_DOMAIN_BLOCK_COMMIT_DELETE, then this command will unlink all files\nthat were invalidated, after the commit successfully completes.\n\nIf @flags contains VIR_DOMAIN_BLOCK_COMMIT_RELATIVE, the name recorded\ninto the overlay of the @top image (if there is such image) as the\npath to the new backing file will be kept relative to other images.\nThe operation will fail if libvirt can't infer the name.\n\nBy default, if @base is NULL, the commit target will be the bottom of\nthe backing chain; if @flags contains VIR_DOMAIN_BLOCK_COMMIT_SHALLOW,\nthen the immediate backing file of @top will be used instead.  If @top\nis NULL, the active image at the top of the chain will be used.  Some\nhypervisors place restrictions on how much can be committed, and might\nfail if @base is not the immediate backing file of @top, or if @top is\nthe active layer in use by a running domain but @flags did not include\nVIR_DOMAIN_BLOCK_COMMIT_ACTIVE, or if @top is not the top-most file;\nrestrictions may differ for online vs. offline domains.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or the device target shorthand (the\n<target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nThe @base and @top parameters can be either paths to files within the\nbacking chain, or the device target shorthand (the <target dev='...'/>\nsub-element, such as \"vda\") followed by an index to the backing chain\nenclosed in square brackets. Backing chain indexes can be found by\ninspecting //disk//backingStore/@index in the domain XML. Thus, for\nexample, \"vda[3]\" refers to the backing store with index equal to \"3\"\nin the chain of disk \"vda\".\n\nThe maximum bandwidth that will be used to do the commit can be\nspecified with the @bandwidth parameter.  If set to 0, there is no\nlimit.  If @flags includes VIR_DOMAIN_BLOCK_COMMIT_BANDWIDTH_BYTES,\n@bandwidth is in bytes/second; otherwise, it is in MiB/second.\nValues larger than 2^52 bytes/sec may be rejected due to overflow\nconsiderations based on the word size of both client and server,\nand values larger than 2^31 bytes/sec may cause overflow problems\nif later queried by virDomainGetBlockJobInfo() without scaling.\nHypervisors may further restrict the range of valid bandwidth\nvalues.  Some hypervisors do not support this feature and will\nreturn an error if bandwidth is not 0; in this case, it might still\nbe possible for a later call to virDomainBlockJobSetSpeed() to\nsucceed.  The actual speed can be determined with\nvirDomainGetBlockJobInfo()."],"return":[{"$":{"type":"int","info":"0 if the operation has started, -1 on failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"base","type":"const char *","info":"path to backing file to merge into, or device shorthand, or NULL for default"}},{"$":{"name":"top","type":"const char *","info":"path to file within backing chain that contains data to be merged, or device shorthand, or NULL to merge all possible data"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"(optional) specify bandwidth limit; flags determine the unit"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockCommitFlags"}}]},{"$":{"name":"virDomainBlockCopy","file":"libvirt-domain","module":"libvirt-domain"},"info":["Copy the guest-visible contents of a disk image to a new file described\nby @destxml.  The destination XML has a top-level element of <disk>, and\nresembles what is used when hot-plugging a disk via virDomainAttachDevice(),\nexcept that only sub-elements related to describing the new host resource\nare necessary (sub-elements related to the guest view, such as <target>,\nare ignored).  It is strongly recommended to include a <driver type='...'/>\nformat designation for the destination, to avoid the potential of any\nsecurity problem that might be caused by probing a file for its format.\n\nThis command starts a long-running copy.  By default, the copy will pull\nthe entire source chain into the destination file, but if @flags also\ncontains VIR_DOMAIN_BLOCK_COPY_SHALLOW, then only the top of the source\nchain will be copied (the source and destination have a common backing\nfile).  The format of the destination file is controlled by the <driver>\nsub-element of the XML.  The destination will be created unless the\nVIR_DOMAIN_BLOCK_COPY_REUSE_EXT flag is present stating that the file\nwas pre-created with the correct format and metadata and sufficient\nsize to hold the copy. In case the VIR_DOMAIN_BLOCK_COPY_SHALLOW flag\nis used the pre-created file has to exhibit the same guest visible contents\nas the backing file of the original image. This allows a management app to\npre-create files with relative backing file names, rather than the default\nof absolute backing file names.\n\nA copy job has two parts; in the first phase, the source is copied into\nthe destination, and the job can only be canceled by reverting to the\nsource file; progress in this phase can be tracked via the\nvirDomainBlockJobInfo() command, with a job type of\nVIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the second\nphase when the job info states cur == end, and remains alive to mirror\nall further changes to both source and destination.  The user must\ncall virDomainBlockJobAbort() to end the mirroring while choosing\nwhether to revert to source or pivot to the destination.  An event is\nissued when the job ends, and depending on the hypervisor, an event may\nalso be issued when the job transitions from pulling to mirroring.  If\nthe job is aborted, a new job will have to start over from the beginning\nof the first phase.\n\nSome hypervisors will restrict certain actions, such as virDomainSave()\nor virDomainDetachDevice(), while a copy job is active; they may\nalso restrict a copy job to transient domains.\n\nIf @flags contains VIR_DOMAIN_BLOCK_COPY_TRANSIENT_JOB the job will not be\nrecoverable if the VM is turned off while job is active. This flag will\nremove the restriction of copy jobs to transient domains.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or the device target shorthand (the\n<target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nThe @params and @nparams arguments can be used to set hypervisor-specific\ntuning parameters, such as maximum bandwidth or granularity.  For a\nparameter that the hypervisor understands, explicitly specifying 0\nbehaves the same as omitting the parameter, to use the hypervisor\ndefault; however, omitting a parameter is less likely to fail.\n\nThis command is a superset of the older virDomainBlockRebase() when used\nwith the VIR_DOMAIN_BLOCK_REBASE_COPY flag, and offers better control\nover the destination format, the ability to copy to a destination that\nis not a local file, and the possibility of additional tuning parameters."],"return":[{"$":{"type":"int","info":"0 if the operation has started, -1 on failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"destxml","type":"const char *","info":"XML description of the copy destination"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"Pointer to block copy parameter objects, or NULL"}},{"$":{"name":"nparams","type":"int","info":"Number of block copy parameters (this value can be the same or less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockCopyFlags"}}]},{"$":{"name":"virDomainBlockJobAbort","file":"libvirt-domain","module":"libvirt-domain"},"info":["Cancel the active block job on the given disk.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or (since 0.9.5) the device target shorthand\n(the <target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nIf the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, then\nby default, this function performs a synchronous operation and the caller\nmay assume that the operation has completed when 0 is returned.  However,\nBlockJob operations may take a long time to cancel, and during this time\nfurther domain interactions may be unresponsive.  To avoid this problem,\npass VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC in the @flags argument to enable\nasynchronous behavior, returning as soon as possible.  When the job has\nbeen canceled, a BlockJob event will be emitted, with status\nVIR_DOMAIN_BLOCK_JOB_CANCELED (even if the ABORT_ASYNC flag was not\nused); it is also possible to poll virDomainBlockJobInfo() to see if\nthe job cancellation is still pending.  This type of job can be restarted\nto pick up from where it left off.\n\nIf the current block job for @disk is VIR_DOMAIN_BLOCK_JOB_TYPE_COPY, then\nthe default is to abort the mirroring and revert to the source disk;\nlikewise, if the current job is VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT,\nthe default is to abort without changing the active layer of @disk.\nAdding @flags of VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT causes this call to\nfail with VIR_ERR_BLOCK_COPY_ACTIVE if the copy or commit is not yet\nready; otherwise it will swap the disk over to the new active image\nto end the mirroring or active commit.  An event will be issued when the\njob is ended, and it is possible to use VIR_DOMAIN_BLOCK_JOB_ABORT_ASYNC\nto control whether this command waits for the completion of the job.\nRestarting a copy or active commit job requires starting over from the\nbeginning of the first phase."],"return":[{"$":{"type":"int","info":"-1 in case of failure, 0 when successful."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockJobAbortFlags"}}]},{"$":{"name":"virDomainBlockJobSetSpeed","file":"libvirt-domain","module":"libvirt-domain"},"info":["Set the maximimum allowable bandwidth that a block job may consume.  If\nbandwidth is 0, the limit will revert to the hypervisor default of\nunlimited.\n\nIf @flags contains VIR_DOMAIN_BLOCK_JOB_SPEED_BANDWIDTH_BYTES, @bandwidth\nis in bytes/second; otherwise, it is in MiB/second.  Values larger than\n2^52 bytes/sec may be rejected due to overflow considerations based on\nthe word size of both client and server, and values larger than 2^31\nbytes/sec may cause overflow problems if later queried by\nvirDomainGetBlockJobInfo() without scaling.  Hypervisors may further\nrestrict the range of valid bandwidth values.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or (since 0.9.5) the device target shorthand\n(the <target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk."],"return":[{"$":{"type":"int","info":"-1 in case of failure, 0 when successful."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"specify bandwidth limit; flags determine the unit"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockJobSetSpeedFlags"}}]},{"$":{"name":"virDomainBlockPeek","file":"libvirt-domain","module":"libvirt-domain"},"info":["This function allows you to read the contents of a domain's\ndisk device.\n\nTypical uses for this are to determine if the domain has\nwritten a Master Boot Record (indicating that the domain\nhas completed installation), or to try to work out the state\nof the domain's filesystems.\n\n(Note that in the local case you might try to open the\nblock device or file directly, but that won't work in the\nremote case, nor if you don't have sufficient permission.\nHence the need for this call).\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or (since 0.9.5) the device target shorthand\n(the <target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\n'offset' and 'size' represent an area which must lie entirely\nwithin the device or file.  'size' may be 0 to test if the\ncall would succeed.\n\n'buffer' is the return buffer and must be at least 'size' bytes.\n\nNB. The remote driver imposes a 64K byte limit on 'size'.\nFor your program to be able to work reliably over a remote\nconnection you should split large requests to <= 65536 bytes.\nHowever, with 0.9.13 this RPC limit has been raised to 1M byte.\nStarting with version 1.0.6 the RPC limit has been raised again.\nNow large requests up to 16M byte are supported."],"return":[{"$":{"type":"int","info":"0 in case of success or -1 in case of failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"offset","type":"unsigned long long","info":"offset within block device"}},{"$":{"name":"size","type":"size_t","info":"size to read"}},{"$":{"name":"buffer","type":"void *","info":"return buffer (must be at least size bytes)"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainBlockPull","file":"libvirt-domain","module":"libvirt-domain"},"info":["Populate a disk image with data from its backing image.  Once all data from\nits backing image has been pulled, the disk no longer depends on a backing\nimage.  This function pulls data for the entire device in the background.\nProgress of the operation can be checked with virDomainGetBlockJobInfo() and\nthe operation can be aborted with virDomainBlockJobAbort().  When finished,\nan asynchronous event is raised to indicate the final status.  To move\ndata in the opposite direction, see virDomainBlockCommit().\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or (since 0.9.5) the device target shorthand\n(the <target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nThe maximum bandwidth that will be used to do the copy can be\nspecified with the @bandwidth parameter.  If set to 0, there is no\nlimit.  If @flags includes VIR_DOMAIN_BLOCK_PULL_BANDWIDTH_BYTES,\n@bandwidth is in bytes/second; otherwise, it is in MiB/second.\nValues larger than 2^52 bytes/sec may be rejected due to overflow\nconsiderations based on the word size of both client and server,\nand values larger than 2^31 bytes/sec may cause overflow problems\nif later queried by virDomainGetBlockJobInfo() without scaling.\nHypervisors may further restrict the range of valid bandwidth\nvalues.  Some hypervisors do not support this feature and will\nreturn an error if bandwidth is not 0; in this case, it might still\nbe possible for a later call to virDomainBlockJobSetSpeed() to\nsucceed.  The actual speed can be determined with\nvirDomainGetBlockJobInfo().\n\nThis is shorthand for virDomainBlockRebase() with a NULL base."],"return":[{"$":{"type":"int","info":"0 if the operation has started, -1 on failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"(optional) specify bandwidth limit; flags determine the unit"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockPullFlags"}}]},{"$":{"name":"virDomainBlockRebase","file":"libvirt-domain","module":"libvirt-domain"},"info":["Populate a disk image with data from its backing image chain, and\nsetting the backing image to @base, or alternatively copy an entire\nbacking chain to a new file @base.\n\nWhen @flags is 0, this starts a pull, where @base must be the absolute\npath of one of the backing images further up the chain, or NULL to\nconvert the disk image so that it has no backing image.  Once all\ndata from its backing image chain has been pulled, the disk no\nlonger depends on those intermediate backing images.  This function\npulls data for the entire device in the background.  Progress of\nthe operation can be checked with virDomainGetBlockJobInfo() with a\njob type of VIR_DOMAIN_BLOCK_JOB_TYPE_PULL, and the operation can be\naborted with virDomainBlockJobAbort().  When finished, an asynchronous\nevent is raised to indicate the final status, and the job no longer\nexists.  If the job is aborted, a new one can be started later to\nresume from the same point.\n\nIf @flags contains VIR_DOMAIN_BLOCK_REBASE_RELATIVE, the name recorded\ninto the active disk as the location for @base will be kept relative.\nThe operation will fail if libvirt can't infer the name.\n\nWhen @flags includes VIR_DOMAIN_BLOCK_REBASE_COPY, this starts a copy,\nwhere @base must be the name of a new file to copy the chain to.  By\ndefault, the copy will pull the entire source chain into the destination\nfile, but if @flags also contains VIR_DOMAIN_BLOCK_REBASE_SHALLOW, then\nonly the top of the source chain will be copied (the source and\ndestination have a common backing file).  By default, @base will be\ncreated with the same file format as the source, but this can be altered\nby adding VIR_DOMAIN_BLOCK_REBASE_COPY_RAW to force the copy to be raw\n(does not make sense with the shallow flag unless the source is also raw),\nor by using VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT to reuse an existing file\nwhich was pre-created with the correct format and metadata and sufficient\nsize to hold the copy. In case the VIR_DOMAIN_BLOCK_REBASE_SHALLOW flag\nis used the pre-created file has to exhibit the same guest visible contents\nas the backing file of the original image. This allows a management app to\npre-create files with relative backing file names, rather than the default\nof absolute backing file names; as a security precaution, you should\ngenerally only use reuse_ext with the shallow flag and a non-raw\ndestination file.  By default, the copy destination will be treated as\ntype='file', but using VIR_DOMAIN_BLOCK_REBASE_COPY_DEV treats the\ndestination as type='block' (affecting how virDomainGetBlockInfo() will\nreport allocation after pivoting).\n\nA copy job has two parts; in the first phase, the @bandwidth parameter\naffects how fast the source is pulled into the destination, and the job\ncan only be canceled by reverting to the source file; progress in this\nphase can be tracked via the virDomainBlockJobInfo() command, with a\njob type of VIR_DOMAIN_BLOCK_JOB_TYPE_COPY.  The job transitions to the\nsecond phase when the job info states cur == end, and remains alive to\nmirror all further changes to both source and destination.  The user\nmust call virDomainBlockJobAbort() to end the mirroring while choosing\nwhether to revert to source or pivot to the destination.  An event is\nissued when the job ends, and depending on the hypervisor, an event may\nalso be issued when the job transitions from pulling to mirroring.  If\nthe job is aborted, a new job will have to start over from the beginning\nof the first phase.\n\nSome hypervisors will restrict certain actions, such as virDomainSave()\nor virDomainDetachDevice(), while a copy job is active; they may\nalso restrict a copy job to transient domains.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or the device target shorthand (the\n<target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nThe @base parameter can be either a path to a file within the backing\nchain, or the device target shorthand (the <target dev='...'/>\nsub-element, such as \"vda\") followed by an index to the backing chain\nenclosed in square brackets. Backing chain indexes can be found by\ninspecting //disk//backingStore/@index in the domain XML. Thus, for\nexample, \"vda[3]\" refers to the backing store with index equal to \"3\"\nin the chain of disk \"vda\".\n\nThe maximum bandwidth that will be used to do the copy can be\nspecified with the @bandwidth parameter.  If set to 0, there is no\nlimit.  If @flags includes VIR_DOMAIN_BLOCK_REBASE_BANDWIDTH_BYTES,\n@bandwidth is in bytes/second; otherwise, it is in MiB/second.\nValues larger than 2^52 bytes/sec may be rejected due to overflow\nconsiderations based on the word size of both client and server,\nand values larger than 2^31 bytes/sec may cause overflow problems\nif later queried by virDomainGetBlockJobInfo() without scaling.\nHypervisors may further restrict the range of valid bandwidth\nvalues.  Some hypervisors do not support this feature and will\nreturn an error if bandwidth is not 0; in this case, it might still\nbe possible for a later call to virDomainBlockJobSetSpeed() to\nsucceed.  The actual speed can be determined with\nvirDomainGetBlockJobInfo().\n\nWhen @base is NULL and @flags is 0, this is identical to\nvirDomainBlockPull().  When @flags contains VIR_DOMAIN_BLOCK_REBASE_COPY,\nthis command is shorthand for virDomainBlockCopy() where the destination\nXML encodes @base as a <disk type='file'>, @bandwidth is properly scaled\nand passed as a typed parameter, the shallow and reuse external flags\nare preserved, and remaining flags control whether the XML encodes a\ndestination format of raw instead of leaving the destination identical\nto the source format or probed from the reused file."],"return":[{"$":{"type":"int","info":"0 if the operation has started, -1 on failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"base","type":"const char *","info":"path to backing file to keep, or device shorthand, or NULL for no backing file"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"(optional) specify bandwidth limit; flags determine the unit"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockRebaseFlags"}}]},{"$":{"name":"virDomainBlockResize","file":"libvirt-domain","module":"libvirt-domain"},"info":["Resize a block device of domain while the domain is running.  If\n@flags is 0, then @size is in kibibytes (blocks of 1024 bytes);\nsince 0.9.11, if @flags includes VIR_DOMAIN_BLOCK_RESIZE_BYTES,\n@size is in bytes instead.  @size is taken directly as the new\nsize.  Depending on the file format, the hypervisor may round up\nto the next alignment boundary.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or (since 0.9.5) the device target shorthand\n(the <target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nNote that this call may fail if the underlying virtualization hypervisor\ndoes not support it; this call requires privileged access to the\nhypervisor."],"return":[{"$":{"type":"int","info":"0 in case of success or -1 in case of failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block image, or shorthand"}},{"$":{"name":"size","type":"unsigned long long","info":"new size of the block image, see below for unit"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockResizeFlags"}}]},{"$":{"name":"virDomainBlockStats","file":"libvirt-domain","module":"libvirt-domain"},"info":["This function returns block device (disk) stats for block\ndevices attached to the domain.\n\nThe @disk parameter is either the device target shorthand (the\n<target dev='...'/> sub-element, such as \"vda\"), or (since 0.9.8)\nan unambiguous source name of the block device (the <source\nfile='...'/> sub-element, such as \"/path/to/image\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk. Some drivers might also\naccept the empty string for the @disk parameter, and then yield\nsummary stats for the entire domain.\n\nDomains may have more than one block device.  To get stats for\neach you should make multiple calls to this function.\n\nIndividual fields within the stats structure may be returned\nas -1, which indicates that the hypervisor does not support\nthat particular statistic."],"return":[{"$":{"type":"int","info":"0 in case of success or -1 in case of failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"stats","type":"virDomainBlockStatsPtr","info":"block device stats (returned)"}},{"$":{"name":"size","type":"size_t","info":"size of stats structure"}}]},{"$":{"name":"virDomainBlockStatsFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["This function is to get block stats parameters for block\ndevices attached to the domain.\n\nThe @disk parameter is either the device target shorthand (the\n<target dev='...'/> sub-element, such as \"vda\"), or (since 0.9.8)\nan unambiguous source name of the block device (the <source\nfile='...'/> sub-element, such as \"/path/to/image\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk. Some drivers might also\naccept the empty string for the @disk parameter, and then yield\nsummary stats for the entire domain.\n\nDomains may have more than one block device.  To get stats for\neach you should make multiple calls to this function.\n\nOn input, @nparams gives the size of the @params array; on output,\n@nparams gives how many slots were filled with parameter\ninformation, which might be less but will not exceed the input\nvalue.\n\nAs a special case, calling with @params as NULL and @nparams as 0 on\ninput will cause @nparams on output to contain the number of parameters\nsupported by the hypervisor. (Note that block devices of different types\nmight support different parameters, so it might be necessary to compute\n@nparams for each block device). The caller should then allocate @params\narray, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\nagain. See virDomainGetMemoryParameters() for more details."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to block stats parameter object (return value, allocated by the caller)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of block stats; input and output"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virTypedParameterFlags"}}]},{"$":{"name":"virDomainCoreDump","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will dump the core of a domain on a given file for analysis.\nNote that for remote Xen Daemon the file path will be interpreted in\nthe remote host. Hypervisors may require  the user to manually ensure\nproper permissions on the file named by @to.\n\nIf @flags includes VIR_DUMP_CRASH, then leave the guest shut off with\na crashed state after the dump completes.  If @flags includes\nVIR_DUMP_LIVE, then make the core dump while continuing to allow\nthe guest to run; otherwise, the guest is suspended during the dump.\nVIR_DUMP_RESET flag forces reset of the guest after dump.\nThe above three flags are mutually exclusive.\n\nAdditionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt\nwill attempt to bypass the file system cache while creating the file,\nor fail if it cannot do so for the given system; this can allow less\npressure on file system cache, but also risks slowing saves to NFS.\n\nFor more control over the output format, see virDomainCoreDumpWithFormat()."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"to","type":"const char *","info":"path for the core file"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainCoreDumpFlags"}}]},{"$":{"name":"virDomainCoreDumpWithFormat","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will dump the core of a domain on a given file for analysis.\nNote that for remote Xen Daemon the file path will be interpreted in\nthe remote host. Hypervisors may require  the user to manually ensure\nproper permissions on the file named by @to.\n\n@dumpformat controls which format the dump will have; use of\nVIR_DOMAIN_CORE_DUMP_FORMAT_RAW mirrors what virDomainCoreDump() will\nperform.  Not all hypervisors are able to support all formats.\n\nIf @flags includes VIR_DUMP_CRASH, then leave the guest shut off with\na crashed state after the dump completes.  If @flags includes\nVIR_DUMP_LIVE, then make the core dump while continuing to allow\nthe guest to run; otherwise, the guest is suspended during the dump.\nVIR_DUMP_RESET flag forces reset of the guest after dump.\nThe above three flags are mutually exclusive.\n\nAdditionally, if @flags includes VIR_DUMP_BYPASS_CACHE, then libvirt\nwill attempt to bypass the file system cache while creating the file,\nor fail if it cannot do so for the given system; this can allow less\npressure on file system cache, but also risks slowing saves to NFS."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"to","type":"const char *","info":"path for the core file"}},{"$":{"name":"dumpformat","type":"unsigned int","info":"format of domain memory's dump (one of virDomainCoreDumpFormat enum)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainCoreDumpFlags"}}]},{"$":{"name":"virDomainCreate","file":"libvirt-domain","module":"libvirt-domain"},"info":["Launch a defined domain. If the call succeeds the domain moves from the\ndefined to the running domains pools.  The domain will be paused only\nif restoring from managed state created from a paused domain.  For more\ncontrol, see virDomainCreateWithFlags()."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to a defined domain"}}]},{"$":{"name":"virDomainCreateLinux","file":"libvirt-domain","module":"libvirt-domain"},"info":["Deprecated after 0.4.6.\nRenamed to virDomainCreateXML() providing identical functionality.\nThis existing name will be left indefinitely for API compatibility."],"return":[{"$":{"type":"virDomainPtr","info":"a new domain object or NULL in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"string containing an XML description of the domain"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainCreateWithFiles","file":"libvirt-domain","module":"libvirt-domain"},"info":["Launch a defined domain. If the call succeeds the domain moves from the\ndefined to the running domains pools.\n\n@files provides an array of file descriptors which will be\nmade available to the 'init' process of the guest. The file\nhandles exposed to the guest will be renumbered to start\nfrom 3 (ie immediately following stderr). This is only\nsupported for guests which use container based virtualization\ntechnology.\n\nIf the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain\nhas a managed save image that requested paused state (see\nvirDomainManagedSave()) the guest domain will be started, but its\nCPUs will remain paused. The CPUs can later be manually started\nusing virDomainResume().  In all other cases, the guest domain will\nbe running.\n\nIf the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\ndomain will be automatically destroyed when the virConnectPtr\nobject is finally released. This will also happen if the\nclient application crashes / loses its connection to the\nlibvirtd daemon. Any domains marked for auto destroy will\nblock attempts at migration, save-to-file, or snapshots.\n\nIf the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a\nmanaged save file for this domain (created by virDomainManagedSave()),\nthen libvirt will attempt to bypass the file system cache while restoring\nthe file, or fail if it cannot do so for the given system; this can allow\nless pressure on file system cache, but also risks slowing loads from NFS.\n\nIf the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save\nfile for this domain is discarded, and the domain boots from scratch."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to a defined domain"}},{"$":{"name":"nfiles","type":"unsigned int","info":"number of file descriptors passed"}},{"$":{"name":"files","type":"int *","info":"list of file descriptors passed"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainCreateFlags"}}]},{"$":{"name":"virDomainCreateWithFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Launch a defined domain. If the call succeeds the domain moves from the\ndefined to the running domains pools.\n\nIf the VIR_DOMAIN_START_PAUSED flag is set, or if the guest domain\nhas a managed save image that requested paused state (see\nvirDomainManagedSave()) the guest domain will be started, but its\nCPUs will remain paused. The CPUs can later be manually started\nusing virDomainResume().  In all other cases, the guest domain will\nbe running.\n\nIf the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\ndomain will be automatically destroyed when the virConnectPtr\nobject is finally released. This will also happen if the\nclient application crashes / loses its connection to the\nlibvirtd daemon. Any domains marked for auto destroy will\nblock attempts at migration, save-to-file, or snapshots.\n\nIf the VIR_DOMAIN_START_BYPASS_CACHE flag is set, and there is a\nmanaged save file for this domain (created by virDomainManagedSave()),\nthen libvirt will attempt to bypass the file system cache while restoring\nthe file, or fail if it cannot do so for the given system; this can allow\nless pressure on file system cache, but also risks slowing loads from NFS.\n\nIf the VIR_DOMAIN_START_FORCE_BOOT flag is set, then any managed save\nfile for this domain is discarded, and the domain boots from scratch."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to a defined domain"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainCreateFlags"}}]},{"$":{"name":"virDomainCreateXML","file":"libvirt-domain","module":"libvirt-domain"},"info":["Launch a new guest domain, based on an XML description similar\nto the one returned by virDomainGetXMLDesc()\nThis function may require privileged access to the hypervisor.\nThe domain is not persistent, so its definition will disappear when it\nis destroyed, or if the host is restarted (see virDomainDefineXML() to\ndefine persistent domains).\n\nIf the VIR_DOMAIN_START_PAUSED flag is set, the guest domain\nwill be started, but its CPUs will remain paused. The CPUs\ncan later be manually started using virDomainResume.\n\nIf the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\ndomain will be automatically destroyed when the virConnectPtr\nobject is finally released. This will also happen if the\nclient application crashes / loses its connection to the\nlibvirtd daemon. Any domains marked for auto destroy will\nblock attempts at migration, save-to-file, or snapshots.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"a new domain object or NULL in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"string containing an XML description of the domain"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainCreateFlags"}}]},{"$":{"name":"virDomainCreateXMLWithFiles","file":"libvirt-domain","module":"libvirt-domain"},"info":["Launch a new guest domain, based on an XML description similar\nto the one returned by virDomainGetXMLDesc()\nThis function may require privileged access to the hypervisor.\nThe domain is not persistent, so its definition will disappear when it\nis destroyed, or if the host is restarted (see virDomainDefineXML() to\ndefine persistent domains).\n\n@files provides an array of file descriptors which will be\nmade available to the 'init' process of the guest. The file\nhandles exposed to the guest will be renumbered to start\nfrom 3 (ie immediately following stderr). This is only\nsupported for guests which use container based virtualization\ntechnology.\n\nIf the VIR_DOMAIN_START_PAUSED flag is set, the guest domain\nwill be started, but its CPUs will remain paused. The CPUs\ncan later be manually started using virDomainResume.\n\nIf the VIR_DOMAIN_START_AUTODESTROY flag is set, the guest\ndomain will be automatically destroyed when the virConnectPtr\nobject is finally released. This will also happen if the\nclient application crashes / loses its connection to the\nlibvirtd daemon. Any domains marked for auto destroy will\nblock attempts at migration, save-to-file, or snapshots.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"a new domain object or NULL in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"string containing an XML description of the domain"}},{"$":{"name":"nfiles","type":"unsigned int","info":"number of file descriptors passed"}},{"$":{"name":"files","type":"int *","info":"list of file descriptors passed"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainCreateFlags"}}]},{"$":{"name":"virDomainDefineXML","file":"libvirt-domain","module":"libvirt-domain"},"info":["Define a domain, but does not start it.\nThis definition is persistent, until explicitly undefined with\nvirDomainUndefine(). A previous definition for this domain would be\noverridden if it already exists.\n\nSome hypervisors may prevent this operation if there is a current\nblock copy operation on a transient domain with the same id as the\ndomain being defined; in that case, use virDomainBlockJobAbort() to\nstop the block copy first.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"NULL in case of error, a pointer to the domain otherwise"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xml","type":"const char *","info":"the XML description for the domain, preferably in UTF-8"}}]},{"$":{"name":"virDomainDefineXMLFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Defines a domain, but does not start it.\nThis definition is persistent, until explicitly undefined with\nvirDomainUndefine(). A previous definition for this domain would be\noverridden if it already exists.\n\nSome hypervisors may prevent this operation if there is a current\nblock copy operation on a transient domain with the same id as the\ndomain being defined; in that case, use virDomainBlockJobAbort() to\nstop the block copy first.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"NULL in case of error, a pointer to the domain otherwise"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xml","type":"const char *","info":"the XML description for the domain, preferably in UTF-8"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise OR of the virDomainDefineFlags constants"}}]},{"$":{"name":"virDomainDelIOThread","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically delete an IOThread from the domain. The @iothread_id to be\ndeleted must not have a resource associated with it and can be any of\nthe currently valid IOThread ID's.\n\nNote that this call can fail if the underlying virtualization hypervisor\ndoes not support it or if reducing the number is arbitrarily limited.\nThis function requires privileged access to the hypervisor.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\nBoth flags may be set.\nIf VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\nand may fail if domain is not alive.\nIf VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\nand will fail for transient domains. If neither flag is specified (that is,\n@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\npersistent setup, while an active domain is hypervisor-dependent on whether\njust live or both live and persistent state is changed."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"iothread_id","type":"unsigned int","info":"the specific IOThread ID value to delete"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainDestroy","file":"libvirt-domain","module":"libvirt-domain"},"info":["Destroy the domain object. The running instance is shutdown if not down\nalready and all resources used by it are given back to the hypervisor. This\ndoes not free the associated virDomainPtr object.\nThis function may require privileged access.\n\nvirDomainDestroy first requests that a guest terminate\n(e.g. SIGTERM), then waits for it to comply. After a reasonable\ntimeout, if the guest still exists, virDomainDestroy will\nforcefully terminate the guest (e.g. SIGKILL) if necessary (which\nmay produce undesirable results, for example unflushed disk cache\nin the guest). To avoid this possibility, it's recommended to\ninstead call virDomainDestroyFlags, sending the\nVIR_DOMAIN_DESTROY_GRACEFUL flag.\n\nIf the domain is transient and has any snapshot metadata (see\nvirDomainSnapshotNum()), then that metadata will automatically\nbe deleted when the domain quits."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainDestroyFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Destroy the domain object. The running instance is shutdown if not down\nalready and all resources used by it are given back to the hypervisor.\nThis does not free the associated virDomainPtr object.\nThis function may require privileged access.\n\nCalling this function with no @flags set (equal to zero) is\nequivalent to calling virDomainDestroy, and after a reasonable\ntimeout will forcefully terminate the guest (e.g. SIGKILL) if\nnecessary (which may produce undesirable results, for example\nunflushed disk cache in the guest). Including\nVIR_DOMAIN_DESTROY_GRACEFUL in the flags will prevent the forceful\ntermination of the guest, and virDomainDestroyFlags will instead\nreturn an error if the guest doesn't terminate by the end of the\ntimeout; at that time, the management application can decide if\ncalling again without VIR_DOMAIN_DESTROY_GRACEFUL is appropriate.\n\nAnother alternative which may produce cleaner results for the\nguest's disks is to use virDomainShutdown() instead, but that\ndepends on guest support (some hypervisor/guest combinations may\nignore the shutdown request)."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainDestroyFlagsValues"}}]},{"$":{"name":"virDomainDetachDevice","file":"libvirt-domain","module":"libvirt-domain"},"info":["This is an equivalent of virDomainDetachDeviceFlags() when called with\n@flags parameter set to VIR_DOMAIN_AFFECT_LIVE.\n\nSee virDomainDetachDeviceFlags() for more details."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"xml","type":"const char *","info":"pointer to XML description of one device"}}]},{"$":{"name":"virDomainDetachDeviceFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Detach a virtual device from a domain, using the flags parameter\nto control how the device is detached.  VIR_DOMAIN_AFFECT_CURRENT\nspecifies that the device allocation is removed based on current domain\nstate.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\ndeallocated from the active domain instance only and is not from the\npersisted domain configuration.  VIR_DOMAIN_AFFECT_CONFIG\nspecifies that the device shall be deallocated from the persisted domain\nconfiguration only.  Note that the target hypervisor must return an\nerror if unable to satisfy flags.  E.g. the hypervisor driver will\nreturn failure if LIVE is specified but it only supports removing the\npersisted device allocation.\n\nSome hypervisors may prevent this operation if there is a current\nblock copy operation on the device being detached; in that case,\nuse virDomainBlockJobAbort() to stop the block copy first.\n\nBeware that depending on the hypervisor and device type, detaching a device\nfrom a running domain may be asynchronous. That is, calling\nvirDomainDetachDeviceFlags may just request device removal while the device\nis actually removed later (in cooperation with a guest OS). Previously,\nthis fact was ignored and the device could have been removed from domain\nconfiguration before it was actually removed by the hypervisor causing\nvarious failures on subsequent operations. To check whether the device was\nsuccessfully removed, either recheck domain configuration using\nvirDomainGetXMLDesc() or add a handler for the VIR_DOMAIN_EVENT_ID_DEVICE_REMOVED\nevent. In case the device is already gone when virDomainDetachDeviceFlags\nreturns, the event is delivered before this API call ends. To help existing\nclients work better in most cases, this API will try to transform an\nasynchronous device removal that finishes shortly after the request into\na synchronous removal. In other words, this API may wait a bit for the\nremoval to complete in case it was not synchronous.\n\nBe aware that hotplug changes might not persist across a domain going\ninto S4 state (also known as hibernation) unless you also modify the\npersistent domain definition.\n\nThe supplied XML description of the device should be as specific\nas its definition in the domain XML. The set of attributes used\nto match the device are internal to the drivers. Using a partial definition,\nor attempting to detach a device that is not present in the domain XML,\nbut shares some specific attributes with one that is present,\nmay lead to unexpected results."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"xml","type":"const char *","info":"pointer to XML description of one device"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainDeviceModifyFlags"}}]},{"$":{"name":"virDomainFSFreeze","file":"libvirt-domain","module":"libvirt-domain"},"info":["Freeze specified filesystems within the guest (hence guest agent\nmay be required depending on hypervisor used). If @mountpoints is NULL and\n@nmountpoints is 0, every mounted filesystem on the guest is frozen.\nIn some environments (e.g. QEMU guest with guest agent which doesn't\nsupport mountpoints argument), @mountpoints may need to be NULL."],"return":[{"$":{"type":"int","info":"the number of frozen filesystems on success, -1 otherwise."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"mountpoints","type":"const char **","info":"list of mount points to be frozen"}},{"$":{"name":"nmountpoints","type":"unsigned int","info":"the number of mount points specified in @mountpoints"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainFSInfoFree","file":"libvirt-domain","module":"libvirt-domain"},"info":["Frees all the memory occupied by @info."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"info","type":"virDomainFSInfoPtr","info":"pointer to a FSInfo object"}}]},{"$":{"name":"virDomainFSThaw","file":"libvirt-domain","module":"libvirt-domain"},"info":["Thaw specified filesystems within the guest. If @mountpoints is NULL and\n@nmountpoints is 0, every mounted filesystem on the guest is thawed.\nIn some drivers (e.g. QEMU driver), @mountpoints may need to be NULL."],"return":[{"$":{"type":"int","info":"the number of thawed filesystems on success, -1 otherwise."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"mountpoints","type":"const char **","info":"list of mount points to be thawed"}},{"$":{"name":"nmountpoints","type":"unsigned int","info":"the number of mount points specified in @mountpoints"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainFSTrim","file":"libvirt-domain","module":"libvirt-domain"},"info":["Calls FITRIM within the guest (hence guest agent may be\nrequired depending on hypervisor used). Either call it on each\nmounted filesystem (@mountPoint is NULL) or just on specified\n@mountPoint. @minimum hints that free ranges smaller than this\nmay be ignored (this is a hint and the guest may not respect\nit).  By increasing this value, the fstrim operation will\ncomplete more quickly for filesystems with badly fragmented\nfree space, although not all blocks will be discarded.\nIf @minimum is not zero, the command may fail."],"return":[{"$":{"type":"int","info":"0 on success, -1 otherwise."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"mountPoint","type":"const char *","info":"which mount point to trim"}},{"$":{"name":"minimum","type":"unsigned long long","info":"Minimum contiguous free range to discard in bytes"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags, not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainFree","file":"libvirt-domain","module":"libvirt-domain"},"info":["Free the domain object. The running instance is kept alive.\nThe data structure is freed and should not be used thereafter."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainGetAutostart","file":"libvirt-domain","module":"libvirt-domain"},"info":["Provides a boolean value indicating whether the domain\nconfigured to be automatically started when the host\nmachine boots."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"autostart","type":"int *","info":"the value returned"}}]},{"$":{"name":"virDomainGetBlkioParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all blkio parameters.  On input, @nparams gives the size of the\n@params array; on output, @nparams gives how many slots were filled\nwith parameter information, which might be less but will not exceed\nthe input value.\n\nAs a special case, calling with @params as NULL and @nparams as 0 on\ninput will cause @nparams on output to contain the number of parameters\nsupported by the hypervisor. The caller should then allocate @params\narray, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\nagain.\n\nSee virDomainGetMemoryParameters() for an equivalent usage example.\n\nThis function may require privileged access to the hypervisor. This function\nexpects the caller to allocate the @params."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to blkio parameter object (return value, allocated by the caller)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of blkio parameters; input and output"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact and virTypedParameterFlags"}}]},{"$":{"name":"virDomainGetBlockInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract information about a domain's block device.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or (since 0.9.5) the device target shorthand\n(the <target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nFor QEMU domains, the allocation and physical virDomainBlockInfo\nvalues returned will generally be the same, except when using a\nnon raw, block backing device, such as qcow2 for an active domain.\nWhen the persistent domain is not active, QEMU will return the\ndefault which is the same value for allocation and physical.\n\nActive QEMU domains can return an allocation value which is more\nrepresentative of the currently used blocks by the device compared\nto the physical size of the device. Applications can use/monitor\nthe allocation value with the understanding that if the domain\nbecomes inactive during an attempt to get the value, the default\nvalues will be returned. Thus, the application should check\nafter the call for the domain being inactive if the values are\nthe same. Optionally, the application could be watching for a\nshutdown event and then ignore any values received afterwards.\nThis can be an issue when a domain is being migrated and the\nexact timing of the domain being made inactive and check of\nthe allocation value results the default being returned. For\na transient domain in the similar situation, this call will return\n-1 and an error message indicating the \"domain is not running\".\n\nThe following is some pseudo code illustrating the call sequence:\n\n  ...\n  virDomainPtr dom;\n  virDomainBlockInfo info;\n  char *device;\n  ...\n  // Either get a list of all domains or a specific domain\n  // via a virDomainLookupBy*() call.\n  //\n  // It's also required to fill in the device pointer, but that's\n  // specific to the implementation. For the purposes of this example\n  // a qcow2 backed device name string would need to be provided.\n  ...\n  // If the following call is made on a persistent domain with a\n  // qcow2 block backed block device, then it's possible the returned\n  // allocation equals the physical value. In that case, the domain\n  // that may have been active prior to calling has become inactive,\n  // such as is the case during a domain migration. Thus once we\n  // get data returned, check for active domain when the values are\n  // the same.\n  if (virDomainGetBlockInfo(dom, device, &info, 0) < 0)\n      goto failure;\n  if (info.allocation == info.physical) {\n      // If the domain is no longer active,\n      // then the defaults are being returned.\n      if (!virDomainIsActive())\n              goto ignore_return;\n  }\n  // Do something with the allocation and physical values\n  ..."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"info","type":"virDomainBlockInfoPtr","info":"pointer to a virDomainBlockInfo structure allocated by the user"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainGetBlockIoTune","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all block IO tunable parameters for a given device.  On input,\n@nparams gives the size of the @params array; on output, @nparams\ngives how many slots were filled with parameter information, which\nmight be less but will not exceed the input value.\n\nAs a special case, calling with @params as NULL and @nparams as 0\non input will cause @nparams on output to contain the number of\nparameters supported by the hypervisor, either for the given @disk\n(note that block devices of different types might support different\nparameters), or if @disk is NULL, for all possible disks. The\ncaller should then allocate @params array,\ni.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\nagain.  See virDomainGetMemoryParameters() for more details.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or the device target shorthand (the <target\ndev='...'/> sub-element, such as \"xvda\").  Valid names can be found\nby calling virDomainGetXMLDesc() and inspecting elements\nwithin //domain/devices/disk.  This parameter cannot be NULL\nunless @nparams is 0 on input."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"Pointer to blkio parameter object (return value, allocated by the caller)"}},{"$":{"name":"nparams","type":"int *","info":"Pointer to number of blkio parameters"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact and virTypedParameterFlags"}}]},{"$":{"name":"virDomainGetBlockJobInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Request block job information for the given disk.  If an operation is active\n@info will be updated with the current progress.  The units used for the\nbandwidth field of @info depends on @flags.  If @flags includes\nVIR_DOMAIN_BLOCK_JOB_INFO_BANDWIDTH_BYTES, bandwidth is in bytes/second\n(although this mode can risk failure due to overflow, depending on both\nclient and server word size); otherwise, the value is rounded up to MiB/s.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or (since 0.9.5) the device target shorthand\n(the <target dev='...'/> sub-element, such as \"vda\").  Valid names\ncan be found by calling virDomainGetXMLDesc() and inspecting\nelements within //domain/devices/disk.\n\nAs a corner case underlying hypervisor may report cur == 0 and\nend == 0 when the block job hasn't been started yet. In this\ncase libvirt reports cur = 0 and end = 1. However, hypervisor\nmay return cur == 0 and end == 0 if the block job has finished\nand was no-op. In this case libvirt reports cur = 1 and end = 1.\nSince 2.3.0."],"return":[{"$":{"type":"int","info":"-1 in case of failure, 0 when nothing found, 1 when info was found."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"info","type":"virDomainBlockJobInfoPtr","info":"pointer to a virDomainBlockJobInfo structure"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainBlockJobInfoFlags"}}]},{"$":{"name":"virDomainGetCPUStats","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get statistics relating to CPU usage attributable to a single\ndomain (in contrast to the statistics returned by\nvirNodeGetCPUStats() for all processes on the host).  @dom\nmust be running (an inactive domain has no attributable cpu\nusage).  On input, @params must contain at least @nparams * @ncpus\nentries, allocated by the caller.\n\nIf @start_cpu is -1, then @ncpus must be 1, and the returned\nresults reflect the statistics attributable to the entire\ndomain (such as user and system time for the process as a\nwhole).  Otherwise, @start_cpu represents which cpu to start\nwith, and @ncpus represents how many consecutive processors to\nquery, with statistics attributable per processor (such as\nper-cpu usage).  If @ncpus is larger than the number of cpus\navailable to query, then the trailing part of the array will\nbe unpopulated.\n\nThe remote driver imposes a limit of 128 @ncpus and 16 @nparams;\nthe number of parameters per cpu should not exceed 16, but if you\nhave a host with more than 128 CPUs, your program should split\nthe request into multiple calls.\n\nAs special cases, if @params is NULL and @nparams is 0 and\n@ncpus is 1, and the return value will be how many\nstatistics are available for the given @start_cpu.  This number\nmay be different for @start_cpu of -1 than for any non-negative\nvalue, but will be the same for all non-negative @start_cpu.\nLikewise, if @params is NULL and @nparams is 0 and @ncpus is 0,\nthe number of cpus available to query is returned.  From the\nhost perspective, this would typically match the cpus member\nof virNodeGetInfo(), but might be less due to host cpu hotplug.\n\nFor now, @flags is unused, and the statistics all relate to the\nusage from the host perspective.  It is possible that a future\nversion will support a flag that queries the cpu usage from the\nguest's perspective, where the maximum cpu to query would be\nrelated to virDomainGetVcpusFlags() rather than virNodeGetInfo().\nAn individual guest vcpu cannot be reliably mapped back to a\nspecific host cpu unless a single-processor vcpu pinning was used,\nbut when @start_cpu is -1, any difference in usage between a host\nand guest perspective would serve as a measure of hypervisor overhead.\n\nTypical use sequence is below.\n\ngetting total stats: set start_cpu as -1, ncpus 1\n\n  virDomainGetCPUStats(dom, NULL, 0, -1, 1, 0); // nparams\n  params = calloc(nparams, sizeof(virTypedParameter))\n  virDomainGetCPUStats(dom, params, nparams, -1, 1, 0); // total stats.\n\ngetting per-cpu stats:\n\n  virDomainGetCPUStats(dom, NULL, 0, 0, 0, 0); // ncpus\n  virDomainGetCPUStats(dom, NULL, 0, 0, 1, 0); // nparams\n  params = calloc(ncpus * nparams, sizeof(virTypedParameter));\n  virDomainGetCPUStats(dom, params, nparams, 0, ncpus, 0); // per-cpu stats"],"return":[{"$":{"type":"int","info":"-1 on failure, or the number of statistics that were populated per cpu on success (this will be less than the total number of populated @params, unless @ncpus was 1; and may be less than @nparams).  The populated parameters start at each stride of @nparams, which means the results may be discontiguous; any unpopulated parameters will be zeroed on success (this includes skipped elements if @nparams is too large, and tail elements if @ncpus is too large).  The caller is responsible for freeing any returned string parameters."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"domain to query"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"array to populate on output"}},{"$":{"name":"nparams","type":"unsigned int","info":"number of parameters per cpu"}},{"$":{"name":"start_cpu","type":"int","info":"which cpu to start with, or -1 for summary"}},{"$":{"name":"ncpus","type":"unsigned int","info":"how many cpus to query"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virTypedParameterFlags"}}]},{"$":{"name":"virDomainGetConnect","file":"libvirt-domain","module":"libvirt-domain"},"info":["Provides the connection pointer associated with a domain.  The\nreference counter on the connection is not increased by this\ncall."],"return":[{"$":{"type":"virConnectPtr","info":"the virConnectPtr or NULL in case of failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to a domain"}}]},{"$":{"name":"virDomainGetControlInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract details about current state of control interface to a domain."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"info","type":"virDomainControlInfoPtr","info":"pointer to a virDomainControlInfo structure allocated by the user"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainGetDiskErrors","file":"libvirt-domain","module":"libvirt-domain"},"info":["The function populates @errors array with all disks that encountered an\nI/O error.  Disks with no error will not be returned in the @errors array.\nEach disk is identified by its target (the dev attribute of target\nsubelement in domain XML), such as \"vda\", and accompanied with the error\nthat was seen on it.  The caller is also responsible for calling free()\non each disk name returned.\n\nIn a special case when @errors is NULL and @maxerrors is 0, the function\nreturns preferred size of @errors that the caller should use to get all\ndisk errors.\n\nSince calling virDomainGetDiskErrors(dom, NULL, 0, 0) to get preferred size\nof @errors array and getting the errors are two separate operations, new\ndisks may be hotplugged to the domain and new errors may be encountered\nbetween the two calls.  Thus, this function may not return all disk errors\nbecause the supplied array is not large enough.  Such errors may, however,\nbe detected by listening to domain events."],"return":[{"$":{"type":"int","info":"number of disks with errors filled in the @errors array or -1 on error."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"errors","type":"virDomainDiskErrorPtr","info":"array to populate on output"}},{"$":{"name":"maxerrors","type":"unsigned int","info":"size of @errors array"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainGetEmulatorPinInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Query the CPU affinity setting of all emulator threads of domain, store\nit in cpumap."],"return":[{"$":{"type":"int","info":"1 in case of success, 0 in case of no emulator threads are pined to pcpus, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"cpumap","type":"unsigned char *","info":"pointer to a bit map of real CPUs for all emulator threads of this domain (in 8-bit bytes) (OUT) There is only one cpumap for all emulator threads. Must not be NULL."}},{"$":{"name":"maplen","type":"int","info":"the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact Must not be VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG concurrently."}}]},{"$":{"name":"virDomainGetFSInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get a list of mapping information for each mounted file systems within the\nspecified guest and the disks."],"return":[{"$":{"type":"int","info":"the number of returned mount points, or -1 in case of error. On success, the array of the information is stored into @info. The caller is responsible for calling virDomainFSInfoFree() on each array element, then calling free() on @info. On error, @info is set to NULL."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"info","type":"virDomainFSInfoPtr **","info":"a pointer to a variable to store an array of mount points information"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainGetGuestVcpus","file":"libvirt-domain","module":"libvirt-domain"},"info":["Queries the guest agent for state and information regarding vCPUs from\nguest's perspective. The reported data depends on the guest agent\nimplementation.\n\nReported fields stored in @params:\n'vcpus': string containing bitmap representing vCPU ids as reported by the\n         guest\n'online': string containing bitmap representing online vCPUs as reported\n          by the guest agent.\n'offlinable': string containing bitmap representing ids of vCPUs that can be\n              offlined\n\nThis API requires the VM to run. The caller is responsible for calling\nvirTypedParamsFree to free memory returned in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer that will be filled with an array of typed parameters"}},{"$":{"name":"nparams","type":"unsigned int *","info":"pointer filled with number of elements in @params"}},{"$":{"name":"flags","type":"unsigned int","info":"currently unused, callers shall pass 0"}}]},{"$":{"name":"virDomainGetHostname","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the hostname for that domain.\n\nDependent on hypervisor used, this may require a guest agent to be\navailable."],"return":[{"$":{"type":"char *","info":"the hostname which must be freed by the caller, or NULL if there was an error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainGetID","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the hypervisor ID number for the domain"],"return":[{"$":{"type":"unsigned int","info":"the domain ID number or (unsigned int) -1 in case of error"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainGetIOThreadInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Fetch IOThreads of an active domain including the cpumap information to\ndetermine on which CPU the IOThread has affinity to run."],"return":[{"$":{"type":"int","info":"the number of IOThreads or -1 in case of error. On success, the array of information is stored into @info. The caller is responsible for calling virDomainIOThreadInfoFree() on each array element, then calling free() on @info. On error, @info is set to NULL."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"info","type":"virDomainIOThreadInfoPtr **","info":"pointer to an array of virDomainIOThreadInfo structures (OUT)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact Must not be VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG concurrently."}}]},{"$":{"name":"virDomainGetInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract information about a domain. Note that if the connection\nused to get the domain is limited only a partial set of the information\ncan be extracted."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"info","type":"virDomainInfoPtr","info":"pointer to a virDomainInfo structure allocated by the user"}}]},{"$":{"name":"virDomainGetInterfaceParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all interface parameters. On input, @nparams gives the size of\nthe @params array; on output, @nparams gives how many slots were\nfilled with parameter information, which might be less but will not\nexceed the input value.\n\nAs a special case, calling with @params as NULL and @nparams as 0 on\ninput will cause @nparams on output to contain the number of parameters\nsupported by the hypervisor. The caller should then allocate @params\narray, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the\nAPI again. See virDomainGetMemoryParameters() for an equivalent usage\nexample.\n\nThis function may require privileged access to the hypervisor. This function\nexpects the caller to allocate the @params."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"device","type":"const char *","info":"the interface name or mac address"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to interface parameter objects (return value, allocated by the caller)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of interface parameter; input and output"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact and virTypedParameterFlags"}}]},{"$":{"name":"virDomainGetJobInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract information about progress of a background job on a domain.\nWill return an error if the domain is not active.\n\nThis function returns a limited amount of information in comparison\nto virDomainGetJobStats()."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"info","type":"virDomainJobInfoPtr","info":"pointer to a virDomainJobInfo structure allocated by the user"}}]},{"$":{"name":"virDomainGetJobStats","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract information about progress of a background job on a domain.\nWill return an error if the domain is not active. The function returns\na superset of progress information provided by virDomainGetJobInfo.\nPossible fields returned in @params are defined by VIR_DOMAIN_JOB_*\nmacros and new fields will likely be introduced in the future so callers\nmay receive fields that they do not understand in case they talk to a\nnewer server.\n\nWhen @flags contains VIR_DOMAIN_JOB_STATS_COMPLETED, the function will\nreturn statistics about a recently completed job. Specifically, this\nflag may be used to query statistics of a completed incoming pre-copy\nmigration (statistics for post-copy migration are only available on the\nsource hsot). Statistics of a completed job are automatically destroyed\nonce read or when libvirtd is restarted. Note that time information\nreturned for completed migrations may be completely irrelevant unless both\nsource and destination hosts have synchronized time (i.e., NTP daemon is\nrunning on both of them). The statistics of a completed job can also be\nobtained by listening to a VIR_DOMAIN_EVENT_ID_JOB_COMPLETED event (on the\nsource host in case of a migration job)."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"type","type":"int *","info":"where to store the job type (one of virDomainJobType)"}},{"$":{"name":"params","type":"virTypedParameterPtr *","info":"where to store job statistics"}},{"$":{"name":"nparams","type":"int *","info":"number of items in @params"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainGetJobStatsFlags"}}]},{"$":{"name":"virDomainGetMaxMemory","file":"libvirt-domain","module":"libvirt-domain"},"info":["Retrieve the maximum amount of physical memory allocated to a\ndomain. If domain is NULL, then this get the amount of memory reserved\nto Domain0 i.e. the domain where the application runs."],"return":[{"$":{"type":"unsigned long","info":"the memory size in kibibytes (blocks of 1024 bytes), or 0 in case of error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object or NULL"}}]},{"$":{"name":"virDomainGetMaxVcpus","file":"libvirt-domain","module":"libvirt-domain"},"info":["Provides the maximum number of virtual CPUs supported for\nthe guest VM. If the guest is inactive, this is basically\nthe same as virConnectGetMaxVcpus(). If the guest is running\nthis will reflect the maximum number of virtual CPUs the\nguest was booted with.  For more details, see virDomainGetVcpusFlags()."],"return":[{"$":{"type":"int","info":"the maximum of virtual CPU or -1 in case of error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}}]},{"$":{"name":"virDomainGetMemoryParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all memory parameters.  On input, @nparams gives the size of the\n@params array; on output, @nparams gives how many slots were filled\nwith parameter information, which might be less but will not exceed\nthe input value.\n\nAs a special case, calling with @params as NULL and @nparams as 0 on\ninput will cause @nparams on output to contain the number of parameters\nsupported by the hypervisor. The caller should then allocate @params\narray, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\nagain.\n\nHere is a sample code snippet:\n\n  if (virDomainGetMemoryParameters(dom, NULL, &nparams, 0) == 0 &&\n      nparams != 0) {\n      if ((params = malloc(sizeof(*params) * nparams)) == NULL)\n          goto error;\n      memset(params, 0, sizeof(*params) * nparams);\n      if (virDomainGetMemoryParameters(dom, params, &nparams, 0))\n          goto error;\n  }\n\nThis function may require privileged access to the hypervisor. This function\nexpects the caller to allocate the @params."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to memory parameter object (return value, allocated by the caller)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of memory parameters; input and output"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact and virTypedParameterFlags"}}]},{"$":{"name":"virDomainGetMetadata","file":"libvirt-domain","module":"libvirt-domain"},"info":["Retrieves the appropriate domain element given by @type.\nIf VIR_DOMAIN_METADATA_ELEMENT is requested parameter @uri\nmust be set to the name of the namespace the requested elements\nbelong to, otherwise must be NULL.\n\nIf an element of the domain XML is not present, the resulting\nerror will be VIR_ERR_NO_DOMAIN_METADATA.  This method forms\na shortcut for seeing information from virDomainSetMetadata()\nwithout having to go through virDomainGetXMLDesc().\n\n@flags controls whether the live domain or persistent\nconfiguration will be queried."],"return":[{"$":{"type":"char *","info":"the metadata string on success (caller must free), or NULL in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"type","type":"int","info":"type of metadata, from virDomainMetadataType"}},{"$":{"name":"uri","type":"const char *","info":"XML namespace identifier"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainGetName","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the public name for that domain"],"return":[{"$":{"type":"const char *","info":"a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainGetNumaParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all numa parameters.  On input, @nparams gives the size of the\n@params array; on output, @nparams gives how many slots were filled\nwith parameter information, which might be less but will not exceed\nthe input value.\n\nAs a special case, calling with @params as NULL and @nparams as 0 on\ninput will cause @nparams on output to contain the number of parameters\nsupported by the hypervisor. The caller should then allocate @params\narray, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\nagain.\n\nSee virDomainGetMemoryParameters() for an equivalent usage example.\n\nThis function may require privileged access to the hypervisor. This function\nexpects the caller to allocate the @params."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to numa parameter object (return value, allocated by the caller)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of numa parameters"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact and virTypedParameterFlags"}}]},{"$":{"name":"virDomainGetOSType","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the type of domain operation system."],"return":[{"$":{"type":"char *","info":"the new string or NULL in case of error, the string must be freed by the caller."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainGetPerfEvents","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all Linux perf events setting. Possible fields returned in\n@params are defined by VIR_PERF_EVENT_* macros and new fields\nwill likely be introduced in the future.\n\nLinux perf events are performance analyzing tool in Linux."],"return":[{"$":{"type":"int","info":"-1 in case of failure, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr *","info":"where to store perf events setting"}},{"$":{"name":"nparams","type":"int *","info":"number of items in @params"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainGetSchedulerParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all scheduler parameters.  On input, @nparams gives the size of the\n@params array; on output, @nparams gives how many slots were filled\nwith parameter information, which might be less but will not exceed\nthe input value.  @nparams cannot be 0.\n\nIt is hypervisor specific whether this returns the live or\npersistent state; for more control, use\nvirDomainGetSchedulerParametersFlags()."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to scheduler parameter objects (return value)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of scheduler parameter objects (this value should generally be as large as the returned value nparams of virDomainGetSchedulerType()); input and output"}}]},{"$":{"name":"virDomainGetSchedulerParametersFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get all scheduler parameters.  On input, @nparams gives the size of the\n@params array; on output, @nparams gives how many slots were filled\nwith parameter information, which might be less but will not exceed\nthe input value.  @nparams cannot be 0.\n\nThe value of @flags can be exactly VIR_DOMAIN_AFFECT_CURRENT,\nVIR_DOMAIN_AFFECT_LIVE, or VIR_DOMAIN_AFFECT_CONFIG.\n\nHere is a sample code snippet:\n\n  char *ret = virDomainGetSchedulerType(dom, &nparams);\n  if (ret && nparams != 0) {\n      if ((params = malloc(sizeof(*params) * nparams)) == NULL)\n          goto error;\n      memset(params, 0, sizeof(*params) * nparams);\n      if (virDomainGetSchedulerParametersFlags(dom, params, &nparams, 0))\n          goto error;\n  }"],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to scheduler parameter object (return value)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType()); input and output"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact and virTypedParameterFlags"}}]},{"$":{"name":"virDomainGetSchedulerType","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the scheduler type and the number of scheduler parameters."],"return":[{"$":{"type":"char *","info":"NULL in case of error. The caller must free the returned string."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of scheduler parameters, can be NULL (return value)"}}]},{"$":{"name":"virDomainGetSecurityLabel","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract security label of an active domain. The 'label' field\nin the @seclabel argument will be initialized to the empty\nstring if the domain is not running under a security model."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"seclabel","type":"virSecurityLabelPtr","info":"pointer to a virSecurityLabel structure"}}]},{"$":{"name":"virDomainGetSecurityLabelList","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract the security labels of an active domain. The 'label' field\nin the @seclabels argument will be initialized to the empty\nstring if the domain is not running under a security model."],"return":[{"$":{"type":"int","info":"number of elemnets in @seclabels on success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"seclabels","type":"virSecurityLabelPtr *","info":"will be auto-allocated and filled with domains' security labels. Caller must free memory on return."}}]},{"$":{"name":"virDomainGetState","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract domain state. Each state can be accompanied with a reason (if known)\nwhich led to the state."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"state","type":"int *","info":"returned state of the domain (one of virDomainState)"}},{"$":{"name":"reason","type":"int *","info":"returned reason which led to @state (one of virDomain*Reason corresponding to the current state); it is allowed to be NULL"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainGetTime","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract information about guest time and store it into\n@seconds and @nseconds. The @seconds represents the number of\nseconds since the UNIX Epoch of 1970-01-01 00:00:00 in UTC.\n\nPlease note that some hypervisors may require guest agent to\nbe configured and running in order to run this API."],"return":[{"$":{"type":"int","info":"0 on success, -1 otherwise."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"seconds","type":"long long *","info":"domain's time in seconds"}},{"$":{"name":"nseconds","type":"unsigned int *","info":"the nanoscond part of @seconds"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainGetUUID","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the UUID for a domain"],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"uuid","type":"unsigned char *","info":"pointer to a VIR_UUID_BUFLEN bytes array"}}]},{"$":{"name":"virDomainGetUUIDString","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the UUID for a domain as string. For more information about\nUUID see RFC4122."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"buf","type":"char *","info":"pointer to a VIR_UUID_STRING_BUFLEN bytes array"}}]},{"$":{"name":"virDomainGetVcpuPinInfo","file":"libvirt-domain","module":"libvirt-domain"},"info":["Query the CPU affinity setting of all virtual CPUs of domain, store it\nin cpumaps."],"return":[{"$":{"type":"int","info":"the number of virtual CPUs in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"ncpumaps","type":"int","info":"the number of cpumap (listed first to match virDomainGetVcpus)"}},{"$":{"name":"cpumaps","type":"unsigned char *","info":"pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) It's assumed there is <ncpumaps> cpumap in cpumaps array. The memory allocated to cpumaps must be (ncpumaps * maplen) bytes (ie: calloc(ncpumaps, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API. Must not be NULL."}},{"$":{"name":"maplen","type":"int","info":"the number of bytes in one cpumap, from 1 up to size of CPU map. Must be positive."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact Must not be VIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG concurrently."}}]},{"$":{"name":"virDomainGetVcpus","file":"libvirt-domain","module":"libvirt-domain"},"info":["Extract information about virtual CPUs of domain, store it in info array\nand also in cpumaps if this pointer isn't NULL.  This call may fail\non an inactive domain.\n\nSee also virDomainGetVcpuPinInfo for querying just cpumaps, including on\nan inactive domain."],"return":[{"$":{"type":"int","info":"the number of info filled in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"info","type":"virVcpuInfoPtr","info":"pointer to an array of virVcpuInfo structures (OUT)"}},{"$":{"name":"maxinfo","type":"int","info":"number of structures in info array"}},{"$":{"name":"cpumaps","type":"unsigned char *","info":"pointer to a bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cpumap information is returned by the API. It's assumed there is <maxinfo> cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API."}},{"$":{"name":"maplen","type":"int","info":"number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). Must be zero when cpumaps is NULL and positive when it is non-NULL."}}]},{"$":{"name":"virDomainGetVcpusFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Query the number of virtual CPUs used by the domain.  Note that\nthis call may fail if the underlying virtualization hypervisor does\nnot support it.  This function may require privileged access to the\nhypervisor.\n\nIf @flags includes VIR_DOMAIN_AFFECT_LIVE, this will query a\nrunning domain (which will fail if domain is not active); if\nit includes VIR_DOMAIN_AFFECT_CONFIG, this will query the XML\ndescription of the domain.  It is an error to set both flags.\nIf neither flag is set (that is, VIR_DOMAIN_AFFECT_CURRENT),\nthen the configuration queried depends on whether the domain\nis currently running.\n\nIf @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then the maximum\nvirtual CPU limit is queried.  Otherwise, this call queries the\ncurrent virtual CPU count.\n\nIf @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of the processors\nis queried in the guest instead of the hypervisor. This flag is only usable\non live domains. Guest agent may be needed for this flag to be available."],"return":[{"$":{"type":"int","info":"the number of vCPUs in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainVcpuFlags"}}]},{"$":{"name":"virDomainGetXMLDesc","file":"libvirt-domain","module":"libvirt-domain"},"info":["Provide an XML description of the domain. The description may be reused\nlater to relaunch the domain with virDomainCreateXML().\n\nNo security-sensitive data will be included unless @flags contains\nVIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\nconnections.  If @flags includes VIR_DOMAIN_XML_INACTIVE, then the\nXML represents the configuration that will be used on the next boot\nof a persistent domain; otherwise, the configuration represents the\ncurrently running domain.  If @flags contains\nVIR_DOMAIN_XML_UPDATE_CPU, then the portion of the domain XML\ndescribing CPU capabilities is modified to match actual\ncapabilities of the host."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainXMLFlags"}}]},{"$":{"name":"virDomainHasCurrentSnapshot","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Determine if the domain has a current snapshot."],"return":[{"$":{"type":"int","info":"1 if such snapshot exists, 0 if it doesn't, -1 on error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainHasManagedSaveImage","file":"libvirt-domain","module":"libvirt-domain"},"info":["Check if a domain has a managed save image as created by\nvirDomainManagedSave(). Note that any running domain should not have\nsuch an image, as it should have been removed on restart."],"return":[{"$":{"type":"int","info":"0 if no image is present, 1 if an image is present, and -1 in case of error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainIOThreadInfoFree","file":"libvirt-domain","module":"libvirt-domain"},"info":["Frees the memory used by @info."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"info","type":"virDomainIOThreadInfoPtr","info":"pointer to a virDomainIOThreadInfo object"}}]},{"$":{"name":"virDomainInjectNMI","file":"libvirt-domain","module":"libvirt-domain"},"info":["Send NMI to the guest"],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainInterfaceAddresses","file":"libvirt-domain","module":"libvirt-domain"},"info":["Return a pointer to the allocated array of pointers to interfaces\npresent in given domain along with their IP and MAC addresses. Note that\nsingle interface can have multiple or even 0 IP addresses.\n\nThis API dynamically allocates the virDomainInterfacePtr struct based on\nhow many interfaces domain @dom has, usually there's 1:1 correlation. The\ncount of the interfaces is returned as the return value.\n\nIf @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE, the DHCP lease\nfile associated with any virtual networks will be examined to obtain\nthe interface addresses. This only returns data for interfaces which\nare connected to virtual networks managed by libvirt.\n\nIf @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_AGENT, a configured\nguest agent is needed for successful return from this API. Moreover, if\nguest agent is used then the interface name is the one seen by guest OS.\nTo match such interface with the one from @dom XML use MAC address or IP\nrange.\n\nIf @source is VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_ARP, the host\nARP table will be check to obtain the interface addresses. As\nthe arp cache refreshes in time, the returned ip address may\nbe unreachable. Depending on the route table config of the\nguest, the returned mac address may be duplicated.\n\n@ifaces->name and @ifaces->hwaddr are never NULL.\n\nThe caller *must* free @ifaces when no longer needed. Usual use case\nlooks like this:\n\n  virDomainInterfacePtr *ifaces = NULL;\n  int ifaces_count = 0;\n  size_t i, j;\n  virDomainPtr dom = ... obtain a domain here ...;\n\n  if ((ifaces_count = virDomainInterfaceAddresses(dom, &ifaces,\n           VIR_DOMAIN_INTERFACE_ADDRESSES_SRC_LEASE)) < 0)\n      goto cleanup;\n\n ... do something with returned values, for example:\n\n  for (i = 0; i < ifaces_count; i++) {\n      printf(\"name: %s\", ifaces[i]->name);\n      if (ifaces[i]->hwaddr)\n          printf(\" hwaddr: %s\", ifaces[i]->hwaddr);\n\n      for (j = 0; j < ifaces[i]->naddrs; j++) {\n          virDomainIPAddressPtr ip_addr = ifaces[i]->addrs + j;\n          printf(\"[addr: %s prefix: %d type: %d]\",\n                 ip_addr->addr, ip_addr->prefix, ip_addr->type);\n      }\n      printf(\"\\n\");\n  }\n\n  cleanup:\n      if (ifaces && ifaces_count > 0)\n          for (i = 0; i < ifaces_count; i++)\n              virDomainInterfaceFree(ifaces[i]);\n      free(ifaces);"],"return":[{"$":{"type":"int","info":"the number of interfaces on success, -1 in case of error."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"domain object"}},{"$":{"name":"ifaces","type":"virDomainInterfacePtr **","info":"pointer to an array of pointers pointing to interface objects"}},{"$":{"name":"source","type":"unsigned int","info":"one of the virDomainInterfaceAddressesSource constants"}},{"$":{"name":"flags","type":"unsigned int","info":"currently unused, pass zero"}}]},{"$":{"name":"virDomainInterfaceFree","file":"libvirt-domain","module":"libvirt-domain"},"info":["Free the interface object. The data structure is\nfreed and should not be used thereafter. If @iface\nis NULL, then this method has no effect."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"iface","type":"virDomainInterfacePtr","info":"an interface object"}}]},{"$":{"name":"virDomainInterfaceStats","file":"libvirt-domain","module":"libvirt-domain"},"info":["This function returns network interface stats for interfaces\nattached to the domain.\n\nThe @device parameter is the network interface either by name or MAC\naddress.\n\nDomains may have more than one network interface.  To get stats for\neach you should make multiple calls to this function.\n\nIndividual fields within the stats structure may be returned\nas -1, which indicates that the hypervisor does not support\nthat particular statistic.\n\nThe returned stats are from domain's point of view."],"return":[{"$":{"type":"int","info":"0 in case of success or -1 in case of failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"device","type":"const char *","info":"the interface name or MAC address"}},{"$":{"name":"stats","type":"virDomainInterfaceStatsPtr","info":"network interface stats (returned)"}},{"$":{"name":"size","type":"size_t","info":"size of stats structure"}}]},{"$":{"name":"virDomainIsActive","file":"libvirt-domain","module":"libvirt-domain"},"info":["Determine if the domain is currently running"],"return":[{"$":{"type":"int","info":"1 if running, 0 if inactive, -1 on error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}}]},{"$":{"name":"virDomainIsPersistent","file":"libvirt-domain","module":"libvirt-domain"},"info":["Determine if the domain has a persistent configuration\nwhich means it will still exist after shutting down"],"return":[{"$":{"type":"int","info":"1 if persistent, 0 if transient, -1 on error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}}]},{"$":{"name":"virDomainIsUpdated","file":"libvirt-domain","module":"libvirt-domain"},"info":["Determine if the domain has been updated."],"return":[{"$":{"type":"int","info":"1 if updated, 0 if not, -1 on error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}}]},{"$":{"name":"virDomainListAllSnapshots","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Collect the list of domain snapshots for the given domain, and allocate\nan array to store those objects.  This API solves the race inherent in\nvirDomainSnapshotListNames().\n\nBy default, this command covers all snapshots; it is also possible to\nlimit things to just snapshots with no parents, when @flags includes\nVIR_DOMAIN_SNAPSHOT_LIST_ROOTS.  Additional filters are provided in\ngroups, where each group contains bits that describe mutually exclusive\nattributes of a snapshot, and where all bits within a group describe\nall possible snapshots.  Some hypervisors might reject explicit bits\nfrom a group where the hypervisor cannot make a distinction.  For a\ngroup supported by a given hypervisor, the behavior when no bits of a\ngroup are set is identical to the behavior when all bits in that group\nare set.  When setting bits from more than one group, it is possible to\nselect an impossible combination, in that case a hypervisor may return\neither 0 or an error.\n\nThe first group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_LEAVES and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that\nhave no further children (a leaf snapshot).\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_METADATA and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on\nwhether they have metadata that would prevent the removal of the last\nreference to a domain.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,\nVIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,\nfor filtering snapshots based on what domain state is tracked by the\nsnapshot.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL and\nVIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on\nwhether the snapshot is stored inside the disk images or as\nadditional files."],"return":[{"$":{"type":"int","info":"the number of domain snapshots found or -1 and sets @snaps to NULL in case of error.  On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virDomainSnapshotFree() on each array element, then calling free() on @snaps."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"snaps","type":"virDomainSnapshotPtr **","info":"pointer to variable to store the array containing snapshot objects, or NULL if the list is not required (just returns number of snapshots)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainSnapshotListFlags"}}]},{"$":{"name":"virDomainListGetStats","file":"libvirt-domain","module":"libvirt-domain"},"info":["Query statistics for domains provided by @doms. Note that all domains in\n@doms must share the same connection.\n\nReport statistics of various parameters for a running VM according to @stats\nfield. The statistics are returned as an array of structures for each queried\ndomain. The structure contains an array of typed parameters containing the\nindividual statistics. The typed parameter name for each statistic field\nconsists of a dot-separated string containing name of the requested group\nfollowed by a group specific description of the statistic value.\n\nThe statistic groups are enabled using the @stats parameter which is a\nbinary-OR of enum virDomainStatsTypes. The stats groups are documented\nin virConnectGetAllDomainStats.\n\nUsing 0 for @stats returns all stats groups supported by the given\nhypervisor.\n\nSpecifying VIR_CONNECT_GET_ALL_DOMAINS_STATS_ENFORCE_STATS as @flags makes\nthe function return error in case some of the stat types in @stats were\nnot recognized by the daemon.  However, even with this flag, a hypervisor\nmay omit individual fields within a known group if the information is not\navailable; as an extreme example, a supported group may produce zero\nfields for offline domains if the statistics are meaningful only for a\nrunning domain.\n\nNote that any of the domain list filtering flags in @flags may be rejected\nby this function."],"return":[{"$":{"type":"int","info":"the count of returned statistics structures on success, -1 on error. The requested data are returned in the @retStats parameter. The returned array should be freed by the caller. See virDomainStatsRecordListFree. Note that the count of returned stats may be less than the domain count provided via @doms."}}],"arg":[{"$":{"name":"doms","type":"virDomainPtr *","info":"NULL terminated array of domains"}},{"$":{"name":"stats","type":"unsigned int","info":"stats to return, binary-OR of virDomainStatsTypes"}},{"$":{"name":"retStats","type":"virDomainStatsRecordPtr **","info":"Pointer that will be filled with the array of returned stats"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; binary-OR of virConnectGetAllDomainStatsFlags"}}]},{"$":{"name":"virDomainLookupByID","file":"libvirt-domain","module":"libvirt-domain"},"info":["Try to find a domain based on the hypervisor ID number\nNote that this won't work for inactive domains which have an ID of -1,\nin that case a lookup based on the Name or UUId need to be done instead.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"id","type":"int","info":"the domain ID number"}}]},{"$":{"name":"virDomainLookupByName","file":"libvirt-domain","module":"libvirt-domain"},"info":["Try to lookup a domain on the given hypervisor based on its name.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"name","type":"const char *","info":"name for the domain"}}]},{"$":{"name":"virDomainLookupByUUID","file":"libvirt-domain","module":"libvirt-domain"},"info":["Try to lookup a domain on the given hypervisor based on its UUID.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuid","type":"const unsigned char *","info":"the raw UUID for the domain"}}]},{"$":{"name":"virDomainLookupByUUIDString","file":"libvirt-domain","module":"libvirt-domain"},"info":["Try to lookup a domain on the given hypervisor based on its UUID.\n\nvirDomainFree should be used to free the resources after the\ndomain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuidstr","type":"const char *","info":"the string UUID for the domain"}}]},{"$":{"name":"virDomainManagedSave","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will suspend a domain and save its memory contents to\na file on disk. After the call, if successful, the domain is not\nlisted as running anymore.\nThe difference from virDomainSave() is that libvirt is keeping track of\nthe saved state itself, and will reuse it once the domain is being\nrestarted (automatically or via an explicit libvirt call).\nAs a result any running domain is sure to not have a managed saved image.\nThis also implies that managed save only works on persistent domains,\nsince the domain must still exist in order to use virDomainCreate() to\nrestart it.\n\nIf @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\nattempt to bypass the file system cache while creating the file, or\nfail if it cannot do so for the given system; this can allow less\npressure on file system cache, but also risks slowing saves to NFS.\n\nNormally, the managed saved state will remember whether the domain\nwas running or paused, and start will resume to the same state.\nSpecifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n@flags will override the default saved into the file.  These two\nflags are mutually exclusive."],"return":[{"$":{"type":"int","info":"0 in case of success or -1 in case of failure"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSaveRestoreFlags"}}]},{"$":{"name":"virDomainManagedSaveDefineXML","file":"libvirt-domain","module":"libvirt-domain"},"info":["This updates the definition of a domain stored in a saved state\nfile.\n\n@dxml can be used to alter host-specific portions of the domain XML\nthat will be used on the next start of the domain. For example, it is\npossible to alter the backing filename that is associated with a\ndisk device.\n\nNormally, the saved state file will remember whether the domain was\nrunning or paused, and restore defaults to the same state.\nSpecifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n@flags will override the default saved into the file; omitting both\nleaves the file's default unchanged.  These two flags are mutually\nexclusive."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"dxml","type":"const char *","info":"XML config for adjusting guest xml used on restore"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSaveRestoreFlags"}}]},{"$":{"name":"virDomainManagedSaveGetXMLDesc","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will extract the XML description of the managed save\nstate file of a domain.\n\nNo security-sensitive data will be included unless @flags contains\nVIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\nconnections.  For this API, @flags should not contain either\nVIR_DOMAIN_XML_INACTIVE or VIR_DOMAIN_XML_UPDATE_CPU."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.  The caller must free() the returned value."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of subset of virDomainXMLFlags"}}]},{"$":{"name":"virDomainManagedSaveRemove","file":"libvirt-domain","module":"libvirt-domain"},"info":["Remove any managed save image for this domain."],"return":[{"$":{"type":"int","info":"0 in case of success, and -1 in case of error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMemoryPeek","file":"libvirt-domain","module":"libvirt-domain"},"info":["This function allows you to read the contents of a domain's\nmemory.\n\nThe memory which is read is controlled by the 'start', 'size'\nand 'flags' parameters.\n\nIf 'flags' is VIR_MEMORY_VIRTUAL then the 'start' and 'size'\nparameters are interpreted as virtual memory addresses for\nwhichever task happens to be running on the domain at the\nmoment.  Although this sounds haphazard it is in fact what\nyou want in order to read Linux kernel state, because it\nensures that pointers in the kernel image can be interpreted\ncoherently.\n\n'buffer' is the return buffer and must be at least 'size' bytes.\n'size' may be 0 to test if the call would succeed.\n\nNB. The remote driver imposes a 64K byte limit on 'size'.\nFor your program to be able to work reliably over a remote\nconnection you should split large requests to <= 65536 bytes.\nHowever, with 0.9.13 this RPC limit has been raised to 1M byte.\nStarting with version 1.0.6 the RPC limit has been raised again.\nNow large requests up to 16M byte are supported."],"return":[{"$":{"type":"int","info":"0 in case of success or -1 in case of failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"start","type":"unsigned long long","info":"start of memory to peek"}},{"$":{"name":"size","type":"size_t","info":"size of memory to peek"}},{"$":{"name":"buffer","type":"void *","info":"return buffer (must be at least size bytes)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainMemoryFlags"}}]},{"$":{"name":"virDomainMemoryStats","file":"libvirt-domain","module":"libvirt-domain"},"info":["This function provides memory statistics for the domain.\n\nUp to 'nr_stats' elements of 'stats' will be populated with memory statistics\nfrom the domain.  Only statistics supported by the domain, the driver, and\nthis version of libvirt will be returned.\n\nMemory Statistics:\n\nVIR_DOMAIN_MEMORY_STAT_SWAP_IN:\n    The total amount of data read from swap space (in kb).\nVIR_DOMAIN_MEMORY_STAT_SWAP_OUT:\n    The total amount of memory written out to swap space (in kb).\nVIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT:\n    The number of page faults that required disk IO to service.\nVIR_DOMAIN_MEMORY_STAT_MINOR_FAULT:\n    The number of page faults serviced without disk IO.\nVIR_DOMAIN_MEMORY_STAT_UNUSED:\n    The amount of memory which is not being used for any purpose (in kb).\nVIR_DOMAIN_MEMORY_STAT_AVAILABLE:\n    The total amount of memory available to the domain's OS (in kb).\nVIR_DOMAIN_MEMORY_STAT_USABLE:\n    How much the balloon can be inflated without pushing the guest system\n    to swap, corresponds to 'Available' in /proc/meminfo\nVIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON:\n    Current balloon value (in kb).\nVIR_DOMAIN_MEMORY_STAT_LAST_UPDATE\n    Timestamp of the last statistic"],"return":[{"$":{"type":"int","info":"The number of stats provided or -1 in case of failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"stats","type":"virDomainMemoryStatPtr","info":"nr_stats-sized array of stat structures (returned)"}},{"$":{"name":"nr_stats","type":"unsigned int","info":"number of memory statistics requested"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrate","file":"libvirt-domain","module":"libvirt-domain"},"info":["Migrate the domain object from its current host to the destination\nhost given by dconn (a connection to the destination host).\n\nThis function is similar to virDomainMigrate3, but it only supports a fixed\nset of parameters: @dname corresponds to VIR_MIGRATE_PARAM_DEST_NAME, @uri\nis VIR_MIGRATE_PARAM_URI, and @bandwidth is VIR_MIGRATE_PARAM_BANDWIDTH.\n\nvirDomainFree should be used to free the resources after the\nreturned domain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn)."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"dconn","type":"virConnectPtr","info":"destination host (a connection object)"}},{"$":{"name":"flags","type":"unsigned long","info":"bitwise-OR of virDomainMigrateFlags"}},{"$":{"name":"dname","type":"const char *","info":"(optional) rename domain to this at destination"}},{"$":{"name":"uri","type":"const char *","info":"(optional) dest hostname/URI as seen from the source host"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"(optional) specify migration bandwidth limit in MiB/s"}}]},{"$":{"name":"virDomainMigrate2","file":"libvirt-domain","module":"libvirt-domain"},"info":["Migrate the domain object from its current host to the destination\nhost given by dconn (a connection to the destination host).\n\nThis function is similar to virDomainMigrate3, but it only supports a fixed\nset of parameters: @dxml corresponds to VIR_MIGRATE_PARAM_DEST_XML, @dname\nis VIR_MIGRATE_PARAM_DEST_NAME, @uri is VIR_MIGRATE_PARAM_URI, and\n@bandwidth is VIR_MIGRATE_PARAM_BANDWIDTH.\n\nvirDomainFree should be used to free the resources after the\nreturned domain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn)."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"dconn","type":"virConnectPtr","info":"destination host (a connection object)"}},{"$":{"name":"dxml","type":"const char *","info":"(optional) XML config for launching guest on target"}},{"$":{"name":"flags","type":"unsigned long","info":"bitwise-OR of virDomainMigrateFlags"}},{"$":{"name":"dname","type":"const char *","info":"(optional) rename domain to this at destination"}},{"$":{"name":"uri","type":"const char *","info":"(optional) dest hostname/URI as seen from the source host"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"(optional) specify migration bandwidth limit in MiB/s"}}]},{"$":{"name":"virDomainMigrate3","file":"libvirt-domain","module":"libvirt-domain"},"info":["Migrate the domain object from its current host to the destination host\ngiven by dconn (a connection to the destination host).\n\nSee VIR_MIGRATE_PARAM_* and virDomainMigrateFlags for detailed description\nof accepted migration parameters and flags.\n\nSee virDomainMigrateFlags documentation for description of individual flags.\n\nVIR_MIGRATE_TUNNELLED and VIR_MIGRATE_PEER2PEER are not supported by this\nAPI, use virDomainMigrateToURI3 instead.\n\nThere are many limitations on migration imposed by the underlying\ntechnology - for example it may not be possible to migrate between\ndifferent processors even with the same architecture, or between\ndifferent types of hypervisor.\n\nvirDomainFree should be used to free the resources after the\nreturned domain object is no longer needed."],"return":[{"$":{"type":"virDomainPtr","info":"the new domain object if the migration was successful, or NULL in case of error.  Note that the new domain object exists in the scope of the destination connection (dconn)."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"dconn","type":"virConnectPtr","info":"destination host (a connection object)"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"(optional) migration parameters"}},{"$":{"name":"nparams","type":"unsigned int","info":"(optional) number of migration parameters in @params"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainMigrateFlags"}}]},{"$":{"name":"virDomainMigrateGetCompressionCache","file":"libvirt-domain","module":"libvirt-domain"},"info":["Gets current size of the cache (in bytes) used for compressing repeatedly\ntransferred memory pages during live migration."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 otherwise."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"cacheSize","type":"unsigned long long *","info":"return value of current size of the cache (in bytes)"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrateGetMaxDowntime","file":"libvirt-domain","module":"libvirt-domain"},"info":["Gets current maximum tolerable time for which the domain may be paused\nat the end of live migration."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 otherwise."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"downtime","type":"unsigned long long *","info":"return value of the maximum tolerable downtime for live migration, in milliseconds"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrateGetMaxSpeed","file":"libvirt-domain","module":"libvirt-domain"},"info":["Get the current maximum bandwidth (in MiB/s) that will be used if the\ndomain is migrated.  Not all hypervisors will support a bandwidth limit."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 otherwise."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"bandwidth","type":"unsigned long *","info":"return value of current migration bandwidth limit in MiB/s"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrateSetCompressionCache","file":"libvirt-domain","module":"libvirt-domain"},"info":["Sets size of the cache (in bytes) used for compressing repeatedly\ntransferred memory pages during live migration. It's supposed to be called\nwhile the domain is being live-migrated as a reaction to migration progress\nand increasing number of compression cache misses obtained from\nvirDomainGetJobStats."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 otherwise."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"cacheSize","type":"unsigned long long","info":"size of the cache (in bytes) used for compression"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrateSetMaxDowntime","file":"libvirt-domain","module":"libvirt-domain"},"info":["Sets maximum tolerable time for which the domain is allowed to be paused\nat the end of live migration. It's supposed to be called while the domain is\nbeing live-migrated as a reaction to migration progress."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 otherwise."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"downtime","type":"unsigned long long","info":"maximum tolerable downtime for live migration, in milliseconds"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrateSetMaxSpeed","file":"libvirt-domain","module":"libvirt-domain"},"info":["The maximum bandwidth (in MiB/s) that will be used to do migration\ncan be specified with the bandwidth parameter. Not all hypervisors\nwill support a bandwidth cap"],"return":[{"$":{"type":"int","info":"0 in case of success, -1 otherwise."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"migration bandwidth limit in MiB/s"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrateStartPostCopy","file":"libvirt-domain","module":"libvirt-domain"},"info":["Starts post-copy migration. This function has to be called while\nmigration (initiated with VIR_MIGRATE_POSTCOPY flag) is in progress.\n\nTraditional pre-copy migration iteratively walks through guest memory\npages and migrates those that changed since the previous iteration. The\niterative phase stops when the number of dirty pages is low enough so that\nthe virtual CPUs can be paused, all dirty pages transferred to the\ndestination, where the virtual CPUs are unpaused, and all this can happen\nwithin a predefined downtime period. It's clear that this process may never\nconverge if downtime is too short and/or the guest keeps changing a lot of\nmemory pages.\n\nWhen migration is switched to post-copy mode, the virtual CPUs are paused\nimmediately, only a minimum set of pages is transferred, and the CPUs are\nunpaused on destination. The source keeps sending all remaining memory pages\nto the destination while the guest is already running there. Whenever the\nguest tries to read a memory page which has not been migrated yet, the\nhypervisor has to tell the source to transfer that page in a priority\nchannel. To minimize such page faults, it is a good idea to run at least one\niteration of pre-copy migration before switching to post-copy.\n\nPost-copy migration is guaranteed to converge since each page is transferred\nat most once no matter how fast it changes. On the other hand once the\nguest is running on the destination host, the migration can no longer be\nrolled back because none of the hosts has complete state. If this happens,\nlibvirt will leave the domain paused on both hosts with\nVIR_DOMAIN_PAUSED_POSTCOPY_FAILED reason. It's up to the upper layer to\ndecide what to do in such case. Because of this, libvirt will refuse to\ncancel post-copy migration via virDomainAbortJob.\n\nThe following domain life cycle events are emitted during post-copy\nmigration:\n VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY (on the source) -- migration entered\n     post-copy mode.\n VIR_DOMAIN_EVENT_RESUMED_POSTCOPY (on the destination) -- the guest is\n     running on the destination host while some of its memory pages still\n     remain on the source host; neither the source nor the destination host\n     contain a complete guest state from this point until migration\n     finishes.\n VIR_DOMAIN_EVENT_RESUMED_MIGRATED (on the destination),\n VIR_DOMAIN_EVENT_STOPPED_MIGRATED (on the source) -- migration finished\n     successfully and the destination host holds a complete guest state.\n VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY_FAILED (on the destination) -- emitted\n     when migration fails in post-copy mode and it's unclear whether any\n     of the hosts has a complete guest state.\n\nThe progress of a post-copy migration can be monitored normally using\nvirDomainGetJobStats on the source host. Fetching statistics of a completed\npost-copy migration can also be done on the source host (by calling\nvirDomainGetJobStats or listening to VIR_DOMAIN_EVENT_ID_JOB_COMPLETED\nevent, but (in contrast to pre-copy migration) the statistics are not\navailable on the destination host. Thus, VIR_DOMAIN_EVENT_ID_JOB_COMPLETED\nevent is the only way of getting statistics of a completed post-copy\nmigration of a transient domain (because the domain is removed after\nmigration and there's no domain to run virDomainGetJobStats on)."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 otherwise."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainMigrateToURI","file":"libvirt-domain","module":"libvirt-domain"},"info":["Migrate the domain object from its current host to the destination\nhost given by duri.\n\nThis function is similar to virDomainMigrateToURI3, but it only supports a\nfixed set of parameters: @dname corresponds to VIR_MIGRATE_PARAM_DEST_NAME,\nand @bandwidth corresponds to VIR_MIGRATE_PARAM_BANDWIDTH.\n\nThe operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n\nIf the VIR_MIGRATE_PEER2PEER flag IS set, the @duri parameter must be a\nvalid libvirt connection URI, by which the source libvirt driver can connect\nto the destination libvirt. In other words, @duri corresponds to @dconnuri\nof virDomainMigrateToURI3.\n\nIf the VIR_MIGRATE_PEER2PEER flag is NOT set, the @duri parameter takes a\nhypervisor specific URI used to initiate the migration. In this case @duri\ncorresponds to VIR_MIGRATE_PARAM_URI of virDomainMigrateToURI3."],"return":[{"$":{"type":"int","info":"0 if the migration succeeded, -1 upon error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"duri","type":"const char *","info":"mandatory URI for the destination host"}},{"$":{"name":"flags","type":"unsigned long","info":"bitwise-OR of virDomainMigrateFlags"}},{"$":{"name":"dname","type":"const char *","info":"(optional) rename domain to this at destination"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"(optional) specify migration bandwidth limit in MiB/s"}}]},{"$":{"name":"virDomainMigrateToURI2","file":"libvirt-domain","module":"libvirt-domain"},"info":["Migrate the domain object from its current host to the destination\nhost given by @dconnuri.\n\nThis function is similar to virDomainMigrateToURI3, but it only supports a\nfixed set of parameters: @miguri corresponds to VIR_MIGRATE_PARAM_URI, @dxml\nis VIR_MIGRATE_PARAM_DEST_XML, @dname is VIR_MIGRATE_PARAM_DEST_NAME, and\n@bandwidth corresponds to VIR_MIGRATE_PARAM_BANDWIDTH.\n\nThe operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n\nIf the VIR_MIGRATE_PEER2PEER flag IS set, the @dconnuri parameter must be a\nvalid libvirt connection URI, by which the source libvirt driver can connect\nto the destination libvirt. In other words, @dconnuri has the same semantics\nas in virDomainMigrateToURI3.\n\nIf the VIR_MIGRATE_PEER2PEER flag is NOT set, the @dconnuri must be NULL\nand the @miguri parameter takes a hypervisor specific URI used to initiate\nthe migration. In this case @miguri corresponds to VIR_MIGRATE_PARAM_URI of\nvirDomainMigrateToURI3."],"return":[{"$":{"type":"int","info":"0 if the migration succeeded, -1 upon error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"dconnuri","type":"const char *","info":"(optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER"}},{"$":{"name":"miguri","type":"const char *","info":"(optional) URI for invoking the migration, not if @flags includs VIR_MIGRATE_TUNNELLED"}},{"$":{"name":"dxml","type":"const char *","info":"(optional) XML config for launching guest on target"}},{"$":{"name":"flags","type":"unsigned long","info":"bitwise-OR of virDomainMigrateFlags"}},{"$":{"name":"dname","type":"const char *","info":"(optional) rename domain to this at destination"}},{"$":{"name":"bandwidth","type":"unsigned long","info":"(optional) specify migration bandwidth limit in MiB/s"}}]},{"$":{"name":"virDomainMigrateToURI3","file":"libvirt-domain","module":"libvirt-domain"},"info":["Migrate the domain object from its current host to the destination host\ngiven by URI.\n\nSee VIR_MIGRATE_PARAM_* and virDomainMigrateFlags for detailed description\nof accepted migration parameters and flags.\n\nThe operation of this API hinges on the VIR_MIGRATE_PEER2PEER flag.\n\nIf the VIR_MIGRATE_PEER2PEER flag is set, the @dconnuri parameter must be a\nvalid libvirt connection URI, by which the source libvirt daemon can connect\nto the destination libvirt.\n\nIf the VIR_MIGRATE_PEER2PEER flag is NOT set, then @dconnuri must be NULL\nand VIR_MIGRATE_PARAM_URI migration parameter must be filled in with\nhypervisor specific URI used to initiate the migration. The uri_transports\nelement of the hypervisor capabilities XML includes supported URI schemes.\nThis is called \"direct\" migration. Not all hypervisors support this mode of\nmigration, so if the VIR_MIGRATE_PEER2PEER flag is not set, then it may be\nnecessary to use the alternative virDomainMigrate3 API providing an explicit\nvirConnectPtr for the destination host.\n\nThere are many limitations on migration imposed by the underlying\ntechnology - for example it may not be possible to migrate between\ndifferent processors even with the same architecture, or between\ndifferent types of hypervisor."],"return":[{"$":{"type":"int","info":"0 if the migration succeeded, -1 upon error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"dconnuri","type":"const char *","info":"(optional) URI for target libvirtd if @flags includes VIR_MIGRATE_PEER2PEER"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"(optional) migration parameters"}},{"$":{"name":"nparams","type":"unsigned int","info":"(optional) number of migration parameters in @params"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainMigrateFlags"}}]},{"$":{"name":"virDomainOpenChannel","file":"libvirt-domain","module":"libvirt-domain"},"info":["This opens the host interface associated with a channel device on a\nguest, if the host interface is supported.  If @name is given, it\ncan match either the device alias (e.g. \"channel0\"), or the virtio\ntarget name (e.g. \"org.qemu.guest_agent.0\").  If @name is omitted,\nthen the first channel is opened. The channel is associated with\nthe passed in @st stream, which should have been opened in\nnon-blocking mode for bi-directional I/O.\n\nBy default, when @flags is 0, the open will fail if libvirt detects\nthat the channel is already in use by another client; passing\nVIR_DOMAIN_CHANNEL_FORCE will cause libvirt to forcefully remove the\nother client prior to opening this channel."],"return":[{"$":{"type":"int","info":"0 if the channel was opened, -1 on error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"name","type":"const char *","info":"the channel name, or NULL"}},{"$":{"name":"st","type":"virStreamPtr","info":"a stream to associate with the channel"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainChannelFlags"}}]},{"$":{"name":"virDomainOpenConsole","file":"libvirt-domain","module":"libvirt-domain"},"info":["This opens the backend associated with a console, serial or\nparallel port device on a guest, if the backend is supported.\nIf the @dev_name is omitted, then the first console or serial\ndevice is opened. The console is associated with the passed\nin @st stream, which should have been opened in non-blocking\nmode for bi-directional I/O.\n\nBy default, when @flags is 0, the open will fail if libvirt\ndetects that the console is already in use by another client;\npassing VIR_DOMAIN_CONSOLE_FORCE will cause libvirt to forcefully\nremove the other client prior to opening this console.\n\nIf flag VIR_DOMAIN_CONSOLE_SAFE the console is opened only in the\ncase where the hypervisor driver supports safe (mutually exclusive)\nconsole handling.\n\nOlder servers did not support either flag, and also did not forbid\nsimultaneous clients on a console, with potentially confusing results.\nWhen passing @flags of 0 in order to support a wider range of server\nversions, it is up to the client to ensure mutual exclusion."],"return":[{"$":{"type":"int","info":"0 if the console was opened, -1 on error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"dev_name","type":"const char *","info":"the console, serial or parallel port device alias, or NULL"}},{"$":{"name":"st","type":"virStreamPtr","info":"a stream to associate with the console"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainConsoleFlags"}}]},{"$":{"name":"virDomainOpenGraphics","file":"libvirt-domain","module":"libvirt-domain"},"info":["This will attempt to connect the file descriptor @fd, to\nthe graphics backend of @dom. If @dom has multiple graphics\nbackends configured, then @idx will determine which one is\nopened, starting from @idx 0.\n\nTo disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH\nconstant for @flags.\n\nThe caller should use an anonymous socketpair to open\n@fd before invocation.\n\nThis method can only be used when connected to a local\nlibvirt hypervisor, over a UNIX domain socket. Attempts\nto use this method over a TCP connection will always fail"],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"idx","type":"unsigned int","info":"index of graphics config to open"}},{"$":{"name":"fd","type":"int","info":"file descriptor to attach graphics to"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainOpenGraphicsFlags"}}]},{"$":{"name":"virDomainOpenGraphicsFD","file":"libvirt-domain","module":"libvirt-domain"},"info":["This will create a socket pair connected to the graphics backend of @dom.\nOne end of the socket will be returned on success, and the other end is\nhanded to the hypervisor.\nIf @dom has multiple graphics backends configured, then @idx will determine\nwhich one is opened, starting from @idx 0.\n\nTo disable any authentication, pass the VIR_DOMAIN_OPEN_GRAPHICS_SKIPAUTH\nconstant for @flags.\n\nThis method can only be used when connected to a local\nlibvirt hypervisor, over a UNIX domain socket. Attempts\nto use this method over a TCP connection will always fail."],"return":[{"$":{"type":"int","info":"an fd on success, -1 on failure"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"idx","type":"unsigned int","info":"index of graphics config to open"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainOpenGraphicsFlags"}}]},{"$":{"name":"virDomainPMSuspendForDuration","file":"libvirt-domain","module":"libvirt-domain"},"info":["Attempt to have the guest enter the given @target power management\nsuspension level.  If @duration is non-zero, also schedule the guest to\nresume normal operation after that many seconds, if nothing else has\nresumed it earlier.  Some hypervisors require that @duration be 0, for\nan indefinite suspension.\n\nDependent on hypervisor used, this may require a\nguest agent to be available, e.g. QEMU.\n\nBeware that at least for QEMU, the domain's process will be terminated\nwhen VIR_NODE_SUSPEND_TARGET_DISK is used and a new process will be\nlaunched when libvirt is asked to wake up the domain. As a result of\nthis, any runtime changes, such as device hotplug or memory settings,\nare lost unless such changes were made with VIR_DOMAIN_AFFECT_CONFIG\nflag."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"target","type":"unsigned int","info":"a value from virNodeSuspendTarget"}},{"$":{"name":"duration","type":"unsigned long long","info":"duration in seconds to suspend, or 0 for indefinite"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainPMWakeup","file":"libvirt-domain","module":"libvirt-domain"},"info":["Inject a wakeup into the guest that previously used\nvirDomainPMSuspendForDuration, rather than waiting for the\npreviously requested duration (if any) to elapse."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainPinEmulator","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the real CPUs which can be allocated to all emulator\nthreads. This function may require privileged access to the hypervisor.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\nBoth flags may be set.\nIf VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\nand may fail if domain is not alive.\nIf VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\nand will fail for transient domains. If neither flag is specified (that is,\n@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\npersistent setup, while an active domain is hypervisor-dependent on whether\njust live or both live and persistent state is changed.\nNot all hypervisors can support all flag combinations.\n\nSee also virDomainGetEmulatorPinInfo for querying this information."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"cpumap","type":"unsigned char *","info":"pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit."}},{"$":{"name":"maplen","type":"int","info":"number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen < size, missing bytes are set to zero. If maplen > size, failure code is returned."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainPinIOThread","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the real CPUs which can be allocated to an IOThread.\nThis function may require privileged access to the hypervisor.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\nBoth flags may be set.\nIf VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\nand may fail if domain is not alive.\nIf VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\nand will fail for transient domains. If neither flag is specified (that is,\n@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\npersistent setup, while an active domain is hypervisor-dependent on whether\njust live or both live and persistent state is changed.\nNot all hypervisors can support all flag combinations.\n\nSee also virDomainGetIOThreadInfo for querying this information."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"iothread_id","type":"unsigned int","info":"the IOThread ID to set the CPU affinity"}},{"$":{"name":"cpumap","type":"unsigned char *","info":"pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit."}},{"$":{"name":"maplen","type":"int","info":"number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen < size, missing bytes are set to zero. If maplen > size, failure code is returned."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainPinVcpu","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the real CPUs which can be allocated to a virtual CPU.\nThis function may require privileged access to the hypervisor.\n\nThis command only changes the runtime configuration of the domain,\nso can only be called on an active domain."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"vcpu","type":"unsigned int","info":"virtual CPU number"}},{"$":{"name":"cpumap","type":"unsigned char *","info":"pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit."}},{"$":{"name":"maplen","type":"int","info":"number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen < size, missing bytes are set to zero. If maplen > size, failure code is returned."}}]},{"$":{"name":"virDomainPinVcpuFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the real CPUs which can be allocated to a virtual CPU.\nThis function may require privileged access to the hypervisor.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\nBoth flags may be set.\nIf VIR_DOMAIN_AFFECT_LIVE is set, the change affects a running domain\nand may fail if domain is not alive.\nIf VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\nand will fail for transient domains. If neither flag is specified (that is,\n@flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain modifies\npersistent setup, while an active domain is hypervisor-dependent on whether\njust live or both live and persistent state is changed.\nNot all hypervisors can support all flag combinations.\n\nSee also virDomainGetVcpuPinInfo for querying this information."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"vcpu","type":"unsigned int","info":"virtual CPU number"}},{"$":{"name":"cpumap","type":"unsigned char *","info":"pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit."}},{"$":{"name":"maplen","type":"int","info":"number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen < size, missing bytes are set to zero. If maplen > size, failure code is returned."}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainReboot","file":"libvirt-domain","module":"libvirt-domain"},"info":["Reboot a domain, the domain object is still usable thereafter, but\nthe domain OS is being stopped for a restart.\nNote that the guest OS may ignore the request.\nAdditionally, the hypervisor may check and support the domain\n'on_reboot' XML setting resulting in a domain that shuts down instead\nof rebooting.\n\nIf @flags is set to zero, then the hypervisor will choose the\nmethod of shutdown it considers best. To have greater control\npass one or more of the virDomainRebootFlagValues. The order\nin which the hypervisor tries each shutdown method is undefined,\nand a hypervisor is not required to support all methods.\n\nTo use guest agent (VIR_DOMAIN_REBOOT_GUEST_AGENT) the domain XML\nmust have <channel> configured.\n\nDue to implementation limitations in some drivers (the qemu driver,\nfor instance) it is not advised to migrate or save a guest that is\nrebooting as a result of this API. Migrating such a guest can lead\nto a plain shutdown on the destination."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainRebootFlagValues"}}]},{"$":{"name":"virDomainRef","file":"libvirt-domain","module":"libvirt-domain"},"info":["Increment the reference count on the domain. For each\nadditional call to this method, there shall be a corresponding\ncall to virDomainFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using a domain would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"the domain to hold a reference on"}}]},{"$":{"name":"virDomainRename","file":"libvirt-domain","module":"libvirt-domain"},"info":["Rename a domain. New domain name is specified in the second\nargument. Depending on each driver implementation it may be\nrequired that domain is in a specific state.\n\nThere might be some attributes and/or elements in domain XML that if no\nvalue provided at XML defining time, libvirt will derive their value from\nthe domain name. These are not updated by this API. Users are strongly\nadvised to change these after the rename was successful."],"return":[{"$":{"type":"int","info":"0 if successfully renamed, -1 on error"}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to the domain object"}},{"$":{"name":"new_name","type":"const char *","info":"new domain name"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainReset","file":"libvirt-domain","module":"libvirt-domain"},"info":["Reset a domain immediately without any guest OS shutdown.\nReset emulates the power reset button on a machine, where all\nhardware sees the RST line set and reinitializes internal state.\n\nNote that there is a risk of data loss caused by reset without any\nguest OS shutdown."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainRestore","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will restore a domain saved to disk by virDomainSave().\n\nSee virDomainRestoreFlags() for more control."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"from","type":"const char *","info":"path to the input file"}}]},{"$":{"name":"virDomainRestoreFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will restore a domain saved to disk by virDomainSave().\n\nIf the hypervisor supports it, @dxml can be used to alter\nhost-specific portions of the domain XML that will be used when\nrestoring an image.  For example, it is possible to alter the\nbacking filename that is associated with a disk device, in order to\nprepare for file renaming done as part of backing up the disk\ndevice while the domain is stopped.\n\nIf @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\nattempt to bypass the file system cache while restoring the file, or\nfail if it cannot do so for the given system; this can allow less\npressure on file system cache, but also risks slowing restores from NFS.\n\nNormally, the saved state file will remember whether the domain was\nrunning or paused, and restore defaults to the same state.\nSpecifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n@flags will override the default read from the file.  These two\nflags are mutually exclusive."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"from","type":"const char *","info":"path to the input file"}},{"$":{"name":"dxml","type":"const char *","info":"(optional) XML config for adjusting guest xml used on restore"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSaveRestoreFlags"}}]},{"$":{"name":"virDomainResume","file":"libvirt-domain","module":"libvirt-domain"},"info":["Resume a suspended domain, the process is restarted from the state where\nit was frozen by calling virDomainSuspend().\nThis function may require privileged access\nMoreover, resume may not be supported if domain is in some\nspecial state like VIR_DOMAIN_PMSUSPENDED."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainRevertToSnapshot","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Revert the domain to a given snapshot.\n\nNormally, the domain will revert to the same state the domain was\nin while the snapshot was taken (whether inactive, running, or\npaused), except that disk snapshots default to reverting to\ninactive state.  Including VIR_DOMAIN_SNAPSHOT_REVERT_RUNNING in\n@flags overrides the snapshot state to guarantee a running domain\nafter the revert; or including VIR_DOMAIN_SNAPSHOT_REVERT_PAUSED in\n@flags guarantees a paused domain after the revert.  These two\nflags are mutually exclusive.  While a persistent domain does not\nneed either flag, it is not possible to revert a transient domain\ninto an inactive state, so transient domains require the use of one\nof these two flags.\n\nReverting to any snapshot discards all configuration changes made since\nthe last snapshot.  Additionally, reverting to a snapshot from a running\ndomain is a form of data loss, since it discards whatever is in the\nguest's RAM at the time.  Since the very nature of keeping snapshots\nimplies the intent to roll back state, no additional confirmation is\nnormally required for these lossy effects.\n\nHowever, there are two particular situations where reverting will\nbe refused by default, and where @flags must include\nVIR_DOMAIN_SNAPSHOT_REVERT_FORCE to acknowledge the risks.  1) Any\nattempt to revert to a snapshot that lacks the metadata to perform\nABI compatibility checks (generally the case for snapshots that\nlack a full <domain> when listed by virDomainSnapshotGetXMLDesc(),\nsuch as those created prior to libvirt 0.9.5).  2) Any attempt to\nrevert a running domain to an active state that requires starting a\nnew hypervisor instance rather than reusing the existing hypervisor\n(since this would terminate all connections to the domain, such as\nsuch as VNC or Spice graphics) - this condition arises from active\nsnapshots that are provably ABI incompatible, as well as from\ninactive snapshots with a @flags request to start the domain after\nthe revert."],"return":[{"$":{"type":"int","info":"0 if the creation is successful, -1 on error."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a domain snapshot object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSnapshotRevertFlags"}}]},{"$":{"name":"virDomainSave","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will suspend a domain and save its memory contents to\na file on disk. After the call, if successful, the domain is not\nlisted as running anymore (this ends the life of a transient domain).\nUse virDomainRestore() to restore a domain after saving.\n\nSee virDomainSaveFlags() for more control.  Also, a save file can\nbe inspected or modified slightly with virDomainSaveImageGetXMLDesc()\nand virDomainSaveImageDefineXML()."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"to","type":"const char *","info":"path for the output file"}}]},{"$":{"name":"virDomainSaveFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will suspend a domain and save its memory contents to\na file on disk. After the call, if successful, the domain is not\nlisted as running anymore (this ends the life of a transient domain).\nUse virDomainRestore() to restore a domain after saving.\n\nIf the hypervisor supports it, @dxml can be used to alter\nhost-specific portions of the domain XML that will be used when\nrestoring an image.  For example, it is possible to alter the\nbacking filename that is associated with a disk device, in order to\nprepare for file renaming done as part of backing up the disk\ndevice while the domain is stopped.\n\nIf @flags includes VIR_DOMAIN_SAVE_BYPASS_CACHE, then libvirt will\nattempt to bypass the file system cache while creating the file, or\nfail if it cannot do so for the given system; this can allow less\npressure on file system cache, but also risks slowing saves to NFS.\n\nNormally, the saved state file will remember whether the domain was\nrunning or paused, and restore defaults to the same state.\nSpecifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n@flags will override what state gets saved into the file.  These\ntwo flags are mutually exclusive.\n\nA save file can be inspected or modified slightly with\nvirDomainSaveImageGetXMLDesc() and virDomainSaveImageDefineXML().\n\nSome hypervisors may prevent this operation if there is a current\nblock copy operation; in that case, use virDomainBlockJobAbort()\nto stop the block copy first."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"to","type":"const char *","info":"path for the output file"}},{"$":{"name":"dxml","type":"const char *","info":"(optional) XML config for adjusting guest xml used on restore"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSaveRestoreFlags"}}]},{"$":{"name":"virDomainSaveImageDefineXML","file":"libvirt-domain","module":"libvirt-domain"},"info":["This updates the definition of a domain stored in a saved state\nfile.  @file must be a file created previously by virDomainSave()\nor virDomainSaveFlags().\n\n@dxml can be used to alter host-specific portions of the domain XML\nthat will be used when restoring an image.  For example, it is\npossible to alter the backing filename that is associated with a\ndisk device, to match renaming done as part of backing up the disk\ndevice while the domain is stopped.\n\nNormally, the saved state file will remember whether the domain was\nrunning or paused, and restore defaults to the same state.\nSpecifying VIR_DOMAIN_SAVE_RUNNING or VIR_DOMAIN_SAVE_PAUSED in\n@flags will override the default saved into the file; omitting both\nleaves the file's default unchanged.  These two flags are mutually\nexclusive."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"file","type":"const char *","info":"path to saved state file"}},{"$":{"name":"dxml","type":"const char *","info":"XML config for adjusting guest xml used on restore"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSaveRestoreFlags"}}]},{"$":{"name":"virDomainSaveImageGetXMLDesc","file":"libvirt-domain","module":"libvirt-domain"},"info":["This method will extract the XML describing the domain at the time\na saved state file was created.  @file must be a file created\npreviously by virDomainSave() or virDomainSaveFlags().\n\nNo security-sensitive data will be included unless @flags contains\nVIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\nconnections.  For this API, @flags should not contain either\nVIR_DOMAIN_XML_INACTIVE or VIR_DOMAIN_XML_UPDATE_CPU."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error.  The caller must free() the returned value."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"file","type":"const char *","info":"path to saved state file"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of subset of virDomainXMLFlags"}}]},{"$":{"name":"virDomainScreenshot","file":"libvirt-domain","module":"libvirt-domain"},"info":["Take a screenshot of current domain console as a stream. The image format\nis hypervisor specific. Moreover, some hypervisors supports multiple\ndisplays per domain. These can be distinguished by @screen argument.\n\nThis call sets up a stream; subsequent use of stream API is necessary\nto transfer actual data, determine how much data is successfully\ntransferred, and detect any errors.\n\nThe screen ID is the sequential number of screen. In case of multiple\ngraphics cards, heads are enumerated before devices, e.g. having\ntwo graphics cards, both with four heads, screen ID 5 addresses\nthe second head on the second card."],"return":[{"$":{"type":"char *","info":"a string representing the mime-type of the image format, or NULL upon error. The caller must free() the returned value."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"stream","type":"virStreamPtr","info":"stream to use as output"}},{"$":{"name":"screen","type":"unsigned int","info":"monitor ID to take screenshot from"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainSendKey","file":"libvirt-domain","module":"libvirt-domain"},"info":["Send key(s) to the guest."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"codeset","type":"unsigned int","info":"the code set of keycodes, from virKeycodeSet"}},{"$":{"name":"holdtime","type":"unsigned int","info":"the duration (in milliseconds) that the keys will be held"}},{"$":{"name":"keycodes","type":"unsigned int *","info":"array of keycodes"}},{"$":{"name":"nkeycodes","type":"int","info":"number of keycodes, up to VIR_DOMAIN_SEND_KEY_MAX_KEYS"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainSendProcessSignal","file":"libvirt-domain","module":"libvirt-domain"},"info":["Send a signal to the designated process in the guest\n\nThe signal numbers must be taken from the virDomainProcessSignal\nenum. These will be translated to the corresponding signal\nnumber for the guest OS, by the guest agent delivering the\nsignal. If there is no mapping from virDomainProcessSignal to\nthe native OS signals, this API will report an error.\n\nIf @pid_value is an integer greater than zero, it is\ntreated as a process ID. If @pid_value is an integer\nless than zero, it is treated as a process group ID.\nAll the @pid_value numbers are from the container/guest\nnamespace. The value zero is not valid.\n\nNot all hypervisors will support sending signals to\narbitrary processes or process groups. If this API is\nimplemented the minimum requirement is to be able to\nuse @pid_value == 1 (i.e. kill init). No other value is\nrequired to be supported.\n\nIf the @signum is VIR_DOMAIN_PROCESS_SIGNAL_NOP then this\nAPI will simply report whether the process is running in\nthe container/guest."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"pid_value","type":"long long","info":"a positive integer process ID, or negative integer process group ID"}},{"$":{"name":"signum","type":"unsigned int","info":"a signal from the virDomainProcessSignal enum"}},{"$":{"name":"flags","type":"unsigned int","info":"currently unused, pass 0"}}]},{"$":{"name":"virDomainSetAutostart","file":"libvirt-domain","module":"libvirt-domain"},"info":["Configure the domain to be automatically started\nwhen the host machine boots."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"autostart","type":"int","info":"whether the domain should be automatically started 0 or 1"}}]},{"$":{"name":"virDomainSetBlkioParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change all or a subset of the blkio tunables.\nThis function may require privileged access to the hypervisor."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to blkio parameter objects"}},{"$":{"name":"nparams","type":"int","info":"number of blkio parameters (this value can be the same or less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetBlockIoTune","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change all or a subset of the per-device block IO tunables.\n\nThe @disk parameter is either an unambiguous source name of the\nblock device (the <source file='...'/> sub-element, such as\n\"/path/to/image\"), or the device target shorthand (the <target\ndev='...'/> sub-element, such as \"xvda\").  Valid names can be found\nby calling virDomainGetXMLDesc() and inspecting elements\nwithin //domain/devices/disk."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"disk","type":"const char *","info":"path to the block device, or device shorthand"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"Pointer to blkio parameter objects"}},{"$":{"name":"nparams","type":"int","info":"Number of blkio parameters (this value can be the same or less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetBlockThreshold","file":"libvirt-domain","module":"libvirt-domain"},"info":["Set the threshold level for delivering the\nVIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD if the device or backing chain element\ndescribed by @dev is written beyond the set threshold level. The threshold\nlevel is unset once the event fires. The event might not be delivered at all\nif libvirtd was not running at the moment when the threshold was reached.\n\nHypervisors report the last written sector of an image in the bulk stats API\n(virConnectGetAllDomainStats/virDomainListGetStats) as\n\"block.<num>.allocation\" in the VIR_DOMAIN_STATS_BLOCK group. The current\nthreshold value is reported as \"block.<num>.threshold\".\n\nThis event allows to use thin-provisioned storage which needs management\ntools to grow it without the need for polling of the data."],"return":[{"$":{"type":"int","info":"0 if the operation has started, -1 on failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"dev","type":"const char *","info":"string specifying the block device or backing chain element"}},{"$":{"name":"threshold","type":"unsigned long long","info":"threshold in bytes when to fire the event"}},{"$":{"name":"flags","type":"unsigned int","info":"currently unused, callers should pass 0"}}]},{"$":{"name":"virDomainSetGuestVcpus","file":"libvirt-domain","module":"libvirt-domain"},"info":["Sets state of individual vcpus described by @cpumap via guest agent. Other\nvcpus are not modified.\n\nThis API requires the VM to run. Various hypervisors or guest agent\nimplementation may limit to operate on just 1 vCPU per call.\n\n@cpumap is a list of vCPU numbers. Its syntax is a comma separated list and\na special markup using '-' and '^' (ex. '0-4', '0-3,^2'). The '-' denotes\nthe range and the '^' denotes exclusive. The expression is sequentially\nevaluated, so \"0-15,^8\" is identical to \"9-14,0-7,15\" but not identical to\n\"^8,0-15\".\n\nNote that OSes (notably Linux) may require vCPU 0 to stay online to support\nlow-level features a S3 sleep."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"cpumap","type":"const char *","info":"text representation of a bitmap of vcpus to set"}},{"$":{"name":"state","type":"int","info":"0 to disable/1 to enable cpus described by @cpumap"}},{"$":{"name":"flags","type":"unsigned int","info":"currently unused, callers shall pass 0"}}]},{"$":{"name":"virDomainSetInterfaceParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change a subset or all parameters of interface; currently this\nincludes bandwidth parameters.  The value of @flags should be\neither VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of values\nVIR_DOMAIN_AFFECT_LIVE and VIR_DOMAIN_AFFECT_CONFIG, although\nhypervisors vary in which flags are supported.\n\nThis function may require privileged access to the hypervisor."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"device","type":"const char *","info":"the interface name or mac address"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to interface parameter objects"}},{"$":{"name":"nparams","type":"int","info":"number of interface parameter (this value can be the same or less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetLifecycleAction","file":"libvirt-domain","module":"libvirt-domain"},"info":["Changes the actions of lifecycle events for domain represented as\n<on_$type>$action</on_$type> in the domain XML.\n\nQEMU driver has a limitation that if all lifecycle events are set\nto destroy when the domain is started, it's not possible to change\nany action for running domain."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"type","type":"unsigned int","info":"the lifecycle type from virDomainLifecycle"}},{"$":{"name":"action","type":"unsigned int","info":"the action type from virDomainLifecycleAction"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetMaxMemory","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the maximum amount of physical memory allocated to a\ndomain. If domain is NULL, then this change the amount of memory reserved\nto Domain0 i.e. the domain where the application runs.\nThis function may require privileged access to the hypervisor.\n\nThis command is hypervisor-specific for whether active, persistent,\nor both configurations are changed; for more control, use\nvirDomainSetMemoryFlags()."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object or NULL"}},{"$":{"name":"memory","type":"unsigned long","info":"the memory size in kibibytes (blocks of 1024 bytes)"}}]},{"$":{"name":"virDomainSetMemory","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the target amount of physical memory allocated to a\ndomain. If domain is NULL, then this change the amount of memory reserved\nto Domain0 i.e. the domain where the application runs.\nThis function may require privileged access to the hypervisor.\n\nThis command is hypervisor-specific for whether active, persistent,\nor both configurations are changed; for more control, use\nvirDomainSetMemoryFlags()."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object or NULL"}},{"$":{"name":"memory","type":"unsigned long","info":"the memory size in kibibytes (blocks of 1024 bytes)"}}]},{"$":{"name":"virDomainSetMemoryFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the target amount of physical memory allocated to a\ndomain. If domain is NULL, then this change the amount of memory reserved\nto Domain0 i.e. the domain where the application runs.\nThis function may require privileged access to the hypervisor.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\nBoth flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects\na running domain and will fail if domain is not active.\nIf VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\nand will fail for transient domains. If neither flag is specified\n(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain\nmodifies persistent setup, while an active domain is hypervisor-dependent\non whether just live or both live and persistent state is changed.\nIf VIR_DOMAIN_MEM_MAXIMUM is set, the change affects domain's maximum memory\nsize rather than current memory size.\nNot all hypervisors can support all flag combinations."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object or NULL"}},{"$":{"name":"memory","type":"unsigned long","info":"the memory size in kibibytes (blocks of 1024 bytes)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainMemoryModFlags"}}]},{"$":{"name":"virDomainSetMemoryParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change all or a subset of the memory tunables.\nThis function may require privileged access to the hypervisor.\n\nPossible values for all *_limit memory tunables are in range from 0 to\nVIR_DOMAIN_MEMORY_PARAM_UNLIMITED."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to memory parameter objects"}},{"$":{"name":"nparams","type":"int","info":"number of memory parameter (this value can be the same or less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetMemoryStatsPeriod","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the domain memory balloon driver statistics collection\nperiod. Use 0 to disable and a positive value to enable.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE or VIR_DOMAIN_AFFECT_CONFIG.\nBoth flags may be set. If VIR_DOMAIN_AFFECT_LIVE is set, the change affects\na running domain and will fail if domain is not active.\nIf VIR_DOMAIN_AFFECT_CONFIG is set, the change affects persistent state,\nand will fail for transient domains. If neither flag is specified\n(that is, @flags is VIR_DOMAIN_AFFECT_CURRENT), then an inactive domain\nmodifies persistent setup, while an active domain is hypervisor-dependent\non whether just live or both live and persistent state is changed.\n\nNot all hypervisors can support all flag combinations."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object or NULL"}},{"$":{"name":"period","type":"int","info":"the period in seconds for stats collection"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainMemoryModFlags"}}]},{"$":{"name":"virDomainSetMetadata","file":"libvirt-domain","module":"libvirt-domain"},"info":["Sets the appropriate domain element given by @type to the\nvalue of @metadata.  A @type of VIR_DOMAIN_METADATA_DESCRIPTION\nis free-form text; VIR_DOMAIN_METADATA_TITLE is free-form, but no\nnewlines are permitted, and should be short (although the length is\nnot enforced). For these two options @key and @uri are irrelevant and\nmust be set to NULL.\n\nFor type VIR_DOMAIN_METADATA_ELEMENT @metadata  must be well-formed\nXML belonging to namespace defined by @uri with local name @key.\n\nPassing NULL for @metadata says to remove that element from the\ndomain XML (passing the empty string leaves the element present).\n\nThe resulting metadata will be present in virDomainGetXMLDesc(),\nas well as quick access through virDomainGetMetadata().\n\n@flags controls whether the live domain, persistent configuration,\nor both will be modified."],"return":[{"$":{"type":"int","info":"0 on success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"type","type":"int","info":"type of metadata, from virDomainMetadataType"}},{"$":{"name":"metadata","type":"const char *","info":"new metadata text"}},{"$":{"name":"key","type":"const char *","info":"XML namespace key, or NULL"}},{"$":{"name":"uri","type":"const char *","info":"XML namespace URI, or NULL"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetNumaParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change all or a subset of the numa tunables.\nThis function may require privileged access to the hypervisor."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to numa parameter objects"}},{"$":{"name":"nparams","type":"int","info":"number of numa parameters (this value can be the same or less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetPerfEvents","file":"libvirt-domain","module":"libvirt-domain"},"info":["Enable or disable the particular list of Linux perf events you\ncare about. The @params argument should contain any subset of\nVIR_PERF_EVENT_ macros.\n\nLinux perf events are performance analyzing tool in Linux."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to perf events parameter object"}},{"$":{"name":"nparams","type":"int","info":"number of perf event parameters (this value can be the same less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetSchedulerParameters","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change all or a subset or the scheduler parameters.  It is\nhypervisor-specific whether this sets live, persistent, or both\nsettings; for more control, use\nvirDomainSetSchedulerParametersFlags."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to scheduler parameter objects"}},{"$":{"name":"nparams","type":"int","info":"number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)"}}]},{"$":{"name":"virDomainSetSchedulerParametersFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change a subset or all scheduler parameters.  The value of @flags\nshould be either VIR_DOMAIN_AFFECT_CURRENT, or a bitwise-or of\nvalues from VIR_DOMAIN_AFFECT_LIVE and\nVIR_DOMAIN_AFFECT_CURRENT, although hypervisors vary in which\nflags are supported."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to scheduler parameter objects"}},{"$":{"name":"nparams","type":"int","info":"number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetTime","file":"libvirt-domain","module":"libvirt-domain"},"info":["When a domain is suspended or restored from a file the\ndomain's OS has no idea that there was a big gap in the time.\nDepending on how long the gap was, NTP might not be able to\nresynchronize the guest.\n\nThis API tries to set guest time to the given value. The time\nto set (@seconds and @nseconds) should be in seconds relative\nto the Epoch of 1970-01-01 00:00:00 in UTC.\n\nPlease note that some hypervisors may require guest agent to\nbe configured and running in order to be able to run this API."],"return":[{"$":{"type":"int","info":"0 on success, -1 otherwise."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"seconds","type":"long long","info":"time to set"}},{"$":{"name":"nseconds","type":"unsigned int","info":"the nanosecond part of @seconds"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSetTimeFlags"}}]},{"$":{"name":"virDomainSetUserPassword","file":"libvirt-domain","module":"libvirt-domain"},"info":["Sets the @user password to the value specified by @password.\nIf @flags contain VIR_DOMAIN_PASSWORD_ENCRYPTED, the password\nis assumed to be encrypted by the method required by the guest OS.\n\nPlease note that some hypervisors may require guest agent to\nbe configured and running in order to be able to run this API."],"return":[{"$":{"type":"int","info":"0 on success, -1 otherwise."}}],"arg":[{"$":{"name":"dom","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"user","type":"const char *","info":"the username that will get a new password"}},{"$":{"name":"password","type":"const char *","info":"the password to set"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSetUserPasswordFlags"}}]},{"$":{"name":"virDomainSetVcpu","file":"libvirt-domain","module":"libvirt-domain"},"info":["Enables/disables individual vcpus described by @vcpumap in the hypervisor.\n\nVarious hypervisor implementations may limit to operate on just 1\nhotpluggable entity (which may contain multiple vCPUs on certain platforms).\n\nNote that OSes and hypervisors may require vCPU 0 to stay online."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"vcpumap","type":"const char *","info":"text representation of a bitmap of vcpus to set"}},{"$":{"name":"state","type":"int","info":"0 to disable/1 to enable cpus described by @vcpumap"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainModificationImpact"}}]},{"$":{"name":"virDomainSetVcpus","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the number of virtual CPUs used by the domain.\nNote that this call may fail if the underlying virtualization hypervisor\ndoes not support it or if growing the number is arbitrarily limited.\nThis function may require privileged access to the hypervisor.\n\nNote that if this call is executed before the guest has finished booting,\nthe guest may fail to process the change.\n\nThis command only changes the runtime configuration of the domain,\nso can only be called on an active domain.  It is hypervisor-dependent\nwhether it also affects persistent configuration; for more control,\nuse virDomainSetVcpusFlags()."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"nvcpus","type":"unsigned int","info":"the new number of virtual CPUs for this domain"}}]},{"$":{"name":"virDomainSetVcpusFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Dynamically change the number of virtual CPUs used by the domain.\nNote that this call may fail if the underlying virtualization hypervisor\ndoes not support it or if growing the number is arbitrarily limited.\nThis function may require privileged access to the hypervisor.\n\n@flags may include VIR_DOMAIN_AFFECT_LIVE to affect a running\ndomain (which may fail if domain is not active), or\nVIR_DOMAIN_AFFECT_CONFIG to affect the next boot via the XML\ndescription of the domain.  Both flags may be set.\nIf neither flag is specified (that is, @flags is VIR_DOMAIN_AFFECT_CURRENT),\nthen an inactive domain modifies persistent setup, while an active domain\nis hypervisor-dependent on whether just live or both live and persistent\nstate is changed.\n\nNote that if this call is executed before the guest has finished booting,\nthe guest may fail to process the change.\n\nIf @flags includes VIR_DOMAIN_VCPU_MAXIMUM, then\nVIR_DOMAIN_AFFECT_LIVE must be clear, and only the maximum virtual\nCPU limit is altered; generally, this value must be less than or\nequal to virConnectGetMaxVcpus().  Otherwise, this call affects the\ncurrent virtual CPU limit, which must be less than or equal to the\nmaximum limit. Note that hypervisors may not allow changing the maximum\nvcpu count if processor topology is specified.\n\nIf @flags includes VIR_DOMAIN_VCPU_GUEST, then the state of processors is\nmodified inside the guest instead of the hypervisor. This flag can only\nbe used with live guests and is incompatible with VIR_DOMAIN_VCPU_MAXIMUM.\nThe usage of this flag may require a guest agent configured.\n\nNot all hypervisors can support all flag combinations."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object, or NULL for Domain0"}},{"$":{"name":"nvcpus","type":"unsigned int","info":"the new number of virtual CPUs for this domain, must be at least 1"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainVcpuFlags"}}]},{"$":{"name":"virDomainShutdown","file":"libvirt-domain","module":"libvirt-domain"},"info":["Shutdown a domain, the domain object is still usable thereafter, but\nthe domain OS is being stopped. Note that the guest OS may ignore the\nrequest. Additionally, the hypervisor may check and support the domain\n'on_poweroff' XML setting resulting in a domain that reboots instead of\nshutting down. For guests that react to a shutdown request, the differences\nfrom virDomainDestroy() are that the guests disk storage will be in a\nstable state rather than having the (virtual) power cord pulled, and\nthis command returns as soon as the shutdown request is issued rather\nthan blocking until the guest is no longer running.\n\nIf the domain is transient and has any snapshot metadata (see\nvirDomainSnapshotNum()), then that metadata will automatically\nbe deleted when the domain quits."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainShutdownFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Shutdown a domain, the domain object is still usable thereafter but\nthe domain OS is being stopped. Note that the guest OS may ignore the\nrequest. Additionally, the hypervisor may check and support the domain\n'on_poweroff' XML setting resulting in a domain that reboots instead of\nshutting down. For guests that react to a shutdown request, the differences\nfrom virDomainDestroy() are that the guest's disk storage will be in a\nstable state rather than having the (virtual) power cord pulled, and\nthis command returns as soon as the shutdown request is issued rather\nthan blocking until the guest is no longer running.\n\nIf the domain is transient and has any snapshot metadata (see\nvirDomainSnapshotNum()), then that metadata will automatically\nbe deleted when the domain quits.\n\nIf @flags is set to zero, then the hypervisor will choose the\nmethod of shutdown it considers best. To have greater control\npass one or more of the virDomainShutdownFlagValues. The order\nin which the hypervisor tries each shutdown method is undefined,\nand a hypervisor is not required to support all methods.\n\nTo use guest agent (VIR_DOMAIN_SHUTDOWN_GUEST_AGENT) the domain XML\nmust have <channel> configured."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainShutdownFlagValues"}}]},{"$":{"name":"virDomainSnapshotCreateXML","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Creates a new snapshot of a domain based on the snapshot xml\ncontained in xmlDesc.\n\nIf @flags is 0, the domain can be active, in which case the\nsnapshot will be a system checkpoint (both disk state and runtime\nVM state such as RAM contents), where reverting to the snapshot is\nthe same as resuming from hibernation (TCP connections may have\ntimed out, but everything else picks up where it left off); or\nthe domain can be inactive, in which case the snapshot includes\njust the disk state prior to booting.  The newly created snapshot\nbecomes current (see virDomainSnapshotCurrent()), and is a child\nof any previous current snapshot.\n\nIf @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE, then this\nis a request to reinstate snapshot metadata that was previously\ndiscarded, rather than creating a new snapshot.  This can be used\nto recreate a snapshot hierarchy on a destination, then remove it\non the source, in order to allow migration (since migration\nnormally fails if snapshot metadata still remains on the source\nmachine).  When redefining snapshot metadata, the current snapshot\nwill not be altered unless the VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT\nflag is also present.  It is an error to request the\nVIR_DOMAIN_SNAPSHOT_CREATE_CURRENT flag without\nVIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.  On some hypervisors,\nredefining an existing snapshot can be used to alter host-specific\nportions of the domain XML to be used during revert (such as\nbacking filenames associated with disk devices), but must not alter\nguest-visible layout.  When redefining a snapshot name that does\nnot exist, the hypervisor may validate that reverting to the\nsnapshot appears to be possible (for example, disk images have\nsnapshot contents by the requested name).  Not all hypervisors\nsupport these flags.\n\nIf @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA, then the\ndomain's disk images are modified according to @xmlDesc, but then\nthe just-created snapshot has its metadata deleted.  This flag is\nincompatible with VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.\n\nIf @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_HALT, then the domain\nwill be inactive after the snapshot completes, regardless of whether\nit was active before; otherwise, a running domain will still be\nrunning after the snapshot.  This flag is invalid on transient domains,\nand is incompatible with VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE.\n\nIf @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_LIVE, then the domain\nis not paused while creating the snapshot. This increases the size\nof the memory dump file, but reduces downtime of the guest while\ntaking the snapshot. Some hypervisors only support this flag during\nexternal checkpoints.\n\nIf @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY, then the\nsnapshot will be limited to the disks described in @xmlDesc, and no\nVM state will be saved.  For an active guest, the disk image may be\ninconsistent (as if power had been pulled), and specifying this\nwith the VIR_DOMAIN_SNAPSHOT_CREATE_HALT flag risks data loss.\n\nIf @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE, then the\nlibvirt will attempt to use guest agent to freeze and thaw all\nfile systems in use within domain OS. However, if the guest agent\nis not present, an error is thrown. Moreover, this flag requires\nVIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY to be passed as well.\n\nBy default, if the snapshot involves external files, and any of the\ndestination files already exist as a non-empty regular file, the\nsnapshot is rejected to avoid losing contents of those files.\nHowever, if @flags includes VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT,\nthen the destination files must be pre-created manually with\nthe correct image format and metadata including backing store path\n(this allows a management app to pre-create files with relative backing\nfile names, rather than the default of creating with absolute backing\nfile names). Note that only the file specified in the snapshot XML is\ninserted as a snapshot thus setting incorrect metadata in the pre-created\nimage may lead to the VM being unable to start or other block jobs may fail.\n\nBe aware that although libvirt prefers to report errors up front with\nno other effect, some hypervisors have certain types of failures where\nthe overall command can easily fail even though the guest configuration\nwas partially altered (for example, if a disk snapshot request for two\ndisks fails on the second disk, but the first disk alteration cannot be\nrolled back).  If this API call fails, it is therefore normally\nnecessary to follow up with virDomainGetXMLDesc() and check each disk\nto determine if any partial changes occurred.  However, if @flags\ncontains VIR_DOMAIN_SNAPSHOT_CREATE_ATOMIC, then libvirt guarantees\nthat this command will not alter any disks unless the entire set of\nchanges can be done atomically, making failure recovery simpler (note\nthat it is still possible to fail after disks have changed, but only\nin the much rarer cases of running out of memory or disk space).\n\nSome hypervisors may prevent this operation if there is a current\nblock copy operation; in that case, use virDomainBlockJobAbort()\nto stop the block copy first.\n\nvirDomainSnapshotFree should be used to free the resources after the\nsnapshot object is no longer needed."],"return":[{"$":{"type":"virDomainSnapshotPtr","info":"an (opaque) virDomainSnapshotPtr on success, NULL on failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"xmlDesc","type":"const char *","info":"string containing an XML description of the domain"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainSnapshotCreateFlags"}}]},{"$":{"name":"virDomainSnapshotCurrent","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Get the current snapshot for a domain, if any.\n\nvirDomainSnapshotFree should be used to free the resources after the\nsnapshot object is no longer needed."],"return":[{"$":{"type":"virDomainSnapshotPtr","info":"a domain snapshot object or NULL in case of failure.  If the current domain snapshot cannot be found, then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainSnapshotDelete","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Delete the snapshot.\n\nIf @flags is 0, then just this snapshot is deleted, and changes\nfrom this snapshot are automatically merged into children\nsnapshots.  If @flags includes VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN,\nthen this snapshot and any descendant snapshots are deleted.  If\n@flags includes VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN_ONLY, then any\ndescendant snapshots are deleted, but this snapshot remains.  These\ntwo flags are mutually exclusive.\n\nIf @flags includes VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY, then\nany snapshot metadata tracked by libvirt is removed while keeping\nthe snapshot contents intact; if a hypervisor does not require any\nlibvirt metadata to track snapshots, then this flag is silently\nignored."],"return":[{"$":{"type":"int","info":"0 if the selected snapshot(s) were successfully deleted, -1 on error."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a domain snapshot object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainSnapshotDeleteFlags"}}]},{"$":{"name":"virDomainSnapshotFree","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Free the domain snapshot object.  The snapshot itself is not modified.\nThe data structure is freed and should not be used thereafter."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a domain snapshot object"}}]},{"$":{"name":"virDomainSnapshotGetConnect","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Provides the connection pointer associated with a snapshot.  The\nreference counter on the connection is not increased by this\ncall."],"return":[{"$":{"type":"virConnectPtr","info":"the connection or NULL."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a snapshot object"}}]},{"$":{"name":"virDomainSnapshotGetDomain","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Provides the domain pointer associated with a snapshot.  The\nreference counter on the domain is not increased by this\ncall."],"return":[{"$":{"type":"virDomainPtr","info":"the domain or NULL."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a snapshot object"}}]},{"$":{"name":"virDomainSnapshotGetName","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Get the public name for that snapshot"],"return":[{"$":{"type":"const char *","info":"a pointer to the name or NULL, the string need not be deallocated as its lifetime will be the same as the snapshot object."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a snapshot object"}}]},{"$":{"name":"virDomainSnapshotGetParent","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Get the parent snapshot for @snapshot, if any.\n\nvirDomainSnapshotFree should be used to free the resources after the\nsnapshot object is no longer needed."],"return":[{"$":{"type":"virDomainSnapshotPtr","info":"a domain snapshot object or NULL in case of failure.  If the given snapshot is a root (no parent), then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a snapshot object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainSnapshotGetXMLDesc","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Provide an XML description of the domain snapshot.\n\nNo security-sensitive data will be included unless @flags contains\nVIR_DOMAIN_XML_SECURE; this flag is rejected on read-only\nconnections.  For this API, @flags should not contain either\nVIR_DOMAIN_XML_INACTIVE or VIR_DOMAIN_XML_UPDATE_CPU."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a domain snapshot object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of subset of virDomainXMLFlags"}}]},{"$":{"name":"virDomainSnapshotHasMetadata","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Determine if the given snapshot is associated with libvirt metadata\nthat would prevent the deletion of the domain."],"return":[{"$":{"type":"int","info":"1 if the snapshot has metadata, 0 if the snapshot exists without help from libvirt, or -1 on error."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a snapshot object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainSnapshotIsCurrent","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Determine if the given snapshot is the domain's current snapshot.  See\nalso virDomainHasCurrentSnapshot()."],"return":[{"$":{"type":"int","info":"1 if current, 0 if not current, or -1 on error."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a snapshot object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainSnapshotListAllChildren","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Collect the list of domain snapshots that are children of the given\nsnapshot, and allocate an array to store those objects.  This API solves\nthe race inherent in virDomainSnapshotListChildrenNames().\n\nBy default, this command covers only direct children; it is also possible\nto expand things to cover all descendants, when @flags includes\nVIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS.  Also, some filters are provided in\ngroups, where each group contains bits that describe mutually exclusive\nattributes of a snapshot, and where all bits within a group describe\nall possible snapshots.  Some hypervisors might reject explicit bits\nfrom a group where the hypervisor cannot make a distinction.  For a\ngroup supported by a given hypervisor, the behavior when no bits of a\ngroup are set is identical to the behavior when all bits in that group\nare set.  When setting bits from more than one group, it is possible to\nselect an impossible combination, in that case a hypervisor may return\neither 0 or an error.\n\nThe first group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_LEAVES and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that\nhave no further children (a leaf snapshot).\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_METADATA and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on\nwhether they have metadata that would prevent the removal of the last\nreference to a domain.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,\nVIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,\nfor filtering snapshots based on what domain state is tracked by the\nsnapshot.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL and\nVIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on\nwhether the snapshot is stored inside the disk images or as\nadditional files."],"return":[{"$":{"type":"int","info":"the number of domain snapshots found or -1 and sets @snaps to NULL in case of error.  On success, the array stored into @snaps is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virDomainSnapshotFree() on each array element, then calling free() on @snaps."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a domain snapshot object"}},{"$":{"name":"snaps","type":"virDomainSnapshotPtr **","info":"pointer to variable to store the array containing snapshot objects, or NULL if the list is not required (just returns number of snapshots)"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainSnapshotListFlags"}}]},{"$":{"name":"virDomainSnapshotListChildrenNames","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Collect the list of domain snapshots that are children of the given\nsnapshot, and store their names in @names.  The value to use for\n@nameslen can be determined by virDomainSnapshotNumChildren() with\nthe same @flags.\n\nBy default, this command covers only direct children; it is also possible\nto expand things to cover all descendants, when @flags includes\nVIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS.  Also, some filters are provided in\ngroups, where each group contains bits that describe mutually exclusive\nattributes of a snapshot, and where all bits within a group describe\nall possible snapshots.  Some hypervisors might reject explicit bits\nfrom a group where the hypervisor cannot make a distinction.  For a\ngroup supported by a given hypervisor, the behavior when no bits of a\ngroup are set is identical to the behavior when all bits in that group\nare set.  When setting bits from more than one group, it is possible to\nselect an impossible combination, in that case a hypervisor may return\neither 0 or an error.\n\nThe first group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_LEAVES and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that\nhave no further children (a leaf snapshot).\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_METADATA and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on\nwhether they have metadata that would prevent the removal of the last\nreference to a domain.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,\nVIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,\nfor filtering snapshots based on what domain state is tracked by the\nsnapshot.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL and\nVIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on\nwhether the snapshot is stored inside the disk images or as\nadditional files."],"return":[{"$":{"type":"int","info":"the number of domain snapshots found or -1 in case of error. Note that this command is inherently racy: another connection can define a new snapshot between a call to virDomainSnapshotNumChildren() and this call.  You are only guaranteed that all currently defined snapshots were listed if the return is less than @nameslen.  Likewise, you should be prepared for virDomainSnapshotLookupByName() to fail when converting a name from this call into a snapshot object, if another connection deletes the snapshot in the meantime.  For more control over the results, see virDomainSnapshotListAllChildren().  Returns the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a domain snapshot object"}},{"$":{"name":"names","type":"char **","info":"array to collect the list of names of snapshots"}},{"$":{"name":"nameslen","type":"int","info":"size of @names"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainSnapshotListFlags"}}]},{"$":{"name":"virDomainSnapshotListNames","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Collect the list of domain snapshots for the given domain, and store\ntheir names in @names.  The value to use for @nameslen can be determined\nby virDomainSnapshotNum() with the same @flags.\n\nBy default, this command covers all snapshots; it is also possible to\nlimit things to just snapshots with no parents, when @flags includes\nVIR_DOMAIN_SNAPSHOT_LIST_ROOTS.  Additional filters are provided in\ngroups, where each group contains bits that describe mutually exclusive\nattributes of a snapshot, and where all bits within a group describe\nall possible snapshots.  Some hypervisors might reject explicit bits\nfrom a group where the hypervisor cannot make a distinction.  For a\ngroup supported by a given hypervisor, the behavior when no bits of a\ngroup are set is identical to the behavior when all bits in that group\nare set.  When setting bits from more than one group, it is possible to\nselect an impossible combination, in that case a hypervisor may return\neither 0 or an error.\n\nThe first group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_LEAVES and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that\nhave no further children (a leaf snapshot).\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_METADATA and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on\nwhether they have metadata that would prevent the removal of the last\nreference to a domain.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,\nVIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,\nfor filtering snapshots based on what domain state is tracked by the\nsnapshot.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL and\nVIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on\nwhether the snapshot is stored inside the disk images or as\nadditional files.\n\nNote that this command is inherently racy: another connection can\ndefine a new snapshot between a call to virDomainSnapshotNum() and\nthis call.  You are only guaranteed that all currently defined\nsnapshots were listed if the return is less than @nameslen.  Likewise,\nyou should be prepared for virDomainSnapshotLookupByName() to fail when\nconverting a name from this call into a snapshot object, if another\nconnection deletes the snapshot in the meantime.  For more control over\nthe results, see virDomainListAllSnapshots()."],"return":[{"$":{"type":"int","info":"the number of domain snapshots found or -1 in case of error. The caller is responsible to call free() for each member of the array."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"names","type":"char **","info":"array to collect the list of names of snapshots"}},{"$":{"name":"nameslen","type":"int","info":"size of @names"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainSnapshotListFlags"}}]},{"$":{"name":"virDomainSnapshotLookupByName","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Try to lookup a domain snapshot based on its name."],"return":[{"$":{"type":"virDomainSnapshotPtr","info":"a domain snapshot object or NULL in case of failure.  If the domain snapshot cannot be found, then the VIR_ERR_NO_DOMAIN_SNAPSHOT error is raised."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"name","type":"const char *","info":"name for the domain snapshot"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virDomainSnapshotNum","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Provides the number of domain snapshots for this domain.\n\nBy default, this command covers all snapshots; it is also possible to\nlimit things to just snapshots with no parents, when @flags includes\nVIR_DOMAIN_SNAPSHOT_LIST_ROOTS.  Additional filters are provided in\ngroups, where each group contains bits that describe mutually exclusive\nattributes of a snapshot, and where all bits within a group describe\nall possible snapshots.  Some hypervisors might reject explicit bits\nfrom a group where the hypervisor cannot make a distinction.  For a\ngroup supported by a given hypervisor, the behavior when no bits of a\ngroup are set is identical to the behavior when all bits in that group\nare set.  When setting bits from more than one group, it is possible to\nselect an impossible combination, in that case a hypervisor may return\neither 0 or an error.\n\nThe first group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_LEAVES and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that\nhave no further children (a leaf snapshot).\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_METADATA and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on\nwhether they have metadata that would prevent the removal of the last\nreference to a domain.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,\nVIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,\nfor filtering snapshots based on what domain state is tracked by the\nsnapshot.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL and\nVIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on\nwhether the snapshot is stored inside the disk images or as\nadditional files."],"return":[{"$":{"type":"int","info":"the number of domain snapshots found or -1 in case of error."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainSnapshotListFlags"}}]},{"$":{"name":"virDomainSnapshotNumChildren","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Provides the number of child snapshots for this domain snapshot.\n\nBy default, this command covers only direct children; it is also possible\nto expand things to cover all descendants, when @flags includes\nVIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS.  Also, some filters are provided in\ngroups, where each group contains bits that describe mutually exclusive\nattributes of a snapshot, and where all bits within a group describe\nall possible snapshots.  Some hypervisors might reject explicit bits\nfrom a group where the hypervisor cannot make a distinction.  For a\ngroup supported by a given hypervisor, the behavior when no bits of a\ngroup are set is identical to the behavior when all bits in that group\nare set.  When setting bits from more than one group, it is possible to\nselect an impossible combination, in that case a hypervisor may return\neither 0 or an error.\n\nThe first group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_LEAVES and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_LEAVES, to filter based on snapshots that\nhave no further children (a leaf snapshot).\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_METADATA and\nVIR_DOMAIN_SNAPSHOT_LIST_NO_METADATA, for filtering snapshots based on\nwhether they have metadata that would prevent the removal of the last\nreference to a domain.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INACTIVE,\nVIR_DOMAIN_SNAPSHOT_LIST_ACTIVE, and VIR_DOMAIN_SNAPSHOT_LIST_DISK_ONLY,\nfor filtering snapshots based on what domain state is tracked by the\nsnapshot.\n\nThe next group of @flags is VIR_DOMAIN_SNAPSHOT_LIST_INTERNAL and\nVIR_DOMAIN_SNAPSHOT_LIST_EXTERNAL, for filtering snapshots based on\nwhether the snapshot is stored inside the disk images or as\nadditional files."],"return":[{"$":{"type":"int","info":"the number of domain snapshots found or -1 in case of error."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"a domain snapshot object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainSnapshotListFlags"}}]},{"$":{"name":"virDomainSnapshotRef","file":"libvirt-domain-snapshot","module":"libvirt-domain-snapshot"},"info":["Increment the reference count on the snapshot. For each\nadditional call to this method, there shall be a corresponding\ncall to virDomainSnapshotFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection and domain remain open until all threads have finished\nusing the snapshot. ie, each new thread using a snapshot would\nincrement the reference count."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"snapshot","type":"virDomainSnapshotPtr","info":"the snapshot to hold a reference on"}}]},{"$":{"name":"virDomainStatsRecordListFree","file":"libvirt-domain","module":"libvirt-domain"},"info":["Convenience function to free a list of domain stats returned by\nvirDomainListGetStats and virConnectGetAllDomainStats."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"stats","type":"virDomainStatsRecordPtr *","info":"NULL terminated array of virDomainStatsRecords to free"}}]},{"$":{"name":"virDomainSuspend","file":"libvirt-domain","module":"libvirt-domain"},"info":["Suspends an active domain, the process is frozen without further access\nto CPU resources and I/O but the memory used by the domain at the\nhypervisor level will stay allocated. Use virDomainResume() to reactivate\nthe domain.\nThis function may require privileged access.\nMoreover, suspend may not be supported if domain is in some\nspecial state like VIR_DOMAIN_PMSUSPENDED."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"a domain object"}}]},{"$":{"name":"virDomainUndefine","file":"libvirt-domain","module":"libvirt-domain"},"info":["Undefine a domain. If the domain is running, it's converted to\ntransient domain, without stopping it. If the domain is inactive,\nthe domain configuration is removed.\n\nIf the domain has a managed save image (see\nvirDomainHasManagedSaveImage()), or if it is inactive and has any\nsnapshot metadata (see virDomainSnapshotNum()), then the undefine will\nfail. See virDomainUndefineFlags() for more control."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to a defined domain"}}]},{"$":{"name":"virDomainUndefineFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Undefine a domain. If the domain is running, it's converted to\ntransient domain, without stopping it. If the domain is inactive,\nthe domain configuration is removed.\n\nIf the domain has a managed save image (see virDomainHasManagedSaveImage()),\nthen including VIR_DOMAIN_UNDEFINE_MANAGED_SAVE in @flags will also remove\nthat file, and omitting the flag will cause the undefine process to fail.\n\nIf the domain is inactive and has any snapshot metadata (see\nvirDomainSnapshotNum()), then including\nVIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA in @flags will also remove\nthat metadata.  Omitting the flag will cause the undefine of an\ninactive domain to fail.  Active snapshots will retain snapshot\nmetadata until the (now-transient) domain halts, regardless of\nwhether this flag is present.  On hypervisors where snapshots do\nnot use libvirt metadata, this flag has no effect.\n\nIf the domain has any nvram specified, the undefine process will fail\nunless VIR_DOMAIN_UNDEFINE_KEEP_NVRAM is specified, or if\nVIR_DOMAIN_UNDEFINE_NVRAM is specified to remove the nvram file."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to a defined domain"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of supported virDomainUndefineFlagsValues"}}]},{"$":{"name":"virDomainUpdateDeviceFlags","file":"libvirt-domain","module":"libvirt-domain"},"info":["Change a virtual device on a domain, using the flags parameter\nto control how the device is changed.  VIR_DOMAIN_AFFECT_CURRENT\nspecifies that the device change is made based on current domain\nstate.  VIR_DOMAIN_AFFECT_LIVE specifies that the device shall be\nchanged on the active domain instance only and is not added to the\npersisted domain configuration. VIR_DOMAIN_AFFECT_CONFIG\nspecifies that the device shall be changed on the persisted domain\nconfiguration only.  Note that the target hypervisor must return an\nerror if unable to satisfy flags.  E.g. the hypervisor driver will\nreturn failure if LIVE is specified but it only supports modifying the\npersisted device allocation.\n\nThis method is used for actions such changing CDROM/Floppy device\nmedia, altering the graphics configuration such as password,\nreconfiguring the NIC device backend connectivity, etc."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"domain","type":"virDomainPtr","info":"pointer to domain object"}},{"$":{"name":"xml","type":"const char *","info":"pointer to XML description of one device"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virDomainDeviceModifyFlags"}}]},{"$":{"name":"virEventAddHandle","file":"libvirt-event","module":"virevent"},"info":["Register a callback for monitoring file handle events.  This function\nrequires that an event loop has previously been registered with\nvirEventRegisterImpl() or virEventRegisterDefaultImpl()."],"return":[{"$":{"type":"int","info":"-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events."}}],"arg":[{"$":{"name":"fd","type":"int","info":"file handle to monitor for events"}},{"$":{"name":"events","type":"int","info":"bitset of events to watch from virEventHandleType constants"}},{"$":{"name":"cb","type":"virEventHandleCallback","info":"callback to invoke when an event occurs"}},{"$":{"name":"opaque","type":"void *","info":"user data to pass to callback"}},{"$":{"name":"ff","type":"virFreeCallback","info":"callback to free opaque when handle is removed"}}]},{"$":{"name":"virEventAddTimeout","file":"libvirt-event","module":"virevent"},"info":["Register a callback for a timer event.  This function\nrequires that an event loop has previously been registered with\nvirEventRegisterImpl() or virEventRegisterDefaultImpl().\n\nSetting @timeout to -1 will disable the timer. Setting @timeout\nto zero will cause it to fire on every event loop iteration."],"return":[{"$":{"type":"int","info":"-1 if the timer cannot be registered, a positive integer timer id upon success."}}],"arg":[{"$":{"name":"timeout","type":"int","info":"time between events in milliseconds"}},{"$":{"name":"cb","type":"virEventTimeoutCallback","info":"callback to invoke when an event occurs"}},{"$":{"name":"opaque","type":"void *","info":"user data to pass to callback"}},{"$":{"name":"ff","type":"virFreeCallback","info":"callback to free opaque when timeout is removed"}}]},{"$":{"name":"virEventRegisterDefaultImpl","file":"libvirt-event","module":"virevent"},"info":["Registers a default event implementation based on the\npoll() system call. This is a generic implementation\nthat can be used by any client application which does\nnot have a need to integrate with an external event\nloop impl.\n\nFor proper event handling, it is important that the event implementation\nis registered before a connection to the Hypervisor is opened.\n\nOnce registered, the application has to invoke virEventRunDefaultImpl() in\na loop to process events.  Failure to do so may result in connections being\nclosed unexpectedly as a result of keepalive timeout.  The default\nevent loop fully supports handle and timeout events, but only\nwakes up on events registered by libvirt API calls such as\nvirEventAddHandle() or virConnectDomainEventRegisterAny()."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}]},{"$":{"name":"virEventRegisterImpl","file":"libvirt-event","module":"virevent"},"info":["Registers an event implementation, to allow integration\nwith an external event loop. Applications would use this\nto integrate with the libglib2 event loop, or libevent\nor the QT event loop.\n\nFor proper event handling, it is important that the event implementation\nis registered before a connection to the Hypervisor is opened.\n\nUse of the virEventAddHandle() and similar APIs require that the\ncorresponding handler is registered.  Use of the\nvirConnectDomainEventRegisterAny() and similar APIs requires that\nthe three timeout handlers are registered.  Likewise, the three\ntimeout handlers must be registered if the remote server has been\nconfigured to send keepalive messages, or if the client intends\nto call virConnectSetKeepAlive(), to avoid either side from\nunexpectedly closing the connection due to inactivity.\n\nIf an application does not need to integrate with an\nexisting event loop implementation, then the\nvirEventRegisterDefaultImpl() method can be used to setup\nthe generic libvirt implementation.\n\nOnce registered, the event loop implementation cannot be\nchanged, and must be run continuously. Note that callbacks\nmay remain registered for a short time even after calling\nvirConnectClose on all open connections, so it is not safe\nto stop running the event loop immediately after closing\nthe connection."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"addHandle","type":"virEventAddHandleFunc","info":"the callback to add fd handles"}},{"$":{"name":"updateHandle","type":"virEventUpdateHandleFunc","info":"the callback to update fd handles"}},{"$":{"name":"removeHandle","type":"virEventRemoveHandleFunc","info":"the callback to remove fd handles"}},{"$":{"name":"addTimeout","type":"virEventAddTimeoutFunc","info":"the callback to add a timeout"}},{"$":{"name":"updateTimeout","type":"virEventUpdateTimeoutFunc","info":"the callback to update a timeout"}},{"$":{"name":"removeTimeout","type":"virEventRemoveTimeoutFunc","info":"the callback to remove a timeout"}}]},{"$":{"name":"virEventRemoveHandle","file":"libvirt-event","module":"virevent"},"info":["Unregister a callback from a file handle.  This function\nrequires that an event loop has previously been registered with\nvirEventRegisterImpl() or virEventRegisterDefaultImpl()."],"return":[{"$":{"type":"int","info":"-1 if the file handle was not registered, 0 upon success."}}],"arg":[{"$":{"name":"watch","type":"int","info":"watch whose file handle to remove"}}]},{"$":{"name":"virEventRemoveTimeout","file":"libvirt-event","module":"virevent"},"info":["Unregister a callback for a timer.  This function\nrequires that an event loop has previously been registered with\nvirEventRegisterImpl() or virEventRegisterDefaultImpl()."],"return":[{"$":{"type":"int","info":"-1 if the timer was not registered, 0 upon success."}}],"arg":[{"$":{"name":"timer","type":"int","info":"the timer id to remove"}}]},{"$":{"name":"virEventRunDefaultImpl","file":"libvirt-event","module":"virevent"},"info":["Run one iteration of the event loop. Applications\nwill generally want to have a thread which invokes\nthis method in an infinite loop.  Furthermore, it is wise\nto set up a pipe-to-self handler (via virEventAddHandle())\nor a timeout (via virEventAddTimeout()) before calling this\nfunction, as it will block forever if there are no\nregistered events.\n\n  static bool quit;\n\n  while (!quit) {\n    if (virEventRunDefaultImpl() < 0)\n      ...print error...\n  }"],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}]},{"$":{"name":"virEventUpdateHandle","file":"libvirt-event","module":"virevent"},"info":["Change event set for a monitored file handle.  This function\nrequires that an event loop has previously been registered with\nvirEventRegisterImpl() or virEventRegisterDefaultImpl().\n\nWill not fail if fd exists."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"watch","type":"int","info":"watch whose file handle to update"}},{"$":{"name":"events","type":"int","info":"bitset of events to watch from virEventHandleType constants"}}]},{"$":{"name":"virEventUpdateTimeout","file":"libvirt-event","module":"virevent"},"info":["Change frequency for a timer.  This function\nrequires that an event loop has previously been registered with\nvirEventRegisterImpl() or virEventRegisterDefaultImpl().\n\nSetting frequency to -1 will disable the timer. Setting the frequency\nto zero will cause it to fire on every event loop iteration.\n\nWill not fail if timer exists."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"timer","type":"int","info":"timer id to change"}},{"$":{"name":"timeout","type":"int","info":"time between events in milliseconds"}}]},{"$":{"name":"virFreeError","file":"virterror","module":"virerror"},"info":["Resets and frees the given error."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"err","type":"virErrorPtr","info":"error to free"}}]},{"$":{"name":"virGetLastError","file":"virterror","module":"virerror"},"info":["Provide a pointer to the last error caught at the library level\n\nThe error object is kept in thread local storage, so separate\nthreads can safely access this concurrently."],"return":[{"$":{"type":"virErrorPtr","info":"a pointer to the last error or NULL if none occurred."}}]},{"$":{"name":"virGetLastErrorMessage","file":"virterror","module":"virerror"},"info":["Get the most recent error message"],"return":[{"$":{"type":"const char *","info":"the most recent error message string in this thread, or a generic message if none is set"}}]},{"$":{"name":"virGetVersion","file":"libvirt-host","module":"libvirt"},"info":["Provides version information. @libVer is the version of the\nlibrary and will always be set unless an error occurs, in which case\nan error code will be returned. @typeVer exists for historical\ncompatibility; if it is not NULL it will duplicate @libVer (it was\noriginally intended to return hypervisor information based on @type,\nbut due to the design of remote clients this is not reliable). To\nget the version of the running hypervisor use the virConnectGetVersion()\nfunction instead. To get the libvirt library version used by a\nconnection use the virConnectGetLibVersion() instead.\n\nThis function includes a call to virInitialize() when necessary."],"return":[{"$":{"type":"int","info":"-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release."}}],"arg":[{"$":{"name":"libVer","type":"unsigned long *","info":"return value for the library version (OUT)"}},{"$":{"name":"type","type":"const char *","info":"ignored; pass NULL"}},{"$":{"name":"typeVer","type":"unsigned long *","info":"pass NULL; for historical purposes duplicates @libVer if non-NULL"}}]},{"$":{"name":"virInitialize","file":"libvirt-host","module":"libvirt"},"info":["Initialize the library.\n\nThis method is invoked automatically by any of the virConnectOpen() API\ncalls, and by virGetVersion(). Since release 1.0.0, there is no need to\ncall this method even in a multithreaded application, since\ninitialization is performed in a thread safe manner; but applications\nusing an older version of the library should manually call this before\nsetting up competing threads that attempt virConnectOpen in parallel.\n\nThe only other time it would be necessary to call virInitialize is if the\napplication did not invoke virConnectOpen as its first API call, such\nas when calling virEventRegisterImpl() before setting up connections,\nor when using virSetErrorFunc() to alter error reporting of the first\nconnection attempt."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}]},{"$":{"name":"virInterfaceChangeBegin","file":"libvirt-interface","module":"libvirt-interface"},"info":["This function creates a restore point to which one can return\nlater by calling virInterfaceChangeRollback(). This function should\nbe called before any transaction with interface configuration.\nOnce it is known that a new configuration works, it can be committed via\nvirInterfaceChangeCommit(), which frees the restore point.\n\nIf virInterfaceChangeBegin() is called when a transaction is\nalready opened, this function will fail, and a\nVIR_ERR_INVALID_OPERATION will be logged."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virInterfaceChangeCommit","file":"libvirt-interface","module":"libvirt-interface"},"info":["This commits the changes made to interfaces and frees the restore point\ncreated by virInterfaceChangeBegin().\n\nIf virInterfaceChangeCommit() is called when a transaction is not\nopened, this function will fail, and a VIR_ERR_INVALID_OPERATION\nwill be logged."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virInterfaceChangeRollback","file":"libvirt-interface","module":"libvirt-interface"},"info":["This cancels changes made to interfaces settings by restoring previous\nstate created by virInterfaceChangeBegin().\n\nIf virInterfaceChangeRollback() is called when a transaction is not\nopened, this function will fail, and a VIR_ERR_INVALID_OPERATION\nwill be logged."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virInterfaceCreate","file":"libvirt-interface","module":"libvirt-interface"},"info":["Activate an interface (i.e. call \"ifup\").\n\nIf there was an open network config transaction at the time this\ninterface was defined (that is, if virInterfaceChangeBegin() had\nbeen called), the interface will be brought back down (and then\nundefined) if virInterfaceChangeRollback() is called."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"pointer to a defined interface"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virInterfaceDefineXML","file":"libvirt-interface","module":"libvirt-interface"},"info":["Define an inactive persistent physical host interface or modify an existing\npersistent one from the XML description.\n\nNormally this change in the interface configuration is immediately\npermanent/persistent, but if virInterfaceChangeBegin() has been\npreviously called (i.e. if an interface config transaction is\nopen), the new interface definition will only become permanent if\nvirInterfaceChangeCommit() is called prior to the next reboot of\nthe system running libvirtd. Prior to that time, it can be\nexplicitly removed using virInterfaceChangeRollback(), or will be\nautomatically removed during the next reboot of the system running\nlibvirtd.\n\nvirInterfaceFree should be used to free the resources after the\ninterface object is no longer needed."],"return":[{"$":{"type":"virInterfacePtr","info":"NULL in case of error, a pointer to the interface otherwise"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xml","type":"const char *","info":"the XML description for the interface, preferably in UTF-8"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virInterfaceDestroy","file":"libvirt-interface","module":"libvirt-interface"},"info":["deactivate an interface (ie call \"ifdown\")\nThis does not remove the interface from the config, and\ndoes not free the associated virInterfacePtr object.\n\nIf there is an open network config transaction at the time this\ninterface is destroyed (that is, if virInterfaceChangeBegin() had\nbeen called), and if the interface is later undefined and then\nvirInterfaceChangeRollback() is called, the restoral of the\ninterface definition will also bring the interface back up."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"an interface object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virInterfaceFree","file":"libvirt-interface","module":"libvirt-interface"},"info":["Free the interface object. The interface itself is unaltered.\nThe data structure is freed and should not be used thereafter."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"an interface object"}}]},{"$":{"name":"virInterfaceGetConnect","file":"libvirt-interface","module":"libvirt-interface"},"info":["Provides the connection pointer associated with an interface.  The\nreference counter on the connection is not increased by this\ncall."],"return":[{"$":{"type":"virConnectPtr","info":"the virConnectPtr or NULL in case of failure."}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"pointer to an interface"}}]},{"$":{"name":"virInterfaceGetMACString","file":"libvirt-interface","module":"libvirt-interface"},"info":["Get the MAC for an interface as string. For more information about\nMAC see RFC4122."],"return":[{"$":{"type":"const char *","info":"a pointer to the MAC address (in null-terminated ASCII format) or NULL, the string need not be deallocated its lifetime will be the same as the interface object."}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"an interface object"}}]},{"$":{"name":"virInterfaceGetName","file":"libvirt-interface","module":"libvirt-interface"},"info":["Get the public name for that interface"],"return":[{"$":{"type":"const char *","info":"a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the interface object."}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"an interface object"}}]},{"$":{"name":"virInterfaceGetXMLDesc","file":"libvirt-interface","module":"libvirt-interface"},"info":["VIR_INTERFACE_XML_INACTIVE - return the static configuration,\n                                  suitable for use redefining the\n                                  interface via virInterfaceDefineXML()\n\nProvide an XML description of the interface. If\nVIR_INTERFACE_XML_INACTIVE is set, the description may be reused\nlater to redefine the interface with virInterfaceDefineXML(). If it\nis not set, the ip address and netmask will be the current live\nsetting of the interface, not the settings from the config files."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"an interface object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of extraction flags. Current valid bits:"}}]},{"$":{"name":"virInterfaceIsActive","file":"libvirt-interface","module":"libvirt-interface"},"info":["Determine if the interface is currently running"],"return":[{"$":{"type":"int","info":"1 if running, 0 if inactive, -1 on error"}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"pointer to the interface object"}}]},{"$":{"name":"virInterfaceLookupByMACString","file":"libvirt-interface","module":"libvirt-interface"},"info":["Try to lookup an interface on the given hypervisor based on its MAC.\n\nvirInterfaceFree should be used to free the resources after the\ninterface object is no longer needed."],"return":[{"$":{"type":"virInterfacePtr","info":"a new interface object or NULL in case of failure.  If the interface cannot be found, then VIR_ERR_NO_INTERFACE error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"macstr","type":"const char *","info":"the MAC for the interface (null-terminated ASCII format)"}}]},{"$":{"name":"virInterfaceLookupByName","file":"libvirt-interface","module":"libvirt-interface"},"info":["Try to lookup an interface on the given hypervisor based on its name.\n\nvirInterfaceFree should be used to free the resources after the\ninterface object is no longer needed."],"return":[{"$":{"type":"virInterfacePtr","info":"a new interface object or NULL in case of failure.  If the interface cannot be found, then VIR_ERR_NO_INTERFACE error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"name","type":"const char *","info":"name for the interface"}}]},{"$":{"name":"virInterfaceRef","file":"libvirt-interface","module":"libvirt-interface"},"info":["Increment the reference count on the interface. For each\nadditional call to this method, there shall be a corresponding\ncall to virInterfaceFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using an interface would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"the interface to hold a reference on"}}]},{"$":{"name":"virInterfaceUndefine","file":"libvirt-interface","module":"libvirt-interface"},"info":["Undefine an interface, ie remove it from the config.\nThis does not free the associated virInterfacePtr object.\n\nNormally this change in the interface configuration is\npermanent/persistent, but if virInterfaceChangeBegin() has been\npreviously called (i.e. if an interface config transaction is\nopen), the removal of the interface definition will only become\npermanent if virInterfaceChangeCommit() is called prior to the next\nreboot of the system running libvirtd. Prior to that time, the\ndefinition can be explicitly restored using\nvirInterfaceChangeRollback(), or will be automatically restored\nduring the next reboot of the system running libvirtd."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"iface","type":"virInterfacePtr","info":"pointer to a defined interface"}}]},{"$":{"name":"virNWFilterDefineXML","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Define a new network filter, based on an XML description\nsimilar to the one returned by virNWFilterGetXMLDesc()\n\nvirNWFilterFree should be used to free the resources after the\nnwfilter object is no longer needed."],"return":[{"$":{"type":"virNWFilterPtr","info":"a new nwfilter object or NULL in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"an XML description of the nwfilter"}}]},{"$":{"name":"virNWFilterFree","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Free the nwfilter object. The running instance is kept alive.\nThe data structure is freed and should not be used thereafter."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"nwfilter","type":"virNWFilterPtr","info":"a nwfilter object"}}]},{"$":{"name":"virNWFilterGetName","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Get the public name for the network filter"],"return":[{"$":{"type":"const char *","info":"a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the nwfilter object."}}],"arg":[{"$":{"name":"nwfilter","type":"virNWFilterPtr","info":"a nwfilter object"}}]},{"$":{"name":"virNWFilterGetUUID","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Get the UUID for a network filter"],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"nwfilter","type":"virNWFilterPtr","info":"a nwfilter object"}},{"$":{"name":"uuid","type":"unsigned char *","info":"pointer to a VIR_UUID_BUFLEN bytes array"}}]},{"$":{"name":"virNWFilterGetUUIDString","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Get the UUID for a network filter as string. For more information about\nUUID see RFC4122."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"nwfilter","type":"virNWFilterPtr","info":"a nwfilter object"}},{"$":{"name":"buf","type":"char *","info":"pointer to a VIR_UUID_STRING_BUFLEN bytes array"}}]},{"$":{"name":"virNWFilterGetXMLDesc","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Provide an XML description of the network filter. The description may be\nreused later to redefine the network filter with virNWFilterCreateXML()."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"nwfilter","type":"virNWFilterPtr","info":"a nwfilter object"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNWFilterLookupByName","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Try to lookup a network filter on the given hypervisor based on its name.\n\nvirNWFilterFree should be used to free the resources after the\nnwfilter object is no longer needed."],"return":[{"$":{"type":"virNWFilterPtr","info":"a new nwfilter object or NULL in case of failure.  If the network filter cannot be found, then VIR_ERR_NO_NWFILTER error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"name","type":"const char *","info":"name for the network filter"}}]},{"$":{"name":"virNWFilterLookupByUUID","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Try to lookup a network filter on the given hypervisor based on its UUID.\n\nvirNWFilterFree should be used to free the resources after the\nnwfilter object is no longer needed."],"return":[{"$":{"type":"virNWFilterPtr","info":"a new nwfilter object or NULL in case of failure.  If the nwfdilter cannot be found, then VIR_ERR_NO_NWFILTER error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuid","type":"const unsigned char *","info":"the raw UUID for the network filter"}}]},{"$":{"name":"virNWFilterLookupByUUIDString","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Try to lookup an nwfilter on the given hypervisor based on its UUID.\n\nvirNWFilterFree should be used to free the resources after the\nnwfilter object is no longer needed."],"return":[{"$":{"type":"virNWFilterPtr","info":"a new nwfilter object or NULL in case of failure.  If the nwfilter cannot be found, then VIR_ERR_NO_NWFILTER error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuidstr","type":"const char *","info":"the string UUID for the nwfilter"}}]},{"$":{"name":"virNWFilterRef","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Increment the reference count on the nwfilter. For each\nadditional call to this method, there shall be a corresponding\ncall to virNWFilterFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using an nwfilter would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"nwfilter","type":"virNWFilterPtr","info":"the nwfilter to hold a reference on"}}]},{"$":{"name":"virNWFilterUndefine","file":"libvirt-nwfilter","module":"libvirt-nwfilter"},"info":["Undefine the nwfilter object. This call will not succeed if\na running VM is referencing the filter. This does not free the\nassociated virNWFilterPtr object."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"nwfilter","type":"virNWFilterPtr","info":"a nwfilter object"}}]},{"$":{"name":"virNetworkCreate","file":"libvirt-network","module":"libvirt-network"},"info":["Create and start a defined network. If the call succeed the network\nmoves from the defined to the running networks pools."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"pointer to a defined network"}}]},{"$":{"name":"virNetworkCreateXML","file":"libvirt-network","module":"libvirt-network"},"info":["Create and start a new virtual network, based on an XML description\nsimilar to the one returned by virNetworkGetXMLDesc()\n\nvirNetworkFree should be used to free the resources after the\nnetwork object is no longer needed."],"return":[{"$":{"type":"virNetworkPtr","info":"a new network object or NULL in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"an XML description of the network"}}]},{"$":{"name":"virNetworkDHCPLeaseFree","file":"libvirt-network","module":"libvirt-network"},"info":["Frees all the memory occupied by @lease."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"lease","type":"virNetworkDHCPLeasePtr","info":"pointer to a leases object"}}]},{"$":{"name":"virNetworkDefineXML","file":"libvirt-network","module":"libvirt-network"},"info":["Define an inactive persistent virtual network or modify an existing\npersistent one from the XML description.\n\nvirNetworkFree should be used to free the resources after the\nnetwork object is no longer needed."],"return":[{"$":{"type":"virNetworkPtr","info":"NULL in case of error, a pointer to the network otherwise"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xml","type":"const char *","info":"the XML description for the network, preferably in UTF-8"}}]},{"$":{"name":"virNetworkDestroy","file":"libvirt-network","module":"libvirt-network"},"info":["Destroy the network object. The running instance is shutdown if not down\nalready and all resources used by it are given back to the hypervisor. This\ndoes not free the associated virNetworkPtr object.\nThis function may require privileged access"],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}}]},{"$":{"name":"virNetworkFree","file":"libvirt-network","module":"libvirt-network"},"info":["Free the network object. The running instance is kept alive.\nThe data structure is freed and should not be used thereafter."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}}]},{"$":{"name":"virNetworkGetAutostart","file":"libvirt-network","module":"libvirt-network"},"info":["Provides a boolean value indicating whether the network\nconfigured to be automatically started when the host\nmachine boots."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}},{"$":{"name":"autostart","type":"int *","info":"the value returned"}}]},{"$":{"name":"virNetworkGetBridgeName","file":"libvirt-network","module":"libvirt-network"},"info":["Provides a bridge interface name to which a domain may connect\na network interface in order to join the network."],"return":[{"$":{"type":"char *","info":"a 0 terminated interface name, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}}]},{"$":{"name":"virNetworkGetConnect","file":"libvirt-network","module":"libvirt-network"},"info":["Provides the connection pointer associated with a network.  The\nreference counter on the connection is not increased by this\ncall."],"return":[{"$":{"type":"virConnectPtr","info":"the virConnectPtr or NULL in case of failure."}}],"arg":[{"$":{"name":"net","type":"virNetworkPtr","info":"pointer to a network"}}]},{"$":{"name":"virNetworkGetDHCPLeases","file":"libvirt-network","module":"libvirt-network"},"info":["For DHCPv4, the information returned:\n- Network Interface Name\n- Expiry Time\n- MAC address\n- IAID (NULL)\n- IPv4 address (with type and prefix)\n- Hostname (can be NULL)\n- Client ID (can be NULL)\n\nFor DHCPv6, the information returned:\n- Network Interface Name\n- Expiry Time\n- MAC address\n- IAID (can be NULL, only in rare cases)\n- IPv6 address (with type and prefix)\n- Hostname (can be NULL)\n- Client DUID\n\nNote: @mac, @iaid, @ipaddr, @clientid are in ASCII form, not raw bytes.\nNote: @expirytime can 0, in case the lease is for infinite time.\n\nThe API fetches leases info of guests in the specified network. If the\noptional parameter @mac is specified, the returned list will contain only\nlease info about a specific guest interface with @mac. There can be\nmultiple leases for a single @mac because this API supports DHCPv6 too."],"return":[{"$":{"type":"int","info":"the number of leases found or -1 and sets @leases to NULL in case of error. On success, the array stored into @leases is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier. The caller is responsible for calling virNetworkDHCPLeaseFree() on each array element, then calling free() on @leases.  See also virNetworkGetDHCPLeasesForMAC() as a convenience for filtering the list to a single MAC address.  Example of usage:  virNetworkDHCPLeasePtr *leases = NULL; virNetworkPtr network = ... obtain a network pointer here ...; size_t i; int nleases; unsigned int flags = 0;  nleases = virNetworkGetDHCPLeases(network, NULL, &leases, flags); if (nleases < 0) error();  ... do something with returned values, for example:  for (i = 0; i < nleases; i++) { virNetworkDHCPLeasePtr lease = leases[i];  printf(\"Time(epoch): %lu, MAC address: %s, \" \"IP address: %s, Hostname: %s, ClientID: %s\\n\", lease->expirytime, lease->mac, lease->ipaddr, lease->hostname, lease->clientid);  virNetworkDHCPLeaseFree(leases[i]); }  free(leases);"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"Pointer to network object"}},{"$":{"name":"mac","type":"const char *","info":"Optional ASCII formatted MAC address of an interface"}},{"$":{"name":"leases","type":"virNetworkDHCPLeasePtr **","info":"Pointer to a variable to store the array containing details on obtained leases, or NULL if the list is not required (just returns number of leases)."}},{"$":{"name":"flags","type":"unsigned int","info":"Extra flags, not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNetworkGetName","file":"libvirt-network","module":"libvirt-network"},"info":["Get the public name for that network"],"return":[{"$":{"type":"const char *","info":"a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object."}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}}]},{"$":{"name":"virNetworkGetUUID","file":"libvirt-network","module":"libvirt-network"},"info":["Get the UUID for a network"],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}},{"$":{"name":"uuid","type":"unsigned char *","info":"pointer to a VIR_UUID_BUFLEN bytes array"}}]},{"$":{"name":"virNetworkGetUUIDString","file":"libvirt-network","module":"libvirt-network"},"info":["Get the UUID for a network as string. For more information about\nUUID see RFC4122."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}},{"$":{"name":"buf","type":"char *","info":"pointer to a VIR_UUID_STRING_BUFLEN bytes array"}}]},{"$":{"name":"virNetworkGetXMLDesc","file":"libvirt-network","module":"libvirt-network"},"info":["Provide an XML description of the network. The description may be reused\nlater to relaunch the network with virNetworkCreateXML().\n\nNormally, if a network included a physical function, the output includes\nall virtual functions tied to that physical interface.  If @flags includes\nVIR_NETWORK_XML_INACTIVE, then the expansion of virtual interfaces is\nnot performed."],"return":[{"$":{"type":"char *","info":"a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value."}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virNetworkXMLFlags"}}]},{"$":{"name":"virNetworkIsActive","file":"libvirt-network","module":"libvirt-network"},"info":["Determine if the network is currently running"],"return":[{"$":{"type":"int","info":"1 if running, 0 if inactive, -1 on error"}}],"arg":[{"$":{"name":"net","type":"virNetworkPtr","info":"pointer to the network object"}}]},{"$":{"name":"virNetworkIsPersistent","file":"libvirt-network","module":"libvirt-network"},"info":["Determine if the network has a persistent configuration\nwhich means it will still exist after shutting down"],"return":[{"$":{"type":"int","info":"1 if persistent, 0 if transient, -1 on error"}}],"arg":[{"$":{"name":"net","type":"virNetworkPtr","info":"pointer to the network object"}}]},{"$":{"name":"virNetworkLookupByName","file":"libvirt-network","module":"libvirt-network"},"info":["Try to lookup a network on the given hypervisor based on its name.\n\nvirNetworkFree should be used to free the resources after the\nnetwork object is no longer needed."],"return":[{"$":{"type":"virNetworkPtr","info":"a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"name","type":"const char *","info":"name for the network"}}]},{"$":{"name":"virNetworkLookupByUUID","file":"libvirt-network","module":"libvirt-network"},"info":["Try to lookup a network on the given hypervisor based on its UUID.\n\nvirNetworkFree should be used to free the resources after the\nnetwork object is no longer needed."],"return":[{"$":{"type":"virNetworkPtr","info":"a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuid","type":"const unsigned char *","info":"the raw UUID for the network"}}]},{"$":{"name":"virNetworkLookupByUUIDString","file":"libvirt-network","module":"libvirt-network"},"info":["Try to lookup a network on the given hypervisor based on its UUID."],"return":[{"$":{"type":"virNetworkPtr","info":"a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuidstr","type":"const char *","info":"the string UUID for the network"}}]},{"$":{"name":"virNetworkRef","file":"libvirt-network","module":"libvirt-network"},"info":["Increment the reference count on the network. For each\nadditional call to this method, there shall be a corresponding\ncall to virNetworkFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using a network would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"the network to hold a reference on"}}]},{"$":{"name":"virNetworkSetAutostart","file":"libvirt-network","module":"libvirt-network"},"info":["Configure the network to be automatically started\nwhen the host machine boots."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"a network object"}},{"$":{"name":"autostart","type":"int","info":"whether the network should be automatically started 0 or 1"}}]},{"$":{"name":"virNetworkUndefine","file":"libvirt-network","module":"libvirt-network"},"info":["Undefine a network but does not stop it if it is running"],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"pointer to a defined network"}}]},{"$":{"name":"virNetworkUpdate","file":"libvirt-network","module":"libvirt-network"},"info":["Update the definition of an existing network, either its live\nrunning state, its persistent configuration, or both."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of error virNetworkUpdateCommand virNetworkUpdateSection"}}],"arg":[{"$":{"name":"network","type":"virNetworkPtr","info":"pointer to a defined network"}},{"$":{"name":"command","type":"unsigned int","info":"what action to perform (add/delete/modify) (see virNetworkUpdateCommand for descriptions)"}},{"$":{"name":"section","type":"unsigned int","info":"which section of the network to update (see virNetworkUpdateSection for descriptions)"}},{"$":{"name":"parentIndex","type":"int","info":"which parent element, if there are multiple parents of the same type (e.g. which <ip> element when modifying a <dhcp>/<host> element), or \"-1\" for \"don't care\" or \"automatically find appropriate one\"."}},{"$":{"name":"xml","type":"const char *","info":"the XML description for the network, preferably in UTF-8"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise OR of virNetworkUpdateFlags."}}]},{"$":{"name":"virNodeAllocPages","file":"libvirt-host","module":"libvirt-host"},"info":["Sometimes, when trying to start a new domain, it may be\nnecessary to reserve some huge pages in the system pool which\ncan be then allocated by the domain. This API serves that\npurpose. On its input, @pageSizes and @pageCounts are arrays\nof the same cardinality of @npages. The @pageSizes contains\npage sizes which are to be allocated in the system (the size\nunit is kibibytes), and @pageCounts then contains the number\nof pages to reserve.  If @flags is 0\n(VIR_NODE_ALLOC_PAGES_ADD), each pool corresponding to\n@pageSizes grows by the number of pages specified in the\ncorresponding @pageCounts.  If @flags contains\nVIR_NODE_ALLOC_PAGES_SET, each pool mentioned is resized to\nthe given number of pages.  The pages pool can be allocated\nover several NUMA nodes at once, just point at @startCell and\ntell how many subsequent NUMA nodes should be taken in. As a\nspecial case, if @startCell is equal to negative one, then\nkernel is instructed to allocate the pages over all NUMA nodes\nproportionally."],"return":[{"$":{"type":"int","info":"the number of nodes successfully adjusted or -1 in case of an error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"npages","type":"unsigned int","info":"number of items in the @pageSizes and @pageCounts arrays"}},{"$":{"name":"pageSizes","type":"unsigned int *","info":"which huge page sizes to allocate"}},{"$":{"name":"pageCounts","type":"unsigned long long *","info":"how many pages should be allocated"}},{"$":{"name":"startCell","type":"int","info":"index of first cell to allocate pages on"}},{"$":{"name":"cellCount","type":"unsigned int","info":"number of consecutive cells to allocate pages on"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; binary-OR of virNodeAllocPagesFlags"}}]},{"$":{"name":"virNodeDeviceCreateXML","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Create a new device on the VM host machine, for example, virtual\nHBAs created using vport_create.\n\nvirNodeDeviceFree should be used to free the resources after the\nnode device object is no longer needed."],"return":[{"$":{"type":"virNodeDevicePtr","info":"a node device object if successful, NULL in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"string containing an XML description of the device to be created"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeDeviceDestroy","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Destroy the device object. The virtual device (only works for vHBA\ncurrently) is removed from the host operating system.  This function\nmay require privileged access."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"a device object"}}]},{"$":{"name":"virNodeDeviceDetachFlags","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Detach the node device from the node itself so that it may be\nassigned to a guest domain.\n\nDepending on the hypervisor, this may involve operations such as\nunbinding any device drivers from the device, binding the device to\na dummy device driver and resetting the device. Different backend\ndrivers expect the device to be bound to different dummy\ndevices. For example, QEMU's \"kvm\" backend driver (the default)\nexpects the device to be bound to \"pci-stub\", but its \"vfio\"\nbackend driver expects the device to be bound to \"vfio-pci\".\n\nIf the device is currently in use by the node, this method may\nfail.\n\nOnce the device is not assigned to any guest, it may be re-attached\nto the node using the virNodeDeviceReAttach() method."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"pointer to the node device"}},{"$":{"name":"driverName","type":"const char *","info":"name of backend driver that will be used for later device assignment to a domain. NULL means \"use the hypervisor default driver\""}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeDeviceDettach","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Dettach the node device from the node itself so that it may be\nassigned to a guest domain.\n\nDepending on the hypervisor, this may involve operations such\nas unbinding any device drivers from the device, binding the\ndevice to a dummy device driver and resetting the device.\n\nIf the device is currently in use by the node, this method may\nfail.\n\nOnce the device is not assigned to any guest, it may be re-attached\nto the node using the virNodeDeviceReattach() method.\n\nIf the caller needs control over which backend driver will be used\nduring PCI device assignment (to use something other than the\ndefault, for example VFIO), the newer virNodeDeviceDetachFlags()\nAPI should be used instead."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"pointer to the node device"}}]},{"$":{"name":"virNodeDeviceFree","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Drops a reference to the node device, freeing it if\nthis was the last reference."],"return":[{"$":{"type":"int","info":"the 0 for success, -1 for error."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"pointer to the node device"}}]},{"$":{"name":"virNodeDeviceGetName","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Just return the device name"],"return":[{"$":{"type":"const char *","info":"the device name or NULL in case of error"}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"the device"}}]},{"$":{"name":"virNodeDeviceGetParent","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Accessor for the parent of the device"],"return":[{"$":{"type":"const char *","info":"the name of the device's parent, or NULL if an error occurred or when the device has no parent."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"the device"}}]},{"$":{"name":"virNodeDeviceGetXMLDesc","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Fetch an XML document describing all aspects of\nthe device."],"return":[{"$":{"type":"char *","info":"the XML document, or NULL on error"}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"pointer to the node device"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeDeviceListCaps","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Lists the names of the capabilities supported by the device."],"return":[{"$":{"type":"int","info":"the number of capability names listed in @names or -1 in case of error."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"the device"}},{"$":{"name":"names","type":"char ** const","info":"array to collect the list of capability names"}},{"$":{"name":"maxnames","type":"int","info":"size of @names"}}]},{"$":{"name":"virNodeDeviceLookupByName","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Lookup a node device by its name.\n\nvirNodeDeviceFree should be used to free the resources after the\nnode device object is no longer needed."],"return":[{"$":{"type":"virNodeDevicePtr","info":"a virNodeDevicePtr if found, NULL otherwise."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"name","type":"const char *","info":"unique device name"}}]},{"$":{"name":"virNodeDeviceLookupSCSIHostByWWN","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Lookup SCSI Host which is capable with 'fc_host' by its WWNN and WWPN.\n\nvirNodeDeviceFree should be used to free the resources after the\nnode device object is no longer needed."],"return":[{"$":{"type":"virNodeDevicePtr","info":"a virNodeDevicePtr if found, NULL otherwise."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"wwnn","type":"const char *","info":"WWNN of the SCSI Host."}},{"$":{"name":"wwpn","type":"const char *","info":"WWPN of the SCSI Host."}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeDeviceNumOfCaps","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Accessor for the number of capabilities supported by the device."],"return":[{"$":{"type":"int","info":"the number of capabilities supported by the device or -1 in case of error."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"the device"}}]},{"$":{"name":"virNodeDeviceReAttach","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Re-attach a previously detached node device to the node so that it\nmay be used by the node again.\n\nDepending on the hypervisor, this may involve operations such\nas resetting the device, unbinding it from a dummy device driver\nand binding it to its appropriate driver.\n\nIf the device is currently in use by a guest, this method may fail."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"pointer to the node device"}}]},{"$":{"name":"virNodeDeviceRef","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Increment the reference count on the dev. For each\nadditional call to this method, there shall be a corresponding\ncall to virNodeDeviceFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using a dev would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"the dev to hold a reference on"}}]},{"$":{"name":"virNodeDeviceReset","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Reset a previously detached node device to the node before or\nafter assigning it to a guest.\n\nThe exact reset semantics depends on the hypervisor and device\ntype but, for example, KVM will attempt to reset PCI devices with\na Function Level Reset, Secondary Bus Reset or a Power Management\nD-State reset.\n\nIf the reset will affect other devices which are currently in use,\nthis function may fail."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"dev","type":"virNodeDevicePtr","info":"pointer to the node device"}}]},{"$":{"name":"virNodeGetCPUMap","file":"libvirt-host","module":"libvirt-host"},"info":["Get CPU map of host node CPUs."],"return":[{"$":{"type":"int","info":"number of CPUs present on the host node, or -1 if there was an error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"cpumap","type":"unsigned char **","info":"optional pointer to a bit map of real CPUs on the host node (in 8-bit bytes) (OUT) In case of success each bit set to 1 means that corresponding CPU is online. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit. The bit map is allocated by virNodeGetCPUMap and needs to be released using free() by the caller."}},{"$":{"name":"online","type":"unsigned int *","info":"optional number of online CPUs in cpumap (OUT) Contains the number of online CPUs if the call was successful."}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeGetCPUStats","file":"libvirt-host","module":"libvirt-host"},"info":["This function provides individual cpu statistics of the node.\nIf you want to get total cpu statistics of the node, you must specify\nVIR_NODE_CPU_STATS_ALL_CPUS to @cpuNum.\nThe @params array will be filled with the values equal to the number of\nparameters suggested by @nparams\n\nAs the value of @nparams is dynamic, call the API setting @nparams to 0 and\n@params as NULL, the API returns the number of parameters supported by the\nHV by updating @nparams on SUCCESS. The caller should then allocate @params\narray, i.e. (sizeof(@virNodeCPUStats) * @nparams) bytes and call\nthe API again.\n\nHere is a sample code snippet:\n\n  if (virNodeGetCPUStats(conn, cpuNum, NULL, &nparams, 0) == 0 &&\n      nparams != 0) {\n      if ((params = malloc(sizeof(virNodeCPUStats) * nparams)) == NULL)\n          goto error;\n      memset(params, 0, sizeof(virNodeCPUStats) * nparams);\n      if (virNodeGetCPUStats(conn, cpuNum, params, &nparams, 0))\n          goto error;\n  }\n\nThis function doesn't require privileged access to the hypervisor.\nThis function expects the caller to allocate the @params.\n\nCPU time Statistics:\n\nVIR_NODE_CPU_STATS_KERNEL:\n    The cumulative CPU time which spends by kernel,\n    when the node booting up.(nanoseconds)\nVIR_NODE_CPU_STATS_USER:\n    The cumulative CPU time which spends by user processes,\n    when the node booting up.(nanoseconds)\nVIR_NODE_CPU_STATS_IDLE:\n    The cumulative idle CPU time, when the node booting up.(nanoseconds)\nVIR_NODE_CPU_STATS_IOWAIT:\n    The cumulative I/O wait CPU time, when the node booting up.(nanoseconds)\nVIR_NODE_CPU_STATS_UTILIZATION:\n    The CPU utilization. The usage value is in percent and 100%\n    represents all CPUs on the server."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection."}},{"$":{"name":"cpuNum","type":"int","info":"number of node cpu. (VIR_NODE_CPU_STATS_ALL_CPUS means total cpu statistics)"}},{"$":{"name":"params","type":"virNodeCPUStatsPtr","info":"pointer to node cpu time parameter objects"}},{"$":{"name":"nparams","type":"int *","info":"number of node cpu time parameter (this value should be same or less than the number of parameters supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeGetCellsFreeMemory","file":"libvirt-host","module":"libvirt-host"},"info":["This call returns the amount of free memory in one or more NUMA cells.\nThe @freeMems array must be allocated by the caller and will be filled\nwith the amount of free memory in bytes for each cell requested,\nstarting with startCell (in freeMems[0]), up to either\n(startCell + maxCells), or the number of additional cells in the node,\nwhichever is smaller."],"return":[{"$":{"type":"int","info":"the number of entries filled in freeMems, or -1 in case of error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"freeMems","type":"unsigned long long *","info":"pointer to the array of unsigned long long"}},{"$":{"name":"startCell","type":"int","info":"index of first cell to return freeMems info on."}},{"$":{"name":"maxCells","type":"int","info":"Maximum number of cells for which freeMems information can be returned."}}]},{"$":{"name":"virNodeGetFreeMemory","file":"libvirt-host","module":"libvirt-host"},"info":["provides the free memory available on the Node\nNote: most libvirt APIs provide memory sizes in kibibytes, but in this\nfunction the returned value is in bytes. Divide by 1024 as necessary."],"return":[{"$":{"type":"unsigned long long","info":"the available free memory in bytes or 0 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}}]},{"$":{"name":"virNodeGetFreePages","file":"libvirt-host","module":"libvirt-host"},"info":["This calls queries the host system on free pages of\nspecified size. For the input, @pages is expected to be\nfilled with pages that caller is interested in (the size\nunit is kibibytes, so e.g. pass 2048 for 2MB), then @startcell\nrefers to the first NUMA node that info should be collected\nfrom, and @cellcount tells how many consecutive nodes should\nbe queried. On the function output, @counts is filled with\ndesired information, where items are grouped by NUMA node.\nSo from @counts[0] till @counts[@npages - 1] you'll find count\nfor the first node (@startcell), then from @counts[@npages]\ntill @count[2 * @npages - 1] you'll find info for the\n(@startcell + 1) node, and so on. It's callers responsibility\nto allocate the @counts array.\n\nExample how to use this API:\n\n  unsigned int pages[] = { 4, 2048, 1048576}\n  unsigned int npages = ARRAY_CARDINALITY(pages);\n  int startcell = 0;\n  unsigned int cellcount = 2;\n\n  unsigned long long counts = malloc(sizeof(long long) * npages * cellcount);\n\n  virNodeGetFreePages(conn, pages, npages,\n                      startcell, cellcount, counts, 0);\n\n  for (i = 0 ; i < cellcount ; i++) {\n      fprintf(stdout, \"Cell %d\\n\", startcell + i);\n      for (j = 0 ; j < npages ; j++) {\n         fprintf(stdout, \"  Page size=%d count=%d bytes=%llu\\n\",\n                 pages[j], counts[(i * npages) +  j],\n                 pages[j] * counts[(i * npages) +  j]);\n      }\n  }\n\n  This little code snippet will produce something like this:\nCell 0\n   Page size=4096 count=300 bytes=1228800\n   Page size=2097152 count=0 bytes=0\n   Page size=1073741824 count=1 bytes=1073741824\nCell 1\n   Page size=4096 count=0 bytes=0\n   Page size=2097152 count=20 bytes=41943040\n   Page size=1073741824 count=0 bytes=0"],"return":[{"$":{"type":"int","info":"the number of entries filled in @counts or -1 in case of error."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"npages","type":"unsigned int","info":"number of items in the @pages array"}},{"$":{"name":"pages","type":"unsigned int *","info":"page sizes to query"}},{"$":{"name":"startCell","type":"int","info":"index of first cell to return free pages info on."}},{"$":{"name":"cellCount","type":"unsigned int","info":"maximum number of cells for which free pages information can be returned."}},{"$":{"name":"counts","type":"unsigned long long *","info":"returned counts of free pages"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeGetInfo","file":"libvirt-host","module":"libvirt-host"},"info":["Extract hardware information about the node."],"return":[{"$":{"type":"int","info":"0 in case of success and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"info","type":"virNodeInfoPtr","info":"pointer to a virNodeInfo structure allocated by the user"}}]},{"$":{"name":"virNodeGetMemoryParameters","file":"libvirt-host","module":"libvirt-host"},"info":["Get all node memory parameters (parameters unsupported by OS will be\nomitted).  On input, @nparams gives the size of the @params array;\non output, @nparams gives how many slots were filled with parameter\ninformation, which might be less but will not exceed the input value.\n\nAs a special case, calling with @params as NULL and @nparams as 0 on\ninput will cause @nparams on output to contain the number of parameters\nsupported by the hypervisor. The caller should then allocate @params\narray, i.e. (sizeof(@virTypedParameter) * @nparams) bytes and call the API\nagain.  See virDomainGetMemoryParameters() for an equivalent usage\nexample."],"return":[{"$":{"type":"int","info":"0 in case of success, and -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to memory parameter object (return value, allocated by the caller)"}},{"$":{"name":"nparams","type":"int *","info":"pointer to number of memory parameters; input and output"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeGetMemoryStats","file":"libvirt-host","module":"libvirt-host"},"info":["This function provides memory stats of the node.\nIf you want to get total memory statistics of the node, you must specify\nVIR_NODE_MEMORY_STATS_ALL_CELLS to @cellNum.\nThe @params array will be filled with the values equal to the number of\nstats suggested by @nparams\n\nAs the value of @nparams is dynamic, call the API setting @nparams to 0 and\n@params as NULL, the API returns the number of parameters supported by the\nHV by updating @nparams on SUCCESS. The caller should then allocate @params\narray, i.e. (sizeof(@virNodeMemoryStats) * @nparams) bytes and call\nthe API again.\n\nHere is the sample code snippet:\n\n  if (virNodeGetMemoryStats(conn, cellNum, NULL, &nparams, 0) == 0 &&\n      nparams != 0) {\n      if ((params = malloc(sizeof(virNodeMemoryStats) * nparams)) == NULL)\n          goto error;\n      memset(params, cellNum, 0, sizeof(virNodeMemoryStats) * nparams);\n      if (virNodeGetMemoryStats(conn, params, &nparams, 0))\n          goto error;\n  }\n\nThis function doesn't require privileged access to the hypervisor.\nThis function expects the caller to allocate the @params.\n\nMemory Stats:\n\nVIR_NODE_MEMORY_STATS_TOTAL:\n    The total memory usage.(KB)\nVIR_NODE_MEMORY_STATS_FREE:\n    The free memory usage.(KB)\n    On linux, this usage includes buffers and cached.\nVIR_NODE_MEMORY_STATS_BUFFERS:\n    The buffers memory usage.(KB)\nVIR_NODE_MEMORY_STATS_CACHED:\n    The cached memory usage.(KB)"],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection."}},{"$":{"name":"cellNum","type":"int","info":"number of node cell. (VIR_NODE_MEMORY_STATS_ALL_CELLS means total cell statistics)"}},{"$":{"name":"params","type":"virNodeMemoryStatsPtr","info":"pointer to node memory stats objects"}},{"$":{"name":"nparams","type":"int *","info":"number of node memory stats (this value should be same or less than the number of stats supported)"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeGetSecurityModel","file":"libvirt-host","module":"libvirt-host"},"info":["Extract the security model of a hypervisor. The 'model' field\nin the @secmodel argument may be initialized to the empty\nstring if the driver has not activated a security model."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"a connection object"}},{"$":{"name":"secmodel","type":"virSecurityModelPtr","info":"pointer to a virSecurityModel structure"}}]},{"$":{"name":"virNodeListDevices","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Collect the list of node devices, and store their names in @names\n\nFor more control over the results, see virConnectListAllNodeDevices().\n\nIf the optional 'cap'  argument is non-NULL, then the count\nwill be restricted to devices with the specified capability"],"return":[{"$":{"type":"int","info":"the number of node devices found or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"cap","type":"const char *","info":"capability name"}},{"$":{"name":"names","type":"char ** const","info":"array to collect the list of node device names"}},{"$":{"name":"maxnames","type":"int","info":"size of @names"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeNumOfDevices","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["Provides the number of node devices.\n\nIf the optional 'cap'  argument is non-NULL, then the count\nwill be restricted to devices with the specified capability"],"return":[{"$":{"type":"int","info":"the number of node devices or -1 in case of error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"cap","type":"const char *","info":"capability name"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeSetMemoryParameters","file":"libvirt-host","module":"libvirt-host"},"info":["Change all or a subset of the node memory tunables. The function\nfails if not all of the tunables are supported.\n\nNote that it's not recommended to use this function while the\noutside tuning program is running (such as ksmtuned under Linux),\nas they could change the tunables in parallel, which could cause\nconflicts.\n\nThis function may require privileged access to the hypervisor."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"pointer to scheduler parameter objects"}},{"$":{"name":"nparams","type":"int","info":"number of scheduler parameter objects (this value can be the same or less than the returned value nparams of virDomainGetSchedulerType)"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virNodeSuspendForDuration","file":"libvirt-host","module":"libvirt-host"},"info":["Attempt to suspend the node (host machine) for the given duration of\ntime in the specified state (Suspend-to-RAM, Suspend-to-Disk or\nHybrid-Suspend). Schedule the node's Real-Time-Clock interrupt to\nresume the node after the duration is complete."],"return":[{"$":{"type":"int","info":"0 on success (i.e., the node will be suspended after a short delay), -1 on failure (the operation is not supported, or an attempted suspend is already underway)."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"target","type":"unsigned int","info":"the state to which the host must be suspended to, such as: VIR_NODE_SUSPEND_TARGET_MEM (Suspend-to-RAM) VIR_NODE_SUSPEND_TARGET_DISK (Suspend-to-Disk) VIR_NODE_SUSPEND_TARGET_HYBRID (Hybrid-Suspend, which is a combination of the former modes)."}},{"$":{"name":"duration","type":"unsigned long long","info":"the time duration in seconds for which the host has to be suspended"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virResetError","file":"virterror","module":"virerror"},"info":["Reset the error being pointed to"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"err","type":"virErrorPtr","info":"pointer to the virError to clean up"}}]},{"$":{"name":"virResetLastError","file":"virterror","module":"virerror"},"info":["Reset the last error caught at the library level.\n\nThe error object is kept in thread local storage, so separate\nthreads can safely access this concurrently, only resetting\ntheir own error object."],"return":[{"$":{"type":"void"}}]},{"$":{"name":"virSaveLastError","file":"virterror","module":"virerror"},"info":["Save the last error into a new error object.  On success, errno is\nunchanged; on failure, errno is ENOMEM."],"return":[{"$":{"type":"virErrorPtr","info":"a pointer to the copied error or NULL if allocation failed. It is the caller's responsibility to free the error with virFreeError()."}}]},{"$":{"name":"virSecretDefineXML","file":"libvirt-secret","module":"libvirt-secret"},"info":["If XML specifies a UUID, locates the specified secret and replaces all\nattributes of the secret specified by UUID by attributes specified in xml\n(any attributes not specified in xml are discarded).\n\nOtherwise, creates a new secret with an automatically chosen UUID, and\ninitializes its attributes from xml.\n\nvirSecretFree should be used to free the resources after the\nsecret object is no longer needed."],"return":[{"$":{"type":"virSecretPtr","info":"a secret on success, NULL on failure."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}},{"$":{"name":"xml","type":"const char *","info":"XML describing the secret."}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virSecretFree","file":"libvirt-secret","module":"libvirt-secret"},"info":["Release the secret handle. The underlying secret continues to exist."],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error"}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"pointer to a secret"}}]},{"$":{"name":"virSecretGetConnect","file":"libvirt-secret","module":"libvirt-secret"},"info":["Provides the connection pointer associated with a secret.  The reference\ncounter on the connection is not increased by this call."],"return":[{"$":{"type":"virConnectPtr","info":"the virConnectPtr or NULL in case of failure."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"A virSecret secret"}}]},{"$":{"name":"virSecretGetUUID","file":"libvirt-secret","module":"libvirt-secret"},"info":["Fetches the UUID of the secret."],"return":[{"$":{"type":"int","info":"0 on success with the uuid buffer being filled, or -1 upon failure."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"A virSecret secret"}},{"$":{"name":"uuid","type":"unsigned char *","info":"buffer of VIR_UUID_BUFLEN bytes in size"}}]},{"$":{"name":"virSecretGetUUIDString","file":"libvirt-secret","module":"libvirt-secret"},"info":["Get the UUID for a secret as string. For more information about\nUUID see RFC4122."],"return":[{"$":{"type":"int","info":"-1 in case of error, 0 in case of success"}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"a secret object"}},{"$":{"name":"buf","type":"char *","info":"pointer to a VIR_UUID_STRING_BUFLEN bytes array"}}]},{"$":{"name":"virSecretGetUsageID","file":"libvirt-secret","module":"libvirt-secret"},"info":["Get the unique identifier of the object with which this\nsecret is to be used. The format of the identifier is\ndependent on the usage type of the secret. For a secret\nwith a usage type of VIR_SECRET_USAGE_TYPE_VOLUME the\nidentifier will be a fully qualified path name. The\nidentifiers are intended to be unique within the set of\nall secrets sharing the same usage type. ie, there shall\nonly ever be one secret for each volume path."],"return":[{"$":{"type":"const char *","info":"a string identifying the object using the secret, or NULL upon error"}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"a secret object"}}]},{"$":{"name":"virSecretGetUsageType","file":"libvirt-secret","module":"libvirt-secret"},"info":["Get the type of object which uses this secret. The returned\nvalue is one of the constants defined in the virSecretUsageType\nenumeration. More values may be added to this enumeration in\nthe future, so callers should expect to see usage types they\ndo not explicitly know about."],"return":[{"$":{"type":"int","info":"a positive integer identifying the type of object, or -1 upon error."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"a secret object"}}]},{"$":{"name":"virSecretGetValue","file":"libvirt-secret","module":"libvirt-secret"},"info":["Fetches the value of a secret."],"return":[{"$":{"type":"unsigned char *","info":"the secret value on success, NULL on failure.  The caller must free() the secret value."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"A virSecret connection"}},{"$":{"name":"value_size","type":"size_t *","info":"Place for storing size of the secret value"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virSecretGetXMLDesc","file":"libvirt-secret","module":"libvirt-secret"},"info":["Fetches an XML document describing attributes of the secret."],"return":[{"$":{"type":"char *","info":"the XML document on success, NULL on failure.  The caller must free() the XML."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"A virSecret secret"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virSecretLookupByUUID","file":"libvirt-secret","module":"libvirt-secret"},"info":["Try to lookup a secret on the given hypervisor based on its UUID.\nUses the 16 bytes of raw data to describe the UUID\n\nvirSecretFree should be used to free the resources after the\nsecret object is no longer needed."],"return":[{"$":{"type":"virSecretPtr","info":"a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuid","type":"const unsigned char *","info":"the raw UUID for the secret"}}]},{"$":{"name":"virSecretLookupByUUIDString","file":"libvirt-secret","module":"libvirt-secret"},"info":["Try to lookup a secret on the given hypervisor based on its UUID.\nUses the printable string value to describe the UUID\n\nvirSecretFree should be used to free the resources after the\nsecret object is no longer needed."],"return":[{"$":{"type":"virSecretPtr","info":"a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"uuidstr","type":"const char *","info":"the string UUID for the secret"}}]},{"$":{"name":"virSecretLookupByUsage","file":"libvirt-secret","module":"libvirt-secret"},"info":["Try to lookup a secret on the given hypervisor based on its usage\nThe usageID is unique within the set of secrets sharing the\nsame usageType value.\n\nvirSecretFree should be used to free the resources after the\nsecret object is no longer needed."],"return":[{"$":{"type":"virSecretPtr","info":"a new secret object or NULL in case of failure.  If the secret cannot be found, then VIR_ERR_NO_SECRET error is raised."}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the hypervisor connection"}},{"$":{"name":"usageType","type":"int","info":"the type of secret usage"}},{"$":{"name":"usageID","type":"const char *","info":"identifier of the object using the secret"}}]},{"$":{"name":"virSecretRef","file":"libvirt-secret","module":"libvirt-secret"},"info":["Increment the reference count on the secret. For each additional call to\nthis method, there shall be a corresponding call to virSecretFree to release\nthe reference count, once the caller no longer needs the reference to this\nobject.\n\nThis method is typically useful for applications where multiple threads are\nusing a connection, and it is required that the connection remain open until\nall threads have finished using it. ie, each new thread using a secret would\nincrement the reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"the secret to hold a reference on"}}]},{"$":{"name":"virSecretSetValue","file":"libvirt-secret","module":"libvirt-secret"},"info":["Sets the value of a secret."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"A virSecret secret"}},{"$":{"name":"value","type":"const unsigned char *","info":"Value of the secret"}},{"$":{"name":"value_size","type":"size_t","info":"Size of the value"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virSecretUndefine","file":"libvirt-secret","module":"libvirt-secret"},"info":["Deletes the specified secret.  This does not free the associated\nvirSecretPtr object."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure."}}],"arg":[{"$":{"name":"secret","type":"virSecretPtr","info":"A virSecret secret"}}]},{"$":{"name":"virSetErrorFunc","file":"virterror","module":"virerror"},"info":["Set a library global error handling function, if @handler is NULL,\nit will reset to default printing on stderr. The error raised there\nare those for which no handler at the connection level could caught."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"userData","type":"void *","info":"pointer to the user data provided in the handler callback"}},{"$":{"name":"handler","type":"virErrorFunc","info":"the function to get called in case of error or NULL"}}]},{"$":{"name":"virStoragePoolBuild","file":"libvirt-storage","module":"libvirt-storage"},"info":["Currently only filesystem pool accepts flags VIR_STORAGE_POOL_BUILD_OVERWRITE\nand VIR_STORAGE_POOL_BUILD_NO_OVERWRITE.\n\nBuild the underlying storage pool"],"return":[{"$":{"type":"int","info":"0 on success, or -1 upon failure"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStoragePoolBuildFlags"}}]},{"$":{"name":"virStoragePoolCreate","file":"libvirt-storage","module":"libvirt-storage"},"info":["Starts an inactive storage pool"],"return":[{"$":{"type":"int","info":"0 on success, or -1 if it could not be started"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStoragePoolCreateFlags"}}]},{"$":{"name":"virStoragePoolCreateXML","file":"libvirt-storage","module":"libvirt-storage"},"info":["Create a new storage based on its XML description. The\npool is not persistent, so its definition will disappear\nwhen it is destroyed, or if the host is restarted\n\nvirStoragePoolFree should be used to free the resources after the\nstorage pool object is no longer needed."],"return":[{"$":{"type":"virStoragePoolPtr","info":"a virStoragePoolPtr object, or NULL if creation failed"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"xmlDesc","type":"const char *","info":"XML description for new pool"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStoragePoolCreateFlags"}}]},{"$":{"name":"virStoragePoolDefineXML","file":"libvirt-storage","module":"libvirt-storage"},"info":["Define an inactive persistent storage pool or modify an existing persistent\none from the XML description.\n\nvirStoragePoolFree should be used to free the resources after the\nstorage pool object is no longer needed."],"return":[{"$":{"type":"virStoragePoolPtr","info":"a virStoragePoolPtr object, or NULL if creation failed"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"xml","type":"const char *","info":"XML description for new pool"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virStoragePoolDelete","file":"libvirt-storage","module":"libvirt-storage"},"info":["Delete the underlying pool resources. This is\na non-recoverable operation. The virStoragePoolPtr object\nitself is not free'd."],"return":[{"$":{"type":"int","info":"0 on success, or -1 if it could not be obliterate"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStoragePoolDeleteFlags"}}]},{"$":{"name":"virStoragePoolDestroy","file":"libvirt-storage","module":"libvirt-storage"},"info":["Destroy an active storage pool. This will deactivate the\npool on the host, but keep any persistent config associated\nwith it. If it has a persistent config it can later be\nrestarted with virStoragePoolCreate(). This does not free\nthe associated virStoragePoolPtr object."],"return":[{"$":{"type":"int","info":"0 on success, or -1 if it could not be destroyed"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}}]},{"$":{"name":"virStoragePoolFree","file":"libvirt-storage","module":"libvirt-storage"},"info":["Free a storage pool object, releasing all memory associated with\nit. Does not change the state of the pool on the host."],"return":[{"$":{"type":"int","info":"0 on success, or -1 if it could not be free'd."}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}}]},{"$":{"name":"virStoragePoolGetAutostart","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetches the value of the autostart flag, which determines\nwhether the pool is automatically started at boot time"],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"autostart","type":"int *","info":"location in which to store autostart flag"}}]},{"$":{"name":"virStoragePoolGetConnect","file":"libvirt-storage","module":"libvirt-storage"},"info":["Provides the connection pointer associated with a storage pool.  The\nreference counter on the connection is not increased by this\ncall."],"return":[{"$":{"type":"virConnectPtr","info":"the virConnectPtr or NULL in case of failure."}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to a pool"}}]},{"$":{"name":"virStoragePoolGetInfo","file":"libvirt-storage","module":"libvirt-storage"},"info":["Get volatile information about the storage pool\nsuch as free space / usage summary"],"return":[{"$":{"type":"int","info":"0 on success, or -1 on failure."}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"info","type":"virStoragePoolInfoPtr","info":"pointer at which to store info"}}]},{"$":{"name":"virStoragePoolGetName","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch the locally unique name of the storage pool"],"return":[{"$":{"type":"const char *","info":"the name of the pool, or NULL on error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}}]},{"$":{"name":"virStoragePoolGetUUID","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch the globally unique ID of the storage pool"],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error;"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"uuid","type":"unsigned char *","info":"buffer of VIR_UUID_BUFLEN bytes in size"}}]},{"$":{"name":"virStoragePoolGetUUIDString","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch the globally unique ID of the storage pool as a string"],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error;"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"buf","type":"char *","info":"buffer of VIR_UUID_STRING_BUFLEN bytes in size"}}]},{"$":{"name":"virStoragePoolGetXMLDesc","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch an XML document describing all aspects of the\nstorage pool. This is suitable for later feeding back\ninto the virStoragePoolCreateXML method."],"return":[{"$":{"type":"char *","info":"a XML document (caller frees), or NULL on error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageXMLFlags"}}]},{"$":{"name":"virStoragePoolIsActive","file":"libvirt-storage","module":"libvirt-storage"},"info":["Determine if the storage pool is currently running"],"return":[{"$":{"type":"int","info":"1 if running, 0 if inactive, -1 on error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to the storage pool object"}}]},{"$":{"name":"virStoragePoolIsPersistent","file":"libvirt-storage","module":"libvirt-storage"},"info":["Determine if the storage pool has a persistent configuration\nwhich means it will still exist after shutting down"],"return":[{"$":{"type":"int","info":"1 if persistent, 0 if transient, -1 on error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to the storage pool object"}}]},{"$":{"name":"virStoragePoolListAllVolumes","file":"libvirt-storage","module":"libvirt-storage"},"info":["Collect the list of storage volumes, and allocate an array to store those\nobjects."],"return":[{"$":{"type":"int","info":"the number of storage volumes found or -1 and sets @vols to NULL in case of error.  On success, the array stored into @vols is guaranteed to have an extra allocated element set to NULL but not included in the return count, to make iteration easier.  The caller is responsible for calling virStorageVolFree() on each array element, then calling free() on @vols."}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"Pointer to storage pool"}},{"$":{"name":"vols","type":"virStorageVolPtr **","info":"Pointer to a variable to store the array containing storage volume objects or NULL if the list is not required (just returns number of volumes)."}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virStoragePoolListVolumes","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch list of storage volume names, limiting to\nat most maxnames.\n\nTo list the volume objects directly, see virStoragePoolListAllVolumes()."],"return":[{"$":{"type":"int","info":"the number of names fetched, or -1 on error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"names","type":"char ** const","info":"array in which to storage volume names"}},{"$":{"name":"maxnames","type":"int","info":"size of names array"}}]},{"$":{"name":"virStoragePoolLookupByName","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a storage pool based on its unique name\n\nvirStoragePoolFree should be used to free the resources after the\nstorage pool object is no longer needed."],"return":[{"$":{"type":"virStoragePoolPtr","info":"a virStoragePoolPtr object, or NULL if no matching pool is found"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"name","type":"const char *","info":"name of pool to fetch"}}]},{"$":{"name":"virStoragePoolLookupByTargetPath","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a storage pool which maps to a particular target directory.\nIf more than one pool maps to the path, it is undefined which\nwill be returned first.\n\nvirStoragePoolFree should be used to free the resources after the\nstorage pool object is no longer needed."],"return":[{"$":{"type":"virStoragePoolPtr","info":"a virStoragePoolPtr object, or NULL if no matching pool is found"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"path","type":"const char *","info":"path at which the pool is exposed"}}]},{"$":{"name":"virStoragePoolLookupByUUID","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a storage pool based on its globally unique id\n\nvirStoragePoolFree should be used to free the resources after the\nstorage pool object is no longer needed."],"return":[{"$":{"type":"virStoragePoolPtr","info":"a virStoragePoolPtr object, or NULL if no matching pool is found"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"uuid","type":"const unsigned char *","info":"globally unique id of pool to fetch"}}]},{"$":{"name":"virStoragePoolLookupByUUIDString","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a storage pool based on its globally unique id\n\nvirStoragePoolFree should be used to free the resources after the\nstorage pool object is no longer needed."],"return":[{"$":{"type":"virStoragePoolPtr","info":"a virStoragePoolPtr object, or NULL if no matching pool is found"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"uuidstr","type":"const char *","info":"globally unique id of pool to fetch"}}]},{"$":{"name":"virStoragePoolLookupByVolume","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a storage pool which contains a particular volume\n\nvirStoragePoolFree should be used to free the resources after the\nstorage pool object is no longer needed."],"return":[{"$":{"type":"virStoragePoolPtr","info":"a virStoragePoolPtr object, or NULL if no matching pool is found"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}}]},{"$":{"name":"virStoragePoolNumOfVolumes","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch the number of storage volumes within a pool"],"return":[{"$":{"type":"int","info":"the number of storage pools, or -1 on failure"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}}]},{"$":{"name":"virStoragePoolRef","file":"libvirt-storage","module":"libvirt-storage"},"info":["Increment the reference count on the pool. For each\nadditional call to this method, there shall be a corresponding\ncall to virStoragePoolFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using a pool would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"the pool to hold a reference on"}}]},{"$":{"name":"virStoragePoolRefresh","file":"libvirt-storage","module":"libvirt-storage"},"info":["Request that the pool refresh its list of volumes. This may\ninvolve communicating with a remote server, and/or initializing\nnew devices at the OS layer"],"return":[{"$":{"type":"int","info":"0 if the volume list was refreshed, -1 on failure"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virStoragePoolSetAutostart","file":"libvirt-storage","module":"libvirt-storage"},"info":["Sets the autostart flag"],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"autostart","type":"int","info":"new flag setting"}}]},{"$":{"name":"virStoragePoolUndefine","file":"libvirt-storage","module":"libvirt-storage"},"info":["Undefine an inactive storage pool"],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}}]},{"$":{"name":"virStorageVolCreateXML","file":"libvirt-storage","module":"libvirt-storage"},"info":["Create a storage volume within a pool based\non an XML description. Not all pools support\ncreation of volumes.\n\nSince 1.0.1 VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA\nin flags can be used to get higher performance with\nqcow2 image files which don't support full preallocation,\nby creating a sparse image file with metadata.\n\nvirStorageVolFree should be used to free the resources after the\nstorage volume object is no longer needed."],"return":[{"$":{"type":"virStorageVolPtr","info":"the storage volume, or NULL on error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"xmlDesc","type":"const char *","info":"description of volume to create"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageVolCreateFlags"}}]},{"$":{"name":"virStorageVolCreateXMLFrom","file":"libvirt-storage","module":"libvirt-storage"},"info":["Create a storage volume in the parent pool, using the\n'clonevol' volume as input. Information for the new\nvolume (name, perms)  are passed via a typical volume\nXML description.\n\nSince 1.0.1 VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA\nin flags can be used to get higher performance with\nqcow2 image files which don't support full preallocation,\nby creating a sparse image file with metadata.\n\nvirStorageVolFree should be used to free the resources after the\nstorage volume object is no longer needed."],"return":[{"$":{"type":"virStorageVolPtr","info":"the storage volume, or NULL on error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to parent pool for the new volume"}},{"$":{"name":"xmlDesc","type":"const char *","info":"description of volume to create"}},{"$":{"name":"clonevol","type":"virStorageVolPtr","info":"storage volume to use as input"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageVolCreateFlags"}}]},{"$":{"name":"virStorageVolDelete","file":"libvirt-storage","module":"libvirt-storage"},"info":["Delete the storage volume from the pool"],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageVolDeleteFlags"}}]},{"$":{"name":"virStorageVolDownload","file":"libvirt-storage","module":"libvirt-storage"},"info":["Download the content of the volume as a stream. If @length\nis zero, then the remaining contents of the volume after\n@offset will be downloaded.\n\nIf VIR_STORAGE_VOL_DOWNLOAD_SPARSE_STREAM is set in @flags\neffective transmission of holes is enabled. This assumes using\nthe @stream with combination of virStreamSparseRecvAll() or\nvirStreamRecvFlags(stream, ..., flags =\nVIR_STREAM_RECV_STOP_AT_HOLE) for honouring holes sent by\nserver.\n\nThis call sets up an asynchronous stream; subsequent use of\nstream APIs is necessary to transfer the actual data,\ndetermine how much data is successfully transferred, and\ndetect any errors. The results will be unpredictable if\nanother active stream is writing to the storage volume."],"return":[{"$":{"type":"int","info":"0, or -1 upon error."}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to volume to download from"}},{"$":{"name":"stream","type":"virStreamPtr","info":"stream to use as output"}},{"$":{"name":"offset","type":"unsigned long long","info":"position in @vol to start reading from"}},{"$":{"name":"length","type":"unsigned long long","info":"limit on amount of data to download"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageVolDownloadFlags"}}]},{"$":{"name":"virStorageVolFree","file":"libvirt-storage","module":"libvirt-storage"},"info":["Release the storage volume handle. The underlying\nstorage volume continues to exist."],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}}]},{"$":{"name":"virStorageVolGetConnect","file":"libvirt-storage","module":"libvirt-storage"},"info":["Provides the connection pointer associated with a storage volume.  The\nreference counter on the connection is not increased by this\ncall."],"return":[{"$":{"type":"virConnectPtr","info":"the virConnectPtr or NULL in case of failure."}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to a pool"}}]},{"$":{"name":"virStorageVolGetInfo","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetches volatile information about the storage\nvolume such as its current allocation"],"return":[{"$":{"type":"int","info":"0 on success, or -1 on failure"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}},{"$":{"name":"info","type":"virStorageVolInfoPtr","info":"pointer at which to store info"}}]},{"$":{"name":"virStorageVolGetInfoFlags","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetches volatile information about the storage\nvolume such as its current allocation.\n\nIf the @flags argument is VIR_STORAGE_VOL_GET_PHYSICAL, then the physical\nbytes used for the volume will be returned in the @info allocation field.\nThis is useful for sparse files and certain volume file types where the\nphysical on disk usage can be different than the calculated allocation value\nas is the case with qcow2 files."],"return":[{"$":{"type":"int","info":"0 on success, or -1 on failure"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}},{"$":{"name":"info","type":"virStorageVolInfoPtr","info":"pointer at which to store info"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageVolInfoFlags"}}]},{"$":{"name":"virStorageVolGetKey","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch the storage volume key. This is globally\nunique, so the same volume will have the same\nkey no matter what host it is accessed from"],"return":[{"$":{"type":"const char *","info":"the volume key, or NULL on error"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}}]},{"$":{"name":"virStorageVolGetName","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch the storage volume name. This is unique\nwithin the scope of a pool"],"return":[{"$":{"type":"const char *","info":"the volume name, or NULL on error"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}}]},{"$":{"name":"virStorageVolGetPath","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch the storage volume path. Depending on the pool\nconfiguration this is either persistent across hosts,\nor dynamically assigned at pool startup. Consult\npool documentation for information on getting the\npersistent naming"],"return":[{"$":{"type":"char *","info":"the storage volume path, or NULL on error. The caller must free() the returned path after use."}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}}]},{"$":{"name":"virStorageVolGetXMLDesc","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch an XML document describing all aspects of\nthe storage volume"],"return":[{"$":{"type":"char *","info":"the XML document, or NULL on error"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virStorageVolLookupByKey","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a pointer to a storage volume based on its\nglobally unique key\n\nvirStorageVolFree should be used to free the resources after the\nstorage volume object is no longer needed."],"return":[{"$":{"type":"virStorageVolPtr","info":"a storage volume, or NULL if not found / error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"key","type":"const char *","info":"globally unique key"}}]},{"$":{"name":"virStorageVolLookupByName","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a pointer to a storage volume based on its name\nwithin a pool\n\nvirStorageVolFree should be used to free the resources after the\nstorage volume object is no longer needed."],"return":[{"$":{"type":"virStorageVolPtr","info":"a storage volume, or NULL if not found / error"}}],"arg":[{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pointer to storage pool"}},{"$":{"name":"name","type":"const char *","info":"name of storage volume"}}]},{"$":{"name":"virStorageVolLookupByPath","file":"libvirt-storage","module":"libvirt-storage"},"info":["Fetch a pointer to a storage volume based on its\nlocally (host) unique path\n\nvirStorageVolFree should be used to free the resources after the\nstorage volume object is no longer needed."],"return":[{"$":{"type":"virStorageVolPtr","info":"a storage volume, or NULL if not found / error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to hypervisor connection"}},{"$":{"name":"path","type":"const char *","info":"locally unique path"}}]},{"$":{"name":"virStorageVolRef","file":"libvirt-storage","module":"libvirt-storage"},"info":["Increment the reference count on the vol. For each\nadditional call to this method, there shall be a corresponding\ncall to virStorageVolFree to release the reference count, once\nthe caller no longer needs the reference to this object.\n\nThis method is typically useful for applications where multiple\nthreads are using a connection, and it is required that the\nconnection remain open until all threads have finished using\nit. ie, each new thread using a vol would increment\nthe reference count."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure."}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"the vol to hold a reference on"}}]},{"$":{"name":"virStorageVolResize","file":"libvirt-storage","module":"libvirt-storage"},"info":["Changes the capacity of the storage volume @vol to @capacity. The\noperation will fail if the new capacity requires allocation that would\nexceed the remaining free space in the parent pool.  The contents of\nthe new capacity will appear as all zero bytes. The capacity value will\nbe rounded to the granularity supported by the hypervisor.\n\nNormally, the operation will attempt to affect capacity with a minimum\nimpact on allocation (that is, the default operation favors a sparse\nresize).  If @flags contains VIR_STORAGE_VOL_RESIZE_ALLOCATE, then the\noperation will ensure that allocation is sufficient for the new\ncapacity; this may make the operation take noticeably longer.\n\nNormally, the operation treats @capacity as the new size in bytes;\nbut if @flags contains VIR_STORAGE_VOL_RESIZE_DELTA, then @capacity\nrepresents the size difference to add to the current size.  It is\nup to the storage pool implementation whether unaligned requests are\nrounded up to the next valid boundary, or rejected.\n\nNormally, this operation should only be used to enlarge capacity;\nbut if @flags contains VIR_STORAGE_VOL_RESIZE_SHRINK, it is possible to\nattempt a reduction in capacity even though it might cause data loss.\nIf VIR_STORAGE_VOL_RESIZE_DELTA is also present, then @capacity is\nsubtracted from the current size; without it, @capacity represents\nthe absolute new size regardless of whether it is larger or smaller\nthan the current size."],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error."}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}},{"$":{"name":"capacity","type":"unsigned long long","info":"new capacity, in bytes"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageVolResizeFlags"}}]},{"$":{"name":"virStorageVolUpload","file":"libvirt-storage","module":"libvirt-storage"},"info":["Upload new content to the volume from a stream. This call\nwill fail if @offset + @length exceeds the size of the\nvolume. Otherwise, if @length is non-zero, an error\nwill be raised if an attempt is made to upload greater\nthan @length bytes of data.\n\nIf VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM is set in @flags\neffective transmission of holes is enabled. This assumes using\nthe @stream with combination of virStreamSparseSendAll() or\nvirStreamSendHole() to preserve source file sparseness.\n\nThis call sets up an asynchronous stream; subsequent use of\nstream APIs is necessary to transfer the actual data,\ndetermine how much data is successfully transferred, and\ndetect any errors. The results will be unpredictable if\nanother active stream is writing to the storage volume.\n\nWhen the data stream is closed whether the upload is successful\nor not an attempt will be made to refresh the target storage pool\nif an asynchronous build is not running in order to reflect pool\nand volume changes as a result of the upload. Depending on\nthe target volume storage backend and the source stream type\nfor a successful upload, the target volume may take on the\ncharacteristics from the source stream such as format type,\ncapacity, and allocation."],"return":[{"$":{"type":"int","info":"0, or -1 upon error."}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to volume to upload"}},{"$":{"name":"stream","type":"virStreamPtr","info":"stream to use as input"}},{"$":{"name":"offset","type":"unsigned long long","info":"position to start writing to"}},{"$":{"name":"length","type":"unsigned long long","info":"limit on amount of data to upload"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStorageVolUploadFlags"}}]},{"$":{"name":"virStorageVolWipe","file":"libvirt-storage","module":"libvirt-storage"},"info":["Ensure data previously on a volume is not accessible to future reads.\n\nThe data to be wiped may include the format and possibly size information,\nso non-raw images might become raw with a different size. It is storage\nbackend dependent whether the format and size information is regenerated\nonce the initial volume wipe is completed.\n\nDepending on the actual volume representation, this call may not\noverwrite the physical location of the volume. For instance, files\nstored journaled, log structured, copy-on-write, versioned, and\nnetwork file systems are known to be problematic."],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error"}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virStorageVolWipePattern","file":"libvirt-storage","module":"libvirt-storage"},"info":["Similar to virStorageVolWipe, but one can choose between\ndifferent wiping algorithms. Also note, that depending on the\nactual volume representation, this call may not really\noverwrite the physical location of the volume. For instance,\nfiles stored journaled, log structured, copy-on-write,\nversioned, and network file systems are known to be\nproblematic."],"return":[{"$":{"type":"int","info":"0 on success, or -1 on error."}}],"arg":[{"$":{"name":"vol","type":"virStorageVolPtr","info":"pointer to storage volume"}},{"$":{"name":"algorithm","type":"unsigned int","info":"one of virStorageVolWipeAlgorithm"}},{"$":{"name":"flags","type":"unsigned int","info":"future flags, use 0 for now"}}]},{"$":{"name":"virStreamAbort","file":"libvirt-stream","module":"libvirt-stream"},"info":["Request that the in progress data transfer be cancelled\nabnormally before the end of the stream has been reached.\nFor output streams this can be used to inform the driver\nthat the stream is being terminated early. For input\nstreams this can be used to inform the driver that it\nshould stop sending data.\n\nIf the stream is non-blocking, any callback must be removed\nbeforehand."],"return":[{"$":{"type":"int","info":"0 on success, -1 upon error"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}}]},{"$":{"name":"virStreamEventAddCallback","file":"libvirt-stream","module":"libvirt-stream"},"info":["Register a callback to be notified when a stream\nbecomes writable, or readable. This is most commonly\nused in conjunction with non-blocking data streams\nto integrate into an event loop"],"return":[{"$":{"type":"int","info":"0 on success, -1 upon error"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"events","type":"int","info":"set of events to monitor"}},{"$":{"name":"cb","type":"virStreamEventCallback","info":"callback to invoke when an event occurs"}},{"$":{"name":"opaque","type":"void *","info":"application defined data"}},{"$":{"name":"ff","type":"virFreeCallback","info":"callback to free @opaque data"}}]},{"$":{"name":"virStreamEventRemoveCallback","file":"libvirt-stream","module":"libvirt-stream"},"info":["Remove an event callback from the stream"],"return":[{"$":{"type":"int","info":"0 on success, -1 on error"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}}]},{"$":{"name":"virStreamEventUpdateCallback","file":"libvirt-stream","module":"libvirt-stream"},"info":["Changes the set of events to monitor for a stream. This allows\nfor event notification to be changed without having to\nunregister & register the callback completely. This method\nis guaranteed to succeed if a callback is already registered"],"return":[{"$":{"type":"int","info":"0 on success, -1 if no callback is registered"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"events","type":"int","info":"set of events to monitor"}}]},{"$":{"name":"virStreamFinish","file":"libvirt-stream","module":"libvirt-stream"},"info":["Indicate that there is no further data to be transmitted\non the stream. For output streams this should be called once\nall data has been written. For input streams this should be\ncalled once virStreamRecv returns end-of-file.\n\nThis method is a synchronization point for all asynchronous\nerrors, so if this returns a success code the application can\nbe sure that all data has been successfully processed.\n\nIf the stream is non-blocking, any callback must be removed\nbeforehand."],"return":[{"$":{"type":"int","info":"0 on success, -1 upon error"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}}]},{"$":{"name":"virStreamFree","file":"libvirt-stream","module":"libvirt-stream"},"info":["Decrement the reference count on a stream, releasing\nthe stream object if the reference count has hit zero.\n\nThere must not be an active data transfer in progress\nwhen releasing the stream. If a stream needs to be\ndisposed of prior to end of stream being reached, then\nthe virStreamAbort function should be called first."],"return":[{"$":{"type":"int","info":"0 upon success, or -1 on error"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}}]},{"$":{"name":"virStreamNew","file":"libvirt-stream","module":"libvirt-stream"},"info":["Creates a new stream object which can be used to perform\nstreamed I/O with other public API function.\n\nWhen no longer needed, a stream object must be released\nwith virStreamFree. If a data stream has been used,\nthen the application must call virStreamFinish or\nvirStreamAbort before free'ing to, in order to notify\nthe driver of termination.\n\nIf a non-blocking data stream is required passed\nVIR_STREAM_NONBLOCK for flags, otherwise pass 0."],"return":[{"$":{"type":"virStreamPtr","info":"the new stream, or NULL upon error"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"pointer to the connection"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStreamFlags"}}]},{"$":{"name":"virStreamRecv","file":"libvirt-stream","module":"libvirt-stream"},"info":["Reads a series of bytes from the stream. This method may\nblock the calling application for an arbitrary amount\nof time.\n\nErrors are not guaranteed to be reported synchronously\nwith the call, but may instead be delayed until a\nsubsequent call.\n\nAn example using this with a hypothetical file download\nAPI looks like\n\n    virStreamPtr st = virStreamNew(conn, 0);\n    int fd = open(\"demo.iso\", O_WRONLY, 0600);\n\n    virConnectDownloadFile(conn, \"demo.iso\", st);\n\n    while (1) {\n        char buf[1024];\n        int got = virStreamRecv(st, buf, 1024);\n        if (got < 0) {\n           virStreamAbort(st);\n           break;\n        }\n        if (got == 0) {\n           virStreamFinish(st);\n           break;\n        }\n        int offset = 0;\n        while (offset < got) {\n           int sent = write(fd, buf + offset, got - offset);\n           if (sent < 0) {\n              virStreamAbort(st);\n              goto done;\n           }\n           offset += sent;\n        }\n    }\n    if (virStreamFinish(st) < 0)\n       ... report an error ....\n  done:\n    virStreamFree(st);\n    close(fd);"],"return":[{"$":{"type":"int","info":"the number of bytes read, which may be less than requested.  Returns 0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if there is no data pending to be read & the stream is marked as non-blocking."}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"data","type":"char *","info":"buffer to read into from stream"}},{"$":{"name":"nbytes","type":"size_t","info":"size of @data buffer"}}]},{"$":{"name":"virStreamRecvAll","file":"libvirt-stream","module":"libvirt-stream"},"info":["Receive the entire data stream, sending the data to the\nrequested data sink. This is simply a convenient alternative\nto virStreamRecv, for apps that do blocking-I/O.\n\nAn example using this with a hypothetical file download\nAPI looks like\n\n  int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {\n      int *fd = opaque;\n\n      return write(*fd, buf, nbytes);\n  }\n\n  virStreamPtr st = virStreamNew(conn, 0);\n  int fd = open(\"demo.iso\", O_WRONLY);\n\n  virConnectUploadFile(conn, st);\n  if (virStreamRecvAll(st, mysink, &fd) < 0) {\n     ...report an error ...\n     goto done;\n  }\n  if (virStreamFinish(st) < 0)\n     ...report an error...\n  virStreamFree(st);\n  close(fd);"],"return":[{"$":{"type":"int","info":"0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree()"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"handler","type":"virStreamSinkFunc","info":"sink callback for writing data to application"}},{"$":{"name":"opaque","type":"void *","info":"application defined data"}}]},{"$":{"name":"virStreamRecvFlags","file":"libvirt-stream","module":"libvirt-stream"},"info":["Reads a series of bytes from the stream. This method may\nblock the calling application for an arbitrary amount\nof time.\n\nThis is just like virStreamRecv except this one has extra\n@flags. Calling this function with no @flags set (equal to\nzero) is equivalent to calling virStreamRecv(stream, data, nbytes).\n\nIf flag VIR_STREAM_RECV_STOP_AT_HOLE is set, this function\nwill stop reading from stream if it has reached a hole. In\nthat case, -3 is returned and virStreamRecvHole() should be\ncalled to get the hole size. An example using this flag might\nlook like this:\n\n  while (1) {\n    char buf[4096];\n\n    int ret = virStreamRecvFlags(st, buf, len, VIR_STREAM_STOP_AT_HOLE);\n    if (ret < 0) {\n      if (ret == -3) {\n        long long len;\n        ret = virStreamRecvHole(st, &len, 0);\n        if (ret < 0) {\n          ...error..\n        } else {\n          ...seek len bytes in target...\n        }\n      } else {\n        return -1;\n      }\n    } else {\n        ...write buf to target...\n    }\n  }"],"return":[{"$":{"type":"int","info":"0 when the end of the stream is reached, at which time the caller should invoke virStreamFinish() to get confirmation of stream completion.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if there is no data pending to be read & the stream is marked as non-blocking.  Returns -3 if there is a hole in stream and caller requested to stop at a hole."}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"data","type":"char *","info":"buffer to read into from stream"}},{"$":{"name":"nbytes","type":"size_t","info":"size of @data buffer"}},{"$":{"name":"flags","type":"unsigned int","info":"bitwise-OR of virStreamRecvFlagsValues"}}]},{"$":{"name":"virStreamRecvHole","file":"libvirt-stream","module":"libvirt-stream"},"info":["This API is used to determine the @length in bytes of the\nempty space to be created in a @stream's target file when\nuploading or downloading sparsely populated files. This is the\ncounterpart to virStreamSendHole()."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error or when there's currently no hole in the stream"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"length","type":"long long *","info":"number of bytes to skip"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virStreamRef","file":"libvirt-stream","module":"libvirt-stream"},"info":["Increment the reference count on the stream. For each\nadditional call to this method, there shall be a corresponding\ncall to virStreamFree to release the reference count, once\nthe caller no longer needs the reference to this object."],"return":[{"$":{"type":"int","info":"0 in case of success, -1 in case of failure"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream"}}]},{"$":{"name":"virStreamSend","file":"libvirt-stream","module":"libvirt-stream"},"info":["Write a series of bytes to the stream. This method may\nblock the calling application for an arbitrary amount\nof time. Once an application has finished sending data\nit should call virStreamFinish to wait for successful\nconfirmation from the driver, or detect any error.\n\nThis method may not be used if a stream source has been\nregistered.\n\nErrors are not guaranteed to be reported synchronously\nwith the call, but may instead be delayed until a\nsubsequent call.\n\nAn example using this with a hypothetical file upload\nAPI looks like\n\n    virStreamPtr st = virStreamNew(conn, 0);\n    int fd = open(\"demo.iso\", O_RDONLY);\n\n    virConnectUploadFile(conn, \"demo.iso\", st);\n\n    while (1) {\n         char buf[1024];\n         int got = read(fd, buf, 1024);\n         if (got < 0) {\n            virStreamAbort(st);\n            break;\n         }\n         if (got == 0) {\n            virStreamFinish(st);\n            break;\n         }\n         int offset = 0;\n         while (offset < got) {\n            int sent = virStreamSend(st, buf+offset, got-offset);\n            if (sent < 0) {\n               virStreamAbort(st);\n               goto done;\n            }\n            offset += sent;\n         }\n     }\n     if (virStreamFinish(st) < 0)\n        ... report an error ....\n   done:\n     virStreamFree(st);\n     close(fd);"],"return":[{"$":{"type":"int","info":"the number of bytes written, which may be less than requested.  Returns -1 upon error, at which time the stream will be marked as aborted, and the caller should now release the stream with virStreamFree.  Returns -2 if the outgoing transmit buffers are full & the stream is marked as non-blocking."}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"data","type":"const char *","info":"buffer to write to stream"}},{"$":{"name":"nbytes","type":"size_t","info":"size of @data buffer"}}]},{"$":{"name":"virStreamSendAll","file":"libvirt-stream","module":"libvirt-stream"},"info":["Send the entire data stream, reading the data from the\nrequested data source. This is simply a convenient alternative\nto virStreamSend, for apps that do blocking-I/O.\n\nAn example using this with a hypothetical file upload\nAPI looks like\n\n  int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {\n      int *fd = opaque;\n\n      return read(*fd, buf, nbytes);\n  }\n\n  virStreamPtr st = virStreamNew(conn, 0);\n  int fd = open(\"demo.iso\", O_RDONLY);\n\n  virConnectUploadFile(conn, st);\n  if (virStreamSendAll(st, mysource, &fd) < 0) {\n     ...report an error ...\n     goto done;\n  }\n  if (virStreamFinish(st) < 0)\n     ...report an error...\n  virStreamFree(st);\n  close(fd);"],"return":[{"$":{"type":"int","info":"0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree()."}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"handler","type":"virStreamSourceFunc","info":"source callback for reading data from application"}},{"$":{"name":"opaque","type":"void *","info":"application defined data"}}]},{"$":{"name":"virStreamSendHole","file":"libvirt-stream","module":"libvirt-stream"},"info":["Rather than transmitting empty file space, this API directs\nthe @stream target to create @length bytes of empty space.\nThis API would be used when uploading or downloading sparsely\npopulated files to avoid the needless copy of empty file\nspace.\n\nAn example using this with a hypothetical file upload API\nlooks like:\n\n  virStream st;\n\n  while (1) {\n    char buf[4096];\n    size_t len;\n    if (..in hole...) {\n      ..get hole size...\n      virStreamSendHole(st, len, 0);\n    } else {\n      ...read len bytes...\n      virStreamSend(st, buf, len);\n    }\n  }"],"return":[{"$":{"type":"int","info":"0 on success, -1 error"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"length","type":"long long","info":"number of bytes to skip"}},{"$":{"name":"flags","type":"unsigned int","info":"extra flags; not used yet, so callers should always pass 0"}}]},{"$":{"name":"virStreamSparseRecvAll","file":"libvirt-stream","module":"libvirt-stream"},"info":["Receive the entire data stream, sending the data to the\nrequested data sink @handler and calling the skip @holeHandler\nto generate holes for sparse stream targets. This is simply a\nconvenient alternative to virStreamRecvFlags, for apps that do\nblocking-I/O.\n\nAn example using this with a hypothetical file download\nAPI looks like:\n\n  int mysink(virStreamPtr st, const char *buf, int nbytes, void *opaque) {\n      int *fd = opaque;\n\n      return write(*fd, buf, nbytes);\n  }\n\n  int myskip(virStreamPtr st, long long offset, void *opaque) {\n      int *fd = opaque;\n\n      return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;\n  }\n\n  virStreamPtr st = virStreamNew(conn, 0);\n  int fd = open(\"demo.iso\", O_WRONLY);\n\n  virConnectDownloadSparseFile(conn, st);\n  if (virStreamSparseRecvAll(st, mysink, myskip, &fd) < 0) {\n     ...report an error ...\n     goto done;\n  }\n  if (virStreamFinish(st) < 0)\n     ...report an error...\n  virStreamFree(st);\n  close(fd);\n\nNote that @opaque data is shared between both @handler and\n@holeHandler callbacks."],"return":[{"$":{"type":"int","info":"0 if all the data was successfully received. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree(st).  Returns -1 upon any error, with virStreamAbort() already having been called, so the caller need only call virStreamFree()."}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"handler","type":"virStreamSinkFunc","info":"sink callback for writing data to application"}},{"$":{"name":"holeHandler","type":"virStreamSinkHoleFunc","info":"stream hole callback for skipping holes"}},{"$":{"name":"opaque","type":"void *","info":"application defined data"}}]},{"$":{"name":"virStreamSparseSendAll","file":"libvirt-stream","module":"libvirt-stream"},"info":["Send the entire data stream, reading the data from the\nrequested data source. This is simply a convenient alternative\nto virStreamSend, for apps that do blocking-I/O.\n\nAn example using this with a hypothetical file upload\nAPI looks like\n\n  int mysource(virStreamPtr st, char *buf, int nbytes, void *opaque) {\n      int *fd = opaque;\n\n      return read(*fd, buf, nbytes);\n  }\n\n  int myskip(virStreamPtr st, long long offset, void *opaque) {\n      int *fd = opaque;\n\n      return lseek(*fd, offset, SEEK_CUR) == (off_t) -1 ? -1 : 0;\n  }\n\n  int myindata(virStreamPtr st, int *inData,\n               long long *offset, void *opaque) {\n      int *fd = opaque;\n\n      if (@fd in hole) {\n          *inData = 0;\n          *offset = holeSize;\n      } else {\n          *inData = 1;\n          *offset = dataSize;\n      }\n\n      return 0;\n  }\n\n  virStreamPtr st = virStreamNew(conn, 0);\n  int fd = open(\"demo.iso\", O_RDONLY);\n\n  virConnectUploadSparseFile(conn, st);\n  if (virStreamSparseSendAll(st,\n                             mysource,\n                             myindata,\n                             myskip,\n                             &fd) < 0) {\n     ...report an error ...\n     goto done;\n  }\n  if (virStreamFinish(st) < 0)\n     ...report an error...\n  virStreamFree(st);\n  close(fd);\n\nNote that @opaque data are shared between @handler, @holeHandler and @skipHandler."],"return":[{"$":{"type":"int","info":"0 if all the data was successfully sent. The caller should invoke virStreamFinish(st) to flush the stream upon success and then virStreamFree.  Returns -1 upon any error, with virStreamAbort() already having been called,  so the caller need only call virStreamFree()."}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"pointer to the stream object"}},{"$":{"name":"handler","type":"virStreamSourceFunc","info":"source callback for reading data from application"}},{"$":{"name":"holeHandler","type":"virStreamSourceHoleFunc","info":"source callback for determining holes"}},{"$":{"name":"skipHandler","type":"virStreamSourceSkipFunc","info":"skip holes as reported by @holeHandler"}},{"$":{"name":"opaque","type":"void *","info":"application defined data"}}]},{"$":{"name":"virTypedParamsAddBoolean","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with boolean type and sets its value to\n@value. If @params array points to NULL or to a space that is not large\nenough to accommodate the new parameter (@maxparams < @nparams + 1), the\nfunction allocates more space for it and updates @maxparams. On success,\n@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG\nerror if the parameter already exists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"int","info":"the value to store into the new parameter"}}]},{"$":{"name":"virTypedParamsAddDouble","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with double type and sets its value to\n@value. If @params array points to NULL or to a space that is not large\nenough to accommodate the new parameter (@maxparams < @nparams + 1), the\nfunction allocates more space for it and updates @maxparams. On success,\n@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG\nerror if the parameter already exists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"double","info":"the value to store into the new parameter"}}]},{"$":{"name":"virTypedParamsAddFromString","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with the requested @type and parses its\nvalue from the @value string. If the requested type is string, the function\ncreates its own copy of the @value string, which needs to be freed using\nvirTypedParamsFree or virTypedParamsClear. If @params array points to NULL\nor to a space that is not large enough to accommodate the new parameter\n(@maxparams < @nparams + 1), the function allocates more space for it and\nupdates @maxparams. On success, @nparams is incremented by one. The\nfunction fails with VIR_ERR_INVALID_ARG error if the parameter already\nexists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"type","type":"int","info":"type of the parameter"}},{"$":{"name":"value","type":"const char *","info":"the value to store into the new parameter encoded as a string"}}]},{"$":{"name":"virTypedParamsAddInt","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with int type and sets its value to @value.\nIf @params array points to NULL or to a space that is not large enough to\naccommodate the new parameter (@maxparams < @nparams + 1), the function\nallocates more space for it and updates @maxparams. On success, @nparams\nis incremented by one. The function fails with VIR_ERR_INVALID_ARG error\nif the parameter already exists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"int","info":"the value to store into the new parameter"}}]},{"$":{"name":"virTypedParamsAddLLong","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with long long int type and sets its value\nto @value. If @params array points to NULL or to a space that is not large\nenough to accommodate the new parameter (@maxparams < @nparams + 1), the\nfunction allocates more space for it and updates @maxparams. On success,\n@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG\nerror if the parameter already exists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"long long","info":"the value to store into the new parameter"}}]},{"$":{"name":"virTypedParamsAddString","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with char * type and sets its value to\n@value. The function creates its own copy of @value string, which needs to\nbe freed using virTypedParamsFree or virTypedParamsClear. If @params array\npoints to NULL or to a space that is not large enough to accommodate the\nnew parameter (@maxparams < @nparams + 1), the function allocates more\nspace for it and updates @maxparams. On success, @nparams is incremented\nby one. The function fails with VIR_ERR_INVALID_ARG error if the parameter\nalready exists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"const char *","info":"the value to store into the new parameter"}}]},{"$":{"name":"virTypedParamsAddStringList","file":"libvirt-common","module":"virtypedparam"},"info":["Packs NULL-terminated list of strings @values into @params under the\nkey @name."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to store values to"}},{"$":{"name":"values","type":"const char **","info":"the values to store into the new parameters"}}]},{"$":{"name":"virTypedParamsAddUInt","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with unsigned int type and sets its value\nto @value. If @params array points to NULL or to a space that is not large\nenough to accommodate the new parameter (@maxparams < @nparams + 1), the\nfunction allocates more space for it and updates @maxparams. On success,\n@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG\nerror if the parameter already exists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"unsigned int","info":"the value to store into the new parameter"}}]},{"$":{"name":"virTypedParamsAddULLong","file":"libvirt-common","module":"virtypedparam"},"info":["Adds new parameter called @name with unsigned long long type and sets its\nvalue to @value. If @params array points to NULL or to a space that is not\nlarge enough to accommodate the new parameter (@maxparams < @nparams + 1),\nthe function allocates more space for it and updates @maxparams. On success,\n@nparams is incremented by one. The function fails with VIR_ERR_INVALID_ARG\nerror if the parameter already exists in @params."],"return":[{"$":{"type":"int","info":"0 on success, -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr *","info":"pointer to the array of typed parameters"}},{"$":{"name":"nparams","type":"int *","info":"number of parameters in the @params array"}},{"$":{"name":"maxparams","type":"int *","info":"maximum number of parameters that can be stored in @params array without allocating more memory"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"unsigned long long","info":"the value to store into the new parameter"}}]},{"$":{"name":"virTypedParamsClear","file":"libvirt-common","module":"virtypedparam"},"info":["Frees all memory used by string parameters. The memory occupied by @params\nis not freed; use virTypedParamsFree if you want it to be freed too."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"the array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}}]},{"$":{"name":"virTypedParamsFree","file":"libvirt-common","module":"virtypedparam"},"info":["Frees all memory used by string parameters and the memory occupied by\n@params."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"the array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}}]},{"$":{"name":"virTypedParamsGet","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name."],"return":[{"$":{"type":"virTypedParameterPtr","info":"pointer to the parameter or NULL if it does not exist in @params. This function does not raise an error, even when returning NULL."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}}]},{"$":{"name":"virTypedParamsGetBoolean","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name and store its boolean value in @value.\nThe function fails with VIR_ERR_INVALID_ARG error if the parameter does not\nhave the expected type. By passing NULL as @value, the function may be used\nto check presence and type of the parameter."],"return":[{"$":{"type":"int","info":"1 on success, 0 when the parameter does not exist in @params, or -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"int *","info":"where to store the parameter's value"}}]},{"$":{"name":"virTypedParamsGetDouble","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name and store its double value in @value.\nThe function fails with VIR_ERR_INVALID_ARG error if the parameter does not\nhave the expected type. By passing NULL as @value, the function may be used\nto check presence and type of the parameter."],"return":[{"$":{"type":"int","info":"1 on success, 0 when the parameter does not exist in @params, or -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"double *","info":"where to store the parameter's value"}}]},{"$":{"name":"virTypedParamsGetInt","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name and store its int value in @value. The\nfunction fails with VIR_ERR_INVALID_ARG error if the parameter does not\nhave the expected type. By passing NULL as @value, the function may be\nused to check presence and type of the parameter."],"return":[{"$":{"type":"int","info":"1 on success, 0 when the parameter does not exist in @params, or -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"int *","info":"where to store the parameter's value"}}]},{"$":{"name":"virTypedParamsGetLLong","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name and store its long long int value in\n@value. The function fails with VIR_ERR_INVALID_ARG error if the parameter\ndoes not have the expected type. By passing NULL as @value, the function\nmay be used to check presence and type of the parameter."],"return":[{"$":{"type":"int","info":"1 on success, 0 when the parameter does not exist in @params, or -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"long long *","info":"where to store the parameter's value"}}]},{"$":{"name":"virTypedParamsGetString","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name and store its char * value in @value.\nThe function does not create a copy of the string and the caller must not\nfree the string @value points to. The function fails with\nVIR_ERR_INVALID_ARG error if the parameter does not have the expected type.\nBy passing NULL as @value, the function may be used to check presence and\ntype of the parameter."],"return":[{"$":{"type":"int","info":"1 on success, 0 when the parameter does not exist in @params, or -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"const char **","info":"where to store the parameter's value"}}]},{"$":{"name":"virTypedParamsGetUInt","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name and store its unsigned int value in\n@value. The function fails with VIR_ERR_INVALID_ARG error if the parameter\ndoes not have the expected type. By passing NULL as @value, the function\nmay be used to check presence and type of the parameter."],"return":[{"$":{"type":"int","info":"1 on success, 0 when the parameter does not exist in @params, or -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"unsigned int *","info":"where to store the parameter's value"}}]},{"$":{"name":"virTypedParamsGetULLong","file":"libvirt-common","module":"virtypedparam"},"info":["Finds typed parameter called @name and store its unsigned long long int\nvalue in @value. The function fails with VIR_ERR_INVALID_ARG error if the\nparameter does not have the expected type. By passing NULL as @value, the\nfunction may be used to check presence and type of the parameter."],"return":[{"$":{"type":"int","info":"1 on success, 0 when the parameter does not exist in @params, or -1 on error."}}],"arg":[{"$":{"name":"params","type":"virTypedParameterPtr","info":"array of typed parameters"}},{"$":{"name":"nparams","type":"int","info":"number of parameters in the @params array"}},{"$":{"name":"name","type":"const char *","info":"name of the parameter to find"}},{"$":{"name":"value","type":"unsigned long long *","info":"where to store the parameter's value"}}]}],"functype":[{"$":{"name":"virConnectAuthCallbackPtr","file":"libvirt-host","module":"libvirt-host"},"info":["When authentication requires one or more interactions, this callback\nis invoked. For each interaction supplied, data must be gathered\nfrom the user and filled in to the 'result' and 'resultlen' fields.\nIf an interaction cannot be filled, fill in NULL and 0."],"return":[{"$":{"type":"int","info":"0 if all interactions were filled, or -1 upon error"}}],"arg":[{"$":{"name":"cred","type":"virConnectCredentialPtr","info":"list of virConnectCredential object to fetch from user"}},{"$":{"name":"ncred","type":"unsigned int","info":"size of cred list"}},{"$":{"name":"cbdata","type":"void *","info":"opaque data passed to virConnectOpenAuth"}}]},{"$":{"name":"virConnectCloseFunc","file":"libvirt-host","module":"libvirt-host"},"info":["A callback function to be registered, and called when the connection\nis closed."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}},{"$":{"name":"reason","type":"int","info":"reason why the connection was closed (one of virConnectCloseReason)"}},{"$":{"name":"opaque","type":"void *","info":"opaque user data"}}]},{"$":{"name":"virConnectDomainEventAgentLifecycleCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when libvirt detects a change in the state of a guest\nagent.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_AGENT_LIFECYCLE with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"state","type":"int","info":"new state of the guest agent, one of virConnectDomainEventAgentLifecycleState"}},{"$":{"name":"reason","type":"int","info":"reason for state change; one of virConnectDomainEventAgentLifecycleReason"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventBalloonChangeCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_BALLOON_CHANGE with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"actual","type":"unsigned long long","info":"the new balloon level measured in kibibytes(blocks of 1024 bytes)"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventBlockJobCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The string returned for @disk can be used in any of the libvirt API\nthat operate on a particular disk of the domain, and depends on what\nevent type was registered with virConnectDomainEventRegisterAny().\nIf the callback was registered using the older type of\nVIR_DOMAIN_EVENT_ID_BLOCK_JOB, then @disk contains the absolute file\nname of the host resource for the active layer of the disk; however,\nthis name is unstable (pivoting via block copy or active block commit\nwill change which file is active, giving a different name for the two\nevents associated with the same job) and cannot be relied on if the\nactive layer is associated with a network resource.  If the callback\nwas registered using the newer type of VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2,\nthen @disk will contain the device target shorthand (the <target\ndev='...'/> sub-element, such as \"vda\")."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"disk","type":"const char *","info":"name associated with the affected disk (filename or target device, depending on how the callback was registered)"}},{"$":{"name":"type","type":"int","info":"type of block job (virDomainBlockJobType)"}},{"$":{"name":"status","type":"int","info":"status of the operation (virConnectDomainEventBlockJobStatus)"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventBlockThresholdCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The callback occurs when the hypervisor detects that the given storage\nelement was written beyond the point specified by @threshold. The excess\ndata size written beyond @threshold is reported by @excess (if supported\nby the hypervisor, 0 otherwise). The event is useful for thin-provisioned\nstorage.\n\nThe threshold size can be set via the virDomainSetBlockThreshold API.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_BLOCK_THRESHOLD with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"dev","type":"const char *","info":"name associated with the affected disk or storage backing chain element"}},{"$":{"name":"path","type":"const char *","info":"for local storage, the path of the backing chain element"}},{"$":{"name":"threshold","type":"unsigned long long","info":"threshold offset in bytes"}},{"$":{"name":"excess","type":"unsigned long long","info":"number of bytes written beyond the threshold"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["A callback function to be registered, and called when a domain event occurs"],"return":[{"$":{"type":"int","info":"0 (the return value is currently ignored)"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"virConnect connection"}},{"$":{"name":"dom","type":"virDomainPtr","info":"The domain on which the event occurred"}},{"$":{"name":"event","type":"int","info":"The specific virDomainEventType which occurred"}},{"$":{"name":"detail","type":"int","info":"event specific detail information"}},{"$":{"name":"opaque","type":"void *","info":"opaque user data"}}]},{"$":{"name":"virConnectDomainEventDeviceAddedCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when a device is added to the domain.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_DEVICE_ADDED with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"devAlias","type":"const char *","info":"device alias"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventDeviceRemovalFailedCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when it's certain that removal of a device failed.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_DEVICE_REMOVAL_FAILED with\nvirConnectDomainEventRegisterAny()."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"devAlias","type":"const char *","info":"device alias"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventDeviceRemovedCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when a device is removed from the domain.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_DEVICE_REMOVED with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"devAlias","type":"const char *","info":"device alias"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventDiskChangeCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when disk gets changed. However,\nnot all @reason will cause both @oldSrcPath and @newSrcPath\nto be non-NULL. Please see virConnectDomainEventDiskChangeReason\nfor more details.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_DISK_CHANGE with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"oldSrcPath","type":"const char *","info":"old source path"}},{"$":{"name":"newSrcPath","type":"const char *","info":"new source path"}},{"$":{"name":"devAlias","type":"const char *","info":"device alias name"}},{"$":{"name":"reason","type":"int","info":"reason why this callback was called; any of virConnectDomainEventDiskChangeReason"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventGenericCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["A generic domain event callback handler, for use with\nvirConnectDomainEventRegisterAny(). Specific events usually\nhave a customization with extra parameters, often with @opaque being\npassed in a different parameter position; use VIR_DOMAIN_EVENT_CALLBACK()\nwhen registering an appropriate handler."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"the connection pointer"}},{"$":{"name":"dom","type":"virDomainPtr","info":"the domain pointer"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventGraphicsCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_GRAPHICS with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"phase","type":"int","info":"the phase of the connection"}},{"$":{"name":"local","type":"const virDomainEventGraphicsAddress *","info":"the local server address"}},{"$":{"name":"remote","type":"const virDomainEventGraphicsAddress *","info":"the remote client address"}},{"$":{"name":"authScheme","type":"const char *","info":"the authentication scheme activated"}},{"$":{"name":"subject","type":"const virDomainEventGraphicsSubject *","info":"the authenticated subject (user)"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventIOErrorCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_IO_ERROR with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"srcPath","type":"const char *","info":"The host file on which the IO error occurred"}},{"$":{"name":"devAlias","type":"const char *","info":"The guest device alias associated with the path"}},{"$":{"name":"action","type":"int","info":"action that is to be taken due to the IO error"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventIOErrorReasonCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_IO_ERROR_REASON with virConnectDomainEventRegisterAny()\n\nIf the I/O error is known to be caused by an ENOSPC condition in\nthe host (where resizing the disk to be larger will allow the guest\nto be resumed as if nothing happened), @reason will be \"enospc\".\nOtherwise, @reason will be \"\", although future strings may be added\nif determination of other error types becomes possible."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"srcPath","type":"const char *","info":"The host file on which the IO error occurred"}},{"$":{"name":"devAlias","type":"const char *","info":"The guest device alias associated with the path"}},{"$":{"name":"action","type":"int","info":"action that is to be taken due to the IO error"}},{"$":{"name":"reason","type":"const char *","info":"the cause of the IO error"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventJobCompletedCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when a job (such as migration) running on the domain\nis completed. The params array will contain statistics of the just completed\njob as virDomainGetJobStats would return. The callback must not free @params\n(the array will be freed once the callback finishes).\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_JOB_COMPLETED with\nvirConnectDomainEventRegisterAny()."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"job statistics stored as an array of virTypedParameter"}},{"$":{"name":"nparams","type":"int","info":"size of the params array"}},{"$":{"name":"opaque","type":"void *","info":"application specific data"}}]},{"$":{"name":"virConnectDomainEventMetadataChangeCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback is triggered when the domain XML metadata is changed\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_METADATA_CHANGE with virConnectDomainEventRegisterAny()."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"type","type":"int","info":"a value from virDomainMetadataTypea"}},{"$":{"name":"nsuri","type":"const char *","info":"XML namespace URI"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventMigrationIterationCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs during live migration when a new iteration over\ndomain's memory starts. The @iteration value is increased by one every\ntime a new iteration is started to transfer memory pages dirtied since\nthe last iteration.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_MIGRATION_ITERATION with\nvirConnectDomainEventRegisterAny()."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"iteration","type":"int","info":"current iteration over domain's memory"}},{"$":{"name":"opaque","type":"void *","info":"application specific data"}}]},{"$":{"name":"virConnectDomainEventPMSuspendCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when the guest is suspended.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_PMSUSPEND with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"reason","type":"int","info":"reason why the callback was called, unused currently, always passes 0"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventPMSuspendDiskCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when the guest is suspended to disk.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_PMSUSPEND_DISK with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"reason","type":"int","info":"reason why the callback was called, unused currently, always passes 0"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventPMWakeupCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when the guest is woken up.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_PMWAKEUP with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"reason","type":"int","info":"reason why the callback was called, unused currently, always passes 0"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventRTCChangeCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_RTC_CHANGE with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"utcoffset","type":"long long","info":"the new RTC offset from UTC, measured in seconds"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventTrayChangeCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when the tray of a removable device is moved.\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_TRAY_CHANGE with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"devAlias","type":"const char *","info":"device alias"}},{"$":{"name":"reason","type":"int","info":"why the tray status was changed?"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventTunableCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["This callback occurs when tunable values are updated. The params must not\nbe freed in the callback handler as it's done internally after the callback\nhandler is executed.\n\nCurrently supported name spaces:\n \"cputune.*\"\n \"blkdeviotune.*\"\n\nThe callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_TUNABLE with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"params","type":"virTypedParameterPtr","info":"changed tunable values stored as array of virTypedParameter"}},{"$":{"name":"nparams","type":"int","info":"size of the array"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectDomainEventWatchdogCallback","file":"libvirt-domain","module":"libvirt-domain"},"info":["The callback signature to use when registering for an event of type\nVIR_DOMAIN_EVENT_ID_WATCHDOG with virConnectDomainEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dom","type":"virDomainPtr","info":"domain on which the event occurred"}},{"$":{"name":"action","type":"int","info":"action that is to be taken due to watchdog firing"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectNetworkEventGenericCallback","file":"libvirt-network","module":"libvirt-network"},"info":["A generic network event callback handler, for use with\nvirConnectNetworkEventRegisterAny(). Specific events usually\nhave a customization with extra parameters, often with @opaque being\npassed in a different parameter position; use VIR_NETWORK_EVENT_CALLBACK()\nwhen registering an appropriate handler."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"the connection pointer"}},{"$":{"name":"net","type":"virNetworkPtr","info":"the network pointer"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectNetworkEventLifecycleCallback","file":"libvirt-network","module":"libvirt-network"},"info":["This callback occurs when the network is started or stopped.\n\nThe callback signature to use when registering for an event of type\nVIR_NETWORK_EVENT_ID_LIFECYCLE with virConnectNetworkEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"net","type":"virNetworkPtr","info":"network on which the event occurred"}},{"$":{"name":"event","type":"int","info":"The specific virNetworkEventLifeCycleType which occurred"}},{"$":{"name":"detail","type":"int","info":"contains some details on the reason of the event. It will be 0 for the while."}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectNodeDeviceEventGenericCallback","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["A generic node device event callback handler, for use with\nvirConnectNodeDeviceEventRegisterAny(). Specific events usually\nhave a customization with extra parameters, often with @opaque being\npassed in a different parameter position; use\nVIR_NODE_DEVICE_EVENT_CALLBACK() when registering an appropriate handler."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"the connection pointer"}},{"$":{"name":"dev","type":"virNodeDevicePtr","info":"the node device pointer"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectNodeDeviceEventLifecycleCallback","file":"libvirt-nodedev","module":"libvirt-nodedev"},"info":["This callback is called when a node device lifecycle action is performed,\nlike added or removed.\n\nThe callback signature to use when registering for an event of type\nVIR_NODE_DEVICE_EVENT_ID_LIFECYCLE with\nvirConnectNodeDeviceEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"dev","type":"virNodeDevicePtr","info":"node device on which the event occurred"}},{"$":{"name":"event","type":"int","info":"The specific virNodeDeviceEventLifeCycleType which occurred"}},{"$":{"name":"detail","type":"int","info":"contains some details on the reason of the event."}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectSecretEventGenericCallback","file":"libvirt-secret","module":"libvirt-secret"},"info":["A generic secret event callback handler, for use with\nvirConnectSecretEventRegisterAny(). Specific events usually\nhave a customization with extra parameters, often with @opaque being\npassed in a different parameter position; use\nVIR_SECRET_EVENT_CALLBACK() when registering an appropriate handler."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"the connection pointer"}},{"$":{"name":"secret","type":"virSecretPtr","info":"the secret pointer"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectSecretEventLifecycleCallback","file":"libvirt-secret","module":"libvirt-secret"},"info":["This callback is called when a secret lifecycle action is performed,\nlike added or removed.\n\nThe callback signature to use when registering for an event of type\nVIR_SECRET_EVENT_ID_LIFECYCLE with\nvirConnectSecretEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"secret","type":"virSecretPtr","info":"secret on which the event occurred"}},{"$":{"name":"event","type":"int","info":"The specific virSecretEventLifeCycleType which occurred"}},{"$":{"name":"detail","type":"int","info":"contains some details on the reason of the event."}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectStoragePoolEventGenericCallback","file":"libvirt-storage","module":"libvirt-storage"},"info":["A generic storage pool event callback handler, for use with\nvirConnectStoragePoolEventRegisterAny(). Specific events usually\nhave a customization with extra parameters, often with @opaque being\npassed in a different parameter position; use\nVIR_STORAGE_POOL_EVENT_CALLBACK() when registering an appropriate handler."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"the connection pointer"}},{"$":{"name":"pool","type":"virStoragePoolPtr","info":"the pool pointer"}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virConnectStoragePoolEventLifecycleCallback","file":"libvirt-storage","module":"libvirt-storage"},"info":["This callback is called when a pool lifecycle action is performed, like start\nor stop.\n\nThe callback signature to use when registering for an event of type\nVIR_STORAGE_POOL_EVENT_ID_LIFECYCLE with\nvirConnectStoragePoolEventRegisterAny()"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"conn","type":"virConnectPtr","info":"connection object"}},{"$":{"name":"pool","type":"virStoragePoolPtr","info":"pool on which the event occurred"}},{"$":{"name":"event","type":"int","info":"The specific virStoragePoolEventLifeCycleType which occurred"}},{"$":{"name":"detail","type":"int","info":"contains some details on the reason of the event."}},{"$":{"name":"opaque","type":"void *","info":"application specified data"}}]},{"$":{"name":"virErrorFunc","file":"virterror","module":"virterror"},"info":["Signature of a function to use when there is an error raised by the library."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"userData","type":"void *","info":"user provided data for the error callback"}},{"$":{"name":"error","type":"virErrorPtr","info":"the error being raised."}}]},{"$":{"name":"virEventAddHandleFunc","file":"libvirt-event","module":"libvirt-event"},"info":["Part of the EventImpl, this callback adds a file handle callback to\nlisten for specific events. The same file handle can be registered\nmultiple times provided the requested event sets are non-overlapping\n\nIf the opaque user data requires free'ing when the handle\nis unregistered, then a 2nd callback can be supplied for\nthis purpose. This callback needs to be invoked from a clean stack.\nIf 'ff' callbacks are invoked directly from the virEventRemoveHandleFunc\nthey will likely deadlock in libvirt."],"return":[{"$":{"type":"int","info":"-1 if the file handle cannot be registered, otherwise a handle watch number to be used for updating and unregistering for events"}}],"arg":[{"$":{"name":"fd","type":"int","info":"file descriptor to listen on"}},{"$":{"name":"event","type":"int","info":"bitset of events on which to fire the callback"}},{"$":{"name":"cb","type":"virEventHandleCallback","info":"the callback to be called when an event occurrs"}},{"$":{"name":"opaque","type":"void *","info":"user data to pass to the callback"}},{"$":{"name":"ff","type":"virFreeCallback","info":"the callback invoked to free opaque data blob"}}]},{"$":{"name":"virEventAddTimeoutFunc","file":"libvirt-event","module":"libvirt-event"},"info":["Part of the EventImpl, this user-defined callback handles adding an\nevent timeout.\n\nIf the opaque user data requires free'ing when the handle\nis unregistered, then a 2nd callback can be supplied for\nthis purpose."],"return":[{"$":{"type":"int","info":"a timer value"}}],"arg":[{"$":{"name":"timeout","type":"int","info":"The timeout to monitor"}},{"$":{"name":"cb","type":"virEventTimeoutCallback","info":"the callback to call when timeout has expired"}},{"$":{"name":"opaque","type":"void *","info":"user data to pass to the callback"}},{"$":{"name":"ff","type":"virFreeCallback","info":"the callback invoked to free opaque data blob"}}]},{"$":{"name":"virEventHandleCallback","file":"libvirt-event","module":"libvirt-event"},"info":["Callback for receiving file handle events. The callback will\nbe invoked once for each event which is pending."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"watch","type":"int","info":"watch on which the event occurred"}},{"$":{"name":"fd","type":"int","info":"file handle on which the event occurred"}},{"$":{"name":"events","type":"int","info":"bitset of events from virEventHandleType constants"}},{"$":{"name":"opaque","type":"void *","info":"user data registered with handle"}}]},{"$":{"name":"virEventRemoveHandleFunc","file":"libvirt-event","module":"libvirt-event"},"info":["Part of the EventImpl, this user-provided callback is notified when\nan fd is no longer being listened on.\n\nIf a virEventHandleFreeFunc was supplied when the handle was\nregistered, it will be invoked some time during, or after this\nfunction call, when it is safe to release the user data."],"return":[{"$":{"type":"int","info":"-1 if the file handle was not registered, 0 upon success"}}],"arg":[{"$":{"name":"watch","type":"int","info":"file descriptor watch to stop listening on"}}]},{"$":{"name":"virEventRemoveTimeoutFunc","file":"libvirt-event","module":"libvirt-event"},"info":["Part of the EventImpl, this user-defined callback removes a timer\n\nIf a virEventTimeoutFreeFunc was supplied when the handle was\nregistered, it will be invoked some time during, or after this\nfunction call, when it is safe to release the user data."],"return":[{"$":{"type":"int","info":"0 on success, -1 on failure"}}],"arg":[{"$":{"name":"timer","type":"int","info":"the timer to remove"}}]},{"$":{"name":"virEventTimeoutCallback","file":"libvirt-event","module":"libvirt-event"},"info":["callback for receiving timer events"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"timer","type":"int","info":"timer id emitting the event"}},{"$":{"name":"opaque","type":"void *","info":"user data registered with handle"}}]},{"$":{"name":"virEventUpdateHandleFunc","file":"libvirt-event","module":"libvirt-event"},"info":["Part of the EventImpl, this user-provided callback is notified when\nevents to listen on change"],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"watch","type":"int","info":"file descriptor watch to modify"}},{"$":{"name":"event","type":"int","info":"new events to listen on"}}]},{"$":{"name":"virEventUpdateTimeoutFunc","file":"libvirt-event","module":"libvirt-event"},"info":["Part of the EventImpl, this user-defined callback updates an\nevent timeout."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"timer","type":"int","info":"the timer to modify"}},{"$":{"name":"timeout","type":"int","info":"the new timeout value"}}]},{"$":{"name":"virFreeCallback","file":"libvirt-common","module":"libvirt-common"},"info":["Type for a callback cleanup function to be paired with a callback.  This\nfunction will be called as a final chance to clean up the @opaque\nregistered with the primary callback, at the time when the primary\ncallback is deregistered.\n\nIt is forbidden to call any other libvirt APIs from an\nimplementation of this callback, since it can be invoked\nfrom a context which is not re-entrant safe. Failure to\nabide by this requirement may lead to application deadlocks\nor crashes."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"opaque","type":"void *","info":"opaque user data provided at registration"}}]},{"$":{"name":"virStreamEventCallback","file":"libvirt-stream","module":"libvirt-stream"},"info":["Callback for receiving stream events. The callback will\nbe invoked once for each event which is pending."],"return":[{"$":{"type":"void"}}],"arg":[{"$":{"name":"stream","type":"virStreamPtr","info":"stream on which the event occurred"}},{"$":{"name":"events","type":"int","info":"bitset of events from virEventHandleType constants"}},{"$":{"name":"opaque","type":"void *","info":"user data registered with handle"}}]},{"$":{"name":"virStreamSinkFunc","file":"libvirt-stream","module":"libvirt-stream"},"info":["The virStreamSinkFunc callback is used together with the\nvirStreamRecvAll or virStreamSparseRecvAll functions for\nlibvirt to provide the data that has been received.\n\nThe callback will be invoked multiple times,\nproviding data in small chunks. The application\nshould consume up 'nbytes' from the 'data' array\nof data and then return the number actual number\nof bytes consumed. The callback will continue to be\ninvoked until it indicates the end of the stream\nhas been reached. A return value of -1 at any time\nwill abort the receive operation\n\nPlease note that for more accurate error reporting the\ncallback should set appropriate errno on failure."],"return":[{"$":{"type":"int","info":"the number of bytes consumed or -1 upon error"}}],"arg":[{"$":{"name":"st","type":"virStreamPtr","info":"the stream object"}},{"$":{"name":"data","type":"const char *","info":"preallocated array to be filled with data"}},{"$":{"name":"nbytes","type":"size_t","info":"size of the data array"}},{"$":{"name":"opaque","type":"void *","info":"optional application provided data"}}]},{"$":{"name":"virStreamSinkHoleFunc","file":"libvirt-stream","module":"libvirt-stream"},"info":["This callback is used together with the virStreamSparseRecvAll\nfunction for libvirt to provide the size of a hole that\noccurred in the stream.\n\nThe callback may be invoked multiple times as holes are found\nduring processing a stream. The application should create the\nhole in the stream target and then return. A return value of\n-1 at any time will abort the receive operation.\n\nPlease note that for more accurate error reporting the\ncallback should set appropriate errno on failure."],"return":[{"$":{"type":"int","info":"0 on success, -1 upon error"}}],"arg":[{"$":{"name":"st","type":"virStreamPtr","info":"the stream object"}},{"$":{"name":"length","type":"long long","info":"stream hole size"}},{"$":{"name":"opaque","type":"void *","info":"optional application provided data"}}]},{"$":{"name":"virStreamSourceFunc","file":"libvirt-stream","module":"libvirt-stream"},"info":["The virStreamSourceFunc callback is used together with\nthe virStreamSendAll and virStreamSparseSendAll functions\nfor libvirt to obtain the data that is to be sent.\n\nThe callback will be invoked multiple times,\nfetching data in small chunks. The application\nshould fill the 'data' array with up to 'nbytes'\nof data and then return the number actual number\nof bytes. The callback will continue to be\ninvoked until it indicates the end of the source\nhas been reached by returning 0. A return value\nof -1 at any time will abort the send operation.\n\nPlease note that for more accurate error reporting the\ncallback should set appropriate errno on failure."],"return":[{"$":{"type":"int","info":"the number of bytes filled, 0 upon end of file, or -1 upon error"}}],"arg":[{"$":{"name":"st","type":"virStreamPtr","info":"the stream object"}},{"$":{"name":"data","type":"char *","info":"preallocated array to be filled with data"}},{"$":{"name":"nbytes","type":"size_t","info":"size of the data array"}},{"$":{"name":"opaque","type":"void *","info":"optional application provided data"}}]},{"$":{"name":"virStreamSourceHoleFunc","file":"libvirt-stream","module":"libvirt-stream"},"info":["The virStreamSourceHoleFunc callback is used together with the\nvirStreamSparseSendAll function for libvirt to obtain the\nlength of section stream is currently in.\n\nMoreover, upon successful return, @length should be updated\nwith how many bytes are left until the current section ends\n(either data section or hole section). Also the stream is\ncurrently in data section, @inData should be set to a non-zero\nvalue and vice versa.\n\nNB: there's an implicit hole at the end of each file. If\nthat's the case, @inData and @length should be both set to 0.\n\nThis function should not adjust the current position within\nthe file.\n\nPlease note that for more accurate error reporting the\ncallback should set appropriate errno on failure."],"return":[{"$":{"type":"int","info":"0 on success, -1 upon error"}}],"arg":[{"$":{"name":"st","type":"virStreamPtr","info":"the stream object"}},{"$":{"name":"inData","type":"int *","info":"are we in data section"}},{"$":{"name":"length","type":"long long *","info":"how long is the section we are currently in"}},{"$":{"name":"opaque","type":"void *","info":"optional application provided data"}}]},{"$":{"name":"virStreamSourceSkipFunc","file":"libvirt-stream","module":"libvirt-stream"},"info":["This callback is used together with the virStreamSparseSendAll\nto skip holes in the underlying file as reported by\nvirStreamSourceHoleFunc.\n\nThe callback may be invoked multiple times as holes are found\nduring processing a stream. The application should skip\nprocessing the hole in the stream source and then return.\nA return value of -1 at any time will abort the send operation.\n\nPlease note that for more accurate error reporting the\ncallback should set appropriate errno on failure."],"return":[{"$":{"type":"int","info":"0 on success, -1 upon error."}}],"arg":[{"$":{"name":"st","type":"virStreamPtr","info":"the stream object"}},{"$":{"name":"length","type":"long long","info":"stream hole size"}},{"$":{"name":"opaque","type":"void *","info":"optional application provided data"}}]}]}]}}